# 常用搜索算法详解

## 1. 线性搜索 (Linear Search)

### 1.1 算法原理

线性搜索是最简单的搜索算法，从数组的第一个元素开始，逐个检查每个元素，直到找到目标元素或遍历完整个数组。

### 1.2 代码实现

```python
def linear_search(arr, target):
    """线性搜索"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # 返回目标元素的索引
    return -1  # 未找到返回 -1

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
target = 22
result = linear_search(arr, target)
print(f"元素 {target} 在索引 {result}")
```

### 1.3 时间复杂度

- **最好情况**: O(1) - 目标元素在第一个位置
- **平均情况**: O(n)
- **最坏情况**: O(n) - 目标元素在最后或不存在
- **空间复杂度**: O(1)

### 1.4 优缺点

**优点**:
- 实现简单
- 不要求数组有序
- 适用于小规模数据

**缺点**:
- 效率较低
- 大规模数据性能差

## 2. 二分搜索 (Binary Search)

### 2.1 算法原理

二分搜索要求数组必须是有序的。算法通过比较中间元素来决定在左半部分还是右半部分继续搜索，每次将搜索范围缩小一半。

### 2.2 代码实现

```python
def binary_search(arr, target):
    """二分搜索（迭代实现）"""
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

def binary_search_recursive(arr, target, left=0, right=None):
    """二分搜索（递归实现）"""
    if right is None:
        right = len(arr) - 1

    if left > right:
        return -1

    mid = (left + right) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# 测试
arr = [11, 12, 22, 25, 34, 64, 90]  # 必须是有序数组
target = 25
result = binary_search(arr, target)
print(f"元素 {target} 在索引 {result}")
```

### 2.3 时间复杂度

- **所有情况**: O(log n)
- **空间复杂度**: O(1) - 迭代实现，O(log n) - 递归实现

### 2.4 二分搜索变体

```python
def binary_search_first(arr, target):
    """查找第一个等于目标值的元素"""
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid
            right = mid - 1  # 继续在左半部分查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

def binary_search_last(arr, target):
    """查找最后一个等于目标值的元素"""
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid
            left = mid + 1  # 继续在右半部分查找
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

def binary_search_left_bound(arr, target):
    """查找第一个大于等于目标值的元素"""
    left, right = 0, len(arr) - 1
    result = len(arr)

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] >= target:
            result = mid
            right = mid - 1
        else:
            left = mid + 1

    return result

# 测试
arr = [1, 2, 2, 2, 3, 4, 5]
print(f"第一个2在索引: {binary_search_first(arr, 2)}")    # 1
print(f"最后一个2在索引: {binary_search_last(arr, 2)}")    # 3
print(f"第一个>=3在索引: {binary_search_left_bound(arr, 3)}")  # 4
```

## 3. 深度优先搜索 (DFS)

### 3.1 算法原理

DFS 是一种用于遍历或搜索树或图的算法。它沿着树的深度尽可能深地搜索树的分支。

### 3.2 代码实现

```python
# 图的表示
graph = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': ['F'],
    'F': []
}

def dfs_recursive(graph, start, visited=None):
    """DFS 递归实现"""
    if visited is None:
        visited = set()

    visited.add(start)
    print(start, end=' ')

    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

    return visited

def dfs_iterative(graph, start):
    """DFS 迭代实现（使用栈）"""
    visited = set()
    stack = [start]

    while stack:
        vertex = stack.pop()

        if vertex not in visited:
            visited.add(vertex)
            print(vertex, end=' ')

            # 将邻居节点压入栈
            for neighbor in reversed(graph[vertex]):
                if neighbor not in visited:
                    stack.append(neighbor)

    return visited

# 测试
print("DFS 递归:")
dfs_recursive(graph, 'A')
print("\nDFS 迭代:")
dfs_iterative(graph, 'A')
```

### 3.3 应用场景

- 路径查找
- 拓扑排序
- 检测环
- 解决迷宫问题
- 连通性检测

## 4. 广度优先搜索 (BFS)

### 4.1 算法原理

BFS 是一种用于遍历或搜索树或图的算法。它先访问起始顶点，然后访问所有邻居，再访问邻居的邻居，以此类推。

### 4.2 代码实现

```python
from collections import deque

def bfs(graph, start):
    """BFS 实现"""
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        vertex = queue.popleft()
        print(vertex, end=' ')

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

    return visited

def bfs_shortest_path(graph, start, goal):
    """使用 BFS 查找最短路径"""
    visited = set()
    queue = deque([(start, [start])])
    visited.add(start)

    while queue:
        vertex, path = queue.popleft()

        if vertex == goal:
            return path

        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))

    return None

# 测试
print("BFS:")
bfs(graph, 'A')
print("\n最短路径 A -> F:", bfs_shortest_path(graph, 'A', 'F'))
```

### 4.3 应用场景

- 最短路径（无权图）
- 层次遍历
- 连通性检测
- 社交网络分析（查找好友关系）

## 5. 二叉搜索树 (BST) 搜索

### 5.1 BST 定义

```python
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None

class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)

    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)

    def search(self, val):
        """搜索节点"""
        return self._search_recursive(self.root, val)

    def _search_recursive(self, node, val):
        if not node or node.val == val:
            return node

        if val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)

    def inorder_traversal(self):
        """中序遍历（得到有序序列）"""
        result = []
        self._inorder_recursive(self.root, result)
        return result

    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.val)
            self._inorder_recursive(node.right, result)

# 测试
bst = BST()
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)

print("中序遍历:", bst.inorder_traversal())
print("搜索40:", "找到" if bst.search(40) else "未找到")
print("搜索100:", "找到" if bst.search(100) else "未找到")
```

### 5.2 时间复杂度

- **平均情况**: O(log n)
- **最坏情况**: O(n) - 树退化为链表

## 6. 哈希表搜索

### 6.1 算法原理

哈希表通过哈希函数将键映射到数组索引，实现 O(1) 平均时间复杂度的查找。

### 6.2 代码实现

```python
class HashTable:
    """简单的哈希表实现"""

    def __init__(self, size=10):
        self.size = size
        self.table = [[] for _ in range(size)]

    def _hash(self, key):
        """哈希函数"""
        return hash(key) % self.size

    def insert(self, key, value):
        """插入键值对"""
        index = self._hash(key)

        # 检查键是否已存在
        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                self.table[index][i] = (key, value)
                return

        # 添加新键值对
        self.table[index].append((key, value))

    def search(self, key):
        """搜索键对应的值"""
        index = self._hash(key)

        for k, v in self.table[index]:
            if k == key:
                return v

        return None

    def delete(self, key):
        """删除键值对"""
        index = self._hash(key)

        for i, (k, v) in enumerate(self.table[index]):
            if k == key:
                del self.table[index][i]
                return True

        return False

# 测试
ht = HashTable()
ht.insert("apple", 1)
ht.insert("banana", 2)
ht.insert("cherry", 3)

print("搜索apple:", ht.search("apple"))
print("搜索banana:", ht.search("banana"))
print("搜索grape:", ht.search("grape"))
```

### 6.3 时间复杂度

- **平均情况**: O(1)
- **最坏情况**: O(n) - 所有键哈希到同一个桶

## 7. 搜索算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 数据结构要求 | 适用场景 |
|------|-----------|-----------|-------------|---------|
| 线性搜索 | O(n) | O(1) | 无要求 | 小规模数据 |
| 二分搜索 | O(log n) | O(1) | 有序数组 | 静态有序数据 |
| BST 搜索 | O(log n) | O(n) | 二叉搜索树 | 动态数据 |
| 哈希表 | O(1) | O(n) | 哈希表 | 快速查找 |
| DFS | O(V + E) | O(V) | 图/树 | 路径搜索 |
| BFS | O(V + E) | O(V) | 图/树 | 最短路径 |

## 8. Python 内置搜索方法

### 8.1 列表搜索

```python
arr = [1, 2, 3, 4, 5, 3, 6]

# index() - 返回第一个匹配元素的索引
index = arr.index(3)
print("第一个3的索引:", index)

# count() - 统计元素出现次数
count = arr.count(3)
print("3出现的次数:", count)

# in 操作符 - 检查元素是否存在
exists = 3 in arr
print("3是否存在:", exists)
```

### 8.2 二分搜索模块

```python
import bisect

arr = [1, 3, 4, 4, 6, 8, 10]

# bisect_left - 返回插入点（最左位置）
pos = bisect.bisect_left(arr, 4)
print("4的最左位置:", pos)  # 2

# bisect_right - 返回插入点（最右位置）
pos = bisect.bisect_right(arr, 4)
print("4的最右位置:", pos)  # 4

# insort - 插入并保持有序
bisect.insort(arr, 5)
print("插入5后:", arr)
```

## 9. 实际应用示例

### 9.1 查找旋转排序数组中的最小值

```python
def find_min_in_rotated_array(arr):
    """查找旋转排序数组中的最小值"""
    left, right = 0, len(arr) - 1

    while left < right:
        mid = (left + right) // 2

        if arr[mid] > arr[right]:
            left = mid + 1
        else:
            right = mid

    return arr[left]

# 测试
arr = [4, 5, 6, 7, 0, 1, 2]
print("最小值:", find_min_in_rotated_array(arr))
```

### 9.2 在二维矩阵中搜索

```python
def search_matrix(matrix, target):
    """在行列都有序的矩阵中搜索"""
    if not matrix or not matrix[0]:
        return False

    m, n = len(matrix), len(matrix[0])
    row, col = 0, n - 1

    # 从右上角开始搜索
    while row < m and col >= 0:
        if matrix[row][col] == target:
            return True
        elif matrix[row][col] > target:
            col -= 1
        else:
            row += 1

    return False

# 测试
matrix = [
    [1,  4,  7,  11],
    [2,  5,  8,  12],
    [3,  6,  9,  16],
    [10, 13, 14, 17]
]
print("搜索5:", search_matrix(matrix, 5))
print("搜索20:", search_matrix(matrix, 20))
```

## 总结

搜索算法的选择取决于：

1. **数据规模**: 小规模用线性搜索，大规模用更高效的算法
2. **数据是否有序**: 有序数据可用二分搜索
3. **数据是否动态**: 动态数据考虑 BST 或哈希表
4. **查找频率**: 频繁查找考虑哈希表或索引结构
5. **空间限制**: 空间受限考虑空间复杂度低的算法

在实际开发中：
- 简单查找用 Python 的 `in` 操作符或 `list.index()`
- 有序数据用 `bisect` 模块
- 键值对查找用字典（哈希表）
- 图/树搜索用 DFS 或 BFS
