# Python 面向对象编程 (OOP)

## 1. 面向对象编程简介

面向对象编程（Object-Oriented Programming, OOP）是一种程序设计思想，它将对象作为程序的基本单元，一个对象包含了数据和操作数据的方法。

### 1.1 OOP 的三大特性

1. **封装 (Encapsulation)**: 将数据和操作数据的方法绑定在一起
2. **继承 (Inheritance)**: 子类可以继承父类的属性和方法
3. **多态 (Polymorphism)**: 不同对象对同一消息的不同响应

## 2. 类和对象

### 2.1 定义类

```python
class Dog:
    """狗类的定义"""

    # 类属性（所有实例共享）
    species = "Canis familiaris"

    # 构造方法
    def __init__(self, name, age):
        """初始化实例属性"""
        self.name = name
        self.age = age

    # 实例方法
    def bark(self):
        """狗叫的方法"""
        return f"{self.name} says Woof!"

    def get_info(self):
        """获取狗的信息"""
        return f"{self.name} is {self.age} years old"
```

### 2.2 创建对象

```python
# 创建实例
dog1 = Dog("Buddy", 3)
dog2 = Dog("Charlie", 5)

# 访问属性
print(dog1.name)      # Buddy
print(dog1.age)       # 3
print(dog1.species)   # Canis familiaris

# 调用方法
print(dog1.bark())    # Buddy says Woof!
print(dog2.get_info()) # Charlie is 5 years old

# 修改属性
dog1.age = 4
print(dog1.age)       # 4
```

## 3. 类的属性和方法

### 3.1 实例属性 vs 类属性

```python
class Counter:
    # 类属性（所有实例共享）
    total_count = 0

    def __init__(self, name):
        # 实例属性（每个实例独有）
        self.name = name
        self.count = 0
        Counter.total_count += 1

    def increment(self):
        self.count += 1

# 使用
c1 = Counter("Counter1")
c2 = Counter("Counter2")

print(Counter.total_count)  # 2 (类属性)
print(c1.count)            # 0 (实例属性)
print(c2.count)            # 0 (实例属性)

c1.increment()
print(c1.count)            # 1
print(c2.count)            # 0 (不受影响)
```

### 3.2 实例方法、类方法和静态方法

```python
class MyClass:
    class_variable = "I'm a class variable"

    def __init__(self, value):
        self.instance_variable = value

    # 实例方法（需要 self）
    def instance_method(self):
        return f"Instance method called, value={self.instance_variable}"

    # 类方法（需要 cls）
    @classmethod
    def class_method(cls):
        return f"Class method called, class_variable={cls.class_variable}"

    # 静态方法（不需要 self 或 cls）
    @staticmethod
    def static_method():
        return "Static method called"

# 使用
obj = MyClass(10)

# 实例方法：通过实例调用
print(obj.instance_method())

# 类方法：通过类或实例调用
print(MyClass.class_method())
print(obj.class_method())

# 静态方法：通过类或实例调用
print(MyClass.static_method())
print(obj.static_method())
```

### 3.3 私有属性和方法

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        self.__balance = balance  # 私有属性（前缀双下划线）

    def deposit(self, amount):
        """存款"""
        if amount > 0:
            self.__balance += amount
            return True
        return False

    def withdraw(self, amount):
        """取款"""
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            return True
        return False

    def get_balance(self):
        """获取余额"""
        return self.__balance

    def __str__(self):
        """字符串表示"""
        return f"BankAccount(owner={self.owner}, balance={self.__balance})"

# 使用
account = BankAccount("Alice", 1000)

# 可以通过公共方法访问
print(account.get_balance())  # 1000
account.deposit(500)
print(account.get_balance())  # 1500

# 无法直接访问私有属性
# print(account.__balance)  # AttributeError

# 但可以通过名称改编访问（不推荐）
print(account._BankAccount__balance)  # 1500
```

## 4. 继承

### 4.1 单继承

```python
class Animal:
    """动物基类"""

    def __init__(self, name):
        self.name = name

    def speak(self):
        """动物叫声（基类方法）"""
        pass

    def info(self):
        """动物信息"""
        return f"I'm {self.name}"

class Dog(Animal):
    """狗类（继承自 Animal）"""

    def __init__(self, name, breed):
        super().__init__(name)  # 调用父类构造方法
        self.breed = breed

    def speak(self):
        """重写父类方法"""
        return "Woof!"

    def fetch(self):
        """狗特有的方法"""
        return f"{self.name} is fetching"

class Cat(Animal):
    """猫类（继承自 Animal）"""

    def speak(self):
        """重写父类方法"""
        return "Meow!"

# 使用
dog = Dog("Buddy", "Golden Retriever")
cat = Cat("Whiskers")

print(dog.name)     # Buddy (继承自 Animal)
print(dog.breed)    # Golden Retriever (Dog 特有)
print(dog.speak())  # Woof! (重写的方法)
print(dog.info())   # I'm Buddy (继承自 Animal)
print(dog.fetch())  # Buddy is fetching (Dog 特有)

print(cat.speak())  # Meow! (重写的方法)
print(cat.info())   # I'm Whiskers (继承自 Animal)
```

### 4.2 多继承

```python
class Flyable:
    """可飞行接口"""
    def fly(self):
        return "Flying!"

class Swimmable:
    """可游泳接口"""
    def swim(self):
        return "Swimming!"

class Duck(Animal, Flyable, Swimmable):
    """鸭子类（多继承）"""

    def speak(self):
        return "Quack!"

# 使用
duck = Duck("Donald")
print(duck.speak())  # Quack!
print(duck.fly())    # Flying!
print(duck.swim())   # Swimming!
print(duck.info())   # I'm Donald

# 查看方法解析顺序（MRO）
print(Duck.__mro__)
```

### 4.3 方法重写和 super()

```python
class Shape:
    """形状基类"""

    def __init__(self, color):
        self.color = color

    def area(self):
        """计算面积"""
        pass

    def info(self):
        """形状信息"""
        return f"A {self.color} shape"

class Rectangle(Shape):
    """矩形类"""

    def __init__(self, color, width, height):
        super().__init__(color)  # 调用父类构造方法
        self.width = width
        self.height = height

    def area(self):
        """重写面积计算方法"""
        return self.width * self.height

    def info(self):
        """扩展父类方法"""
        base_info = super().info()
        return f"{base_info} with area {self.area()}"

# 使用
rect = Rectangle("red", 5, 3)
print(rect.area())  # 15
print(rect.info())  # A red shape with area 15
```

## 5. 特殊方法（魔术方法）

### 5.1 常用特殊方法

```python
class Book:
    def __init__(self, title, author, pages):
        self.title = title
        self.author = author
        self.pages = pages

    def __str__(self):
        """字符串表示（给用户看）"""
        return f"{self.title} by {self.author}"

    def __repr__(self):
        """对象表示（给开发者看）"""
        return f"Book('{self.title}', '{self.author}', {self.pages})"

    def __len__(self):
        """返回长度"""
        return self.pages

    def __eq__(self, other):
        """相等比较"""
        if isinstance(other, Book):
            return self.title == other.title and self.author == other.author
        return False

    def __lt__(self, other):
        """小于比较"""
        return self.pages < other.pages

    def __add__(self, other):
        """加法运算"""
        if isinstance(other, Book):
            return self.pages + other.pages
        return NotImplemented

# 使用
book1 = Book("Python Basics", "Alice", 300)
book2 = Book("Advanced Python", "Bob", 450)

print(str(book1))      # Python Basics by Alice
print(repr(book1))     # Book('Python Basics', 'Alice', 300)
print(len(book1))      # 300
print(book1 == book2)  # False
print(book1 < book2)   # True (300 < 450)
print(book1 + book2)   # 750
```

### 5.2 容器类型特殊方法

```python
class MyList:
    """自定义列表类"""

    def __init__(self):
        self._items = []

    def __len__(self):
        """返回长度"""
        return len(self._items)

    def __getitem__(self, index):
        """获取元素"""
        return self._items[index]

    def __setitem__(self, index, value):
        """设置元素"""
        self._items[index] = value

    def __delitem__(self, index):
        """删除元素"""
        del self._items[index]

    def __iter__(self):
        """返回迭代器"""
        return iter(self._items)

    def __contains__(self, item):
        """成员测试"""
        return item in self._items

    def append(self, item):
        """添加元素"""
        self._items.append(item)

# 使用
my_list = MyList()
my_list.append(1)
my_list.append(2)
my_list.append(3)

print(len(my_list))      # 3
print(my_list[0])        # 1
my_list[1] = 20
print(my_list[1])        # 20
print(2 in my_list)      # False
print(20 in my_list)     # True

for item in my_list:
    print(item)          # 1, 20, 3
```

## 6. 属性装饰器

### 6.1 @property

```python
class Temperature:
    """温度类"""

    def __init__(self, celsius):
        self._celsius = celsius

    @property
    def celsius(self):
        """获取摄氏温度"""
        return self._celsius

    @celsius.setter
    def celsius(self, value):
        """设置摄氏温度"""
        if value < -273.15:
            raise ValueError("Temperature below absolute zero")
        self._celsius = value

    @property
    def fahrenheit(self):
        """获取华氏温度"""
        return self._celsius * 9/5 + 32

    @fahrenheit.setter
    def fahrenheit(self, value):
        """设置华氏温度"""
        self.celsius = (value - 32) * 5/9

# 使用
temp = Temperature(25)

print(temp.celsius)      # 25
print(temp.fahrenheit)   # 77.0

temp.celsius = 30
print(temp.fahrenheit)   # 86.0

temp.fahrenheit = 32
print(temp.celsius)      # 0.0
```

## 7. 抽象基类

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    """抽象形状类"""

    @abstractmethod
    def area(self):
        """抽象方法：计算面积"""
        pass

    @abstractmethod
    def perimeter(self):
        """抽象方法：计算周长"""
        pass

class Circle(Shape):
    """圆形类"""

    def __init__(self, radius):
        self.radius = radius

    def area(self):
        """实现抽象方法"""
        return 3.14 * self.radius ** 2

    def perimeter(self):
        """实现抽象方法"""
        return 2 * 3.14 * self.radius

# 使用
# shape = Shape()  # 报错：不能实例化抽象类
circle = Circle(5)
print(circle.area())       # 78.5
print(circle.perimeter())  # 31.400000000000002
```

## 8. 数据类 (Python 3.7+)

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class Person:
    """使用数据类定义的人员类"""
    name: str
    age: int
    email: str = "unknown@example.com"
    hobbies: List[str] = field(default_factory=list)

    def greet(self):
        return f"Hello, I'm {self.name}, {self.age} years old"

# 使用
person = Person("Alice", 25)
print(person)  # Person(name='Alice', age=25, email='unknown@example.com', hobbies=[])
print(person.greet())

# 自动生成 __init__, __repr__, __eq__ 等方法
person2 = Person("Alice", 25)
print(person == person2)  # True
```

## 总结

Python 面向对象编程的核心概念：

1. **类和对象**: 类是模板，对象是实例
2. **属性和方法**: 数据和操作的封装
3. **继承**: 代码复用和扩展
4. **特殊方法**: 自定义对象行为
5. **属性装饰器**: 优雅的属性访问控制
6. **抽象基类**: 定义接口规范

掌握这些概念可以编写更加模块化、可维护的代码。
