# 数据结构：树详解

## 1. 树的基本概念

树是一种非线性数据结构，由节点组成，具有层次关系。

### 1.1 基本术语

- **根节点 (Root)**: 树的顶端节点
- **父节点 (Parent)**: 上一层的节点
- **子节点 (Child)**: 下一层的节点
- **叶节点 (Leaf)**: 没有子节点的节点
- **深度 (Depth)**: 节点到根的路径长度
- **高度 (Height)**: 节点到最远叶节点的路径长度
- **层 (Level)**: 根节点为第0层

## 2. 二叉树

### 2.1 节点定义

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
```

### 2.2 二叉树遍历

```python
def preorder_traversal(root):
    """前序遍历：根 -> 左 -> 右"""
    if not root:
        return []

    result = []
    result.append(root.val)
    result.extend(preorder_traversal(root.left))
    result.extend(preorder_traversal(root.right))
    return result

def inorder_traversal(root):
    """中序遍历：左 -> 根 -> 右"""
    if not root:
        return []

    result = []
    result.extend(inorder_traversal(root.left))
    result.append(root.val)
    result.extend(inorder_traversal(root.right))
    return result

def postorder_traversal(root):
    """后序遍历：左 -> 右 -> 根"""
    if not root:
        return []

    result = []
    result.extend(postorder_traversal(root.left))
    result.extend(postorder_traversal(root.right))
    result.append(root.val)
    return result

def level_order_traversal(root):
    """层序遍历（BFS）"""
    if not root:
        return []

    result = []
    queue = [root]

    while queue:
        node = queue.pop(0)
        result.append(node.val)

        if node.left:
            queue.append(node.left)
        if node.right:
            queue.append(node.right)

    return result

# 测试
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.left.right = TreeNode(5)

print("前序遍历:", preorder_traversal(root))    # [1, 2, 4, 5, 3]
print("中序遍历:", inorder_traversal(root))      # [4, 2, 5, 1, 3]
print("后序遍历:", postorder_traversal(root))    # [4, 5, 2, 3, 1]
print("层序遍历:", level_order_traversal(root))  # [1, 2, 3, 4, 5]
```

### 2.3 迭代遍历

```python
def preorder_iterative(root):
    """前序遍历（迭代）"""
    if not root:
        return []

    result = []
    stack = [root]

    while stack:
        node = stack.pop()
        result.append(node.val)

        # 先右后左（栈是后进先出）
        if node.right:
            stack.append(node.right)
        if node.left:
            stack.append(node.left)

    return result

def inorder_iterative(root):
    """中序遍历（迭代）"""
    result = []
    stack = []
    current = root

    while current or stack:
        # 一直向左走
        while current:
            stack.append(current)
            current = current.left

        # 访问节点
        current = stack.pop()
        result.append(current.val)

        # 转向右子树
        current = current.right

    return result
```

## 3. 二叉搜索树 (BST)

### 3.1 BST 性质

- 左子树的所有节点值 < 根节点值
- 右子树的所有节点值 > 根节点值
- 左右子树也是BST

### 3.2 BST 实现

```python
class BST:
    def __init__(self):
        self.root = None

    def insert(self, val):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(val)
        else:
            self._insert_recursive(self.root, val)

    def _insert_recursive(self, node, val):
        if val < node.val:
            if node.left:
                self._insert_recursive(node.left, val)
            else:
                node.left = TreeNode(val)
        else:
            if node.right:
                self._insert_recursive(node.right, val)
            else:
                node.right = TreeNode(val)

    def search(self, val):
        """搜索节点"""
        return self._search_recursive(self.root, val)

    def _search_recursive(self, node, val):
        if not node:
            return False

        if node.val == val:
            return True
        elif val < node.val:
            return self._search_recursive(node.left, val)
        else:
            return self._search_recursive(node.right, val)

    def delete(self, val):
        """删除节点"""
        self.root = self._delete_recursive(self.root, val)

    def _delete_recursive(self, node, val):
        if not node:
            return None

        if val < node.val:
            node.left = self._delete_recursive(node.left, val)
        elif val > node.val:
            node.right = self._delete_recursive(node.right, val)
        else:
            # 找到要删除的节点
            # 情况1: 叶节点
            if not node.left and not node.right:
                return None

            # 情况2: 只有一个子节点
            if not node.left:
                return node.right
            if not node.right:
                return node.left

            # 情况3: 有两个子节点
            # 找到右子树的最小值替换当前节点
            min_node = self._find_min(node.right)
            node.val = min_node.val
            node.right = self._delete_recursive(node.right, min_node.val)

        return node

    def _find_min(self, node):
        """找到最小值节点"""
        while node.left:
            node = node.left
        return node

    def inorder(self):
        """中序遍历（得到有序序列）"""
        return inorder_traversal(self.root)

# 使用示例
bst = BST()
for val in [50, 30, 70, 20, 40, 60, 80]:
    bst.insert(val)

print("中序遍历:", bst.inorder())       # [20, 30, 40, 50, 60, 70, 80]
print("搜索40:", bst.search(40))        # True
bst.delete(50)
print("删除50后:", bst.inorder())       # [20, 30, 40, 60, 70, 80]
```

## 4. 平衡二叉树 (AVL树)

### 4.1 AVL树性质

- 是一棵BST
- 任何节点的左右子树高度差不超过1

### 4.2 AVL节点定义

```python
class AVLNode:
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.height = 1  # 初始高度为1

class AVLTree:
    def get_height(self, node):
        """获取节点高度"""
        if not node:
            return 0
        return node.height

    def get_balance(self, node):
        """获取平衡因子"""
        if not node:
            return 0
        return self.get_height(node.left) - self.get_height(node.right)

    def rotate_right(self, z):
        """右旋转"""
        y = z.left
        T3 = y.right

        # 旋转
        y.right = z
        z.left = T3

        # 更新高度
        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))

        return y

    def rotate_left(self, z):
        """左旋转"""
        y = z.right
        T2 = y.left

        # 旋转
        y.left = z
        z.right = T2

        # 更新高度
        z.height = 1 + max(self.get_height(z.left), self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))

        return y

    def insert(self, node, val):
        """插入节点并保持平衡"""
        # 1. 正常BST插入
        if not node:
            return AVLNode(val)

        if val < node.val:
            node.left = self.insert(node.left, val)
        else:
            node.right = self.insert(node.right, val)

        # 2. 更新高度
        node.height = 1 + max(self.get_height(node.left),
                              self.get_height(node.right))

        # 3. 获取平衡因子
        balance = self.get_balance(node)

        # 4. 如果不平衡，进行旋转
        # Left Left Case
        if balance > 1 and val < node.left.val:
            return self.rotate_right(node)

        # Right Right Case
        if balance < -1 and val > node.right.val:
            return self.rotate_left(node)

        # Left Right Case
        if balance > 1 and val > node.left.val:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)

        # Right Left Case
        if balance < -1 and val < node.right.val:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node
```

## 5. 堆 (Heap)

### 5.1 最小堆实现

```python
class MinHeap:
    def __init__(self):
        self.heap = []

    def parent(self, i):
        return (i - 1) // 2

    def left_child(self, i):
        return 2 * i + 1

    def right_child(self, i):
        return 2 * i + 2

    def swap(self, i, j):
        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]

    def insert(self, val):
        """插入元素"""
        self.heap.append(val)
        self._heapify_up(len(self.heap) - 1)

    def _heapify_up(self, i):
        """向上调整"""
        parent = self.parent(i)

        if i > 0 and self.heap[i] < self.heap[parent]:
            self.swap(i, parent)
            self._heapify_up(parent)

    def extract_min(self):
        """移除并返回最小元素"""
        if not self.heap:
            return None

        if len(self.heap) == 1:
            return self.heap.pop()

        min_val = self.heap[0]
        self.heap[0] = self.heap.pop()
        self._heapify_down(0)

        return min_val

    def _heapify_down(self, i):
        """向下调整"""
        min_index = i
        left = self.left_child(i)
        right = self.right_child(i)

        if left < len(self.heap) and self.heap[left] < self.heap[min_index]:
            min_index = left

        if right < len(self.heap) and self.heap[right] < self.heap[min_index]:
            min_index = right

        if min_index != i:
            self.swap(i, min_index)
            self._heapify_down(min_index)

    def get_min(self):
        """获取最小元素（不删除）"""
        return self.heap[0] if self.heap else None

# 使用示例
heap = MinHeap()
for val in [5, 3, 7, 1, 9, 2]:
    heap.insert(val)

print("最小值:", heap.get_min())       # 1
print("提取最小值:", heap.extract_min())  # 1
print("新的最小值:", heap.get_min())    # 2
```

### 5.2 Python heapq 模块

```python
import heapq

# 创建最小堆
heap = []
heapq.heappush(heap, 5)
heapq.heappush(heap, 3)
heapq.heappush(heap, 7)

# 从列表创建堆
data = [5, 3, 7, 1, 9, 2]
heapq.heapify(data)

# 弹出最小值
min_val = heapq.heappop(data)  # 1

# 获取最大的K个元素
largest = heapq.nlargest(3, data)

# 获取最小的K个元素
smallest = heapq.nsmallest(3, data)
```

## 6. 字典树 (Trie)

```python
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        """插入单词"""
        node = self.root

        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]

        node.is_end = True

    def search(self, word):
        """搜索完整单词"""
        node = self.root

        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]

        return node.is_end

    def starts_with(self, prefix):
        """搜索前缀"""
        node = self.root

        for char in prefix:
            if char not in node.children:
                return False
            node = node.children[char]

        return True

# 使用示例
trie = Trie()
trie.insert("apple")
trie.insert("app")

print(trie.search("app"))          # True
print(trie.search("appl"))         # False
print(trie.starts_with("app"))     # True
```

## 7. 常见树问题

### 7.1 计算树的高度

```python
def max_depth(root):
    """计算树的最大深度"""
    if not root:
        return 0
    return 1 + max(max_depth(root.left), max_depth(root.right))
```

### 7.2 判断是否为平衡二叉树

```python
def is_balanced(root):
    """判断是否为平衡二叉树"""
    def check(node):
        if not node:
            return 0, True

        left_height, left_balanced = check(node.left)
        right_height, right_balanced = check(node.right)

        balanced = (left_balanced and right_balanced and
                   abs(left_height - right_height) <= 1)

        return max(left_height, right_height) + 1, balanced

    return check(root)[1]
```

### 7.3 最近公共祖先

```python
def lowest_common_ancestor(root, p, q):
    """找到两个节点的最近公共祖先"""
    if not root or root == p or root == q:
        return root

    left = lowest_common_ancestor(root.left, p, q)
    right = lowest_common_ancestor(root.right, p, q)

    if left and right:
        return root

    return left if left else right
```

## 8. 时间复杂度对比

| 操作 | BST (平衡) | BST (不平衡) | AVL | 堆 |
|------|-----------|-------------|-----|-----|
| 搜索 | O(log n) | O(n) | O(log n) | O(n) |
| 插入 | O(log n) | O(n) | O(log n) | O(log n) |
| 删除 | O(log n) | O(n) | O(log n) | O(log n) |
| 最小值 | O(log n) | O(n) | O(log n) | O(1) |

## 总结

树是重要的非线性数据结构：
- **二叉树**: 每个节点最多两个子节点
- **BST**: 支持高效搜索、插入、删除
- **AVL树**: 自平衡BST，保证O(log n)性能
- **堆**: 优先队列的实现
- **Trie**: 字符串搜索和前缀匹配

掌握树的遍历和基本操作是算法面试的必备技能。
