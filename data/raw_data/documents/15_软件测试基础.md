# 软件测试基础知识

## 1. 软件测试简介

软件测试是验证软件产品是否满足预期需求并发现缺陷的过程。

### 1.1 测试目的

- 发现软件中的缺陷和错误
- 验证软件是否满足需求
- 评估软件质量
- 降低软件风险
- 提高用户满意度

### 1.2 测试分类

**按测试级别**:
- 单元测试
- 集成测试
- 系统测试
- 验收测试

**按测试方法**:
- 黑盒测试
- 白盒测试
- 灰盒测试

## 2. 单元测试

### 2.1 Python unittest 示例

```python
import unittest

def add(a, b):
    """加法函数"""
    return a + b

def divide(a, b):
    """除法函数"""
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

class TestMathFunctions(unittest.TestCase):
    """数学函数测试类"""

    def setUp(self):
        """每个测试前执行"""
        print("开始测试")

    def tearDown(self):
        """每个测试后执行"""
        print("测试结束")

    def test_add(self):
        """测试加法"""
        self.assertEqual(add(2, 3), 5)
        self.assertEqual(add(-1, 1), 0)
        self.assertEqual(add(0, 0), 0)

    def test_divide(self):
        """测试除法"""
        self.assertEqual(divide(10, 2), 5)
        self.assertAlmostEqual(divide(1, 3), 0.333, places=3)

    def test_divide_by_zero(self):
        """测试除零错误"""
        with self.assertRaises(ValueError):
            divide(10, 0)

if __name__ == '__main__':
    unittest.main()
```

### 2.2 pytest 示例

```python
import pytest

def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("除数不能为零")
    return a / b

# pytest 测试函数
def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
    assert add(0, 0) == 0

def test_divide():
    assert divide(10, 2) == 5
    assert abs(divide(1, 3) - 0.333) < 0.001

def test_divide_by_zero():
    with pytest.raises(ValueError):
        divide(10, 0)

# 参数化测试
@pytest.mark.parametrize("a, b, expected", [
    (2, 3, 5),
    (-1, 1, 0),
    (0, 0, 0),
    (100, 200, 300)
])
def test_add_parametrized(a, b, expected):
    assert add(a, b) == expected

# Fixture（测试夹具）
@pytest.fixture
def sample_data():
    """提供测试数据"""
    return {'users': [{'name': 'Alice', 'age': 25}]}

def test_with_fixture(sample_data):
    assert len(sample_data['users']) == 1
    assert sample_data['users'][0]['name'] == 'Alice'
```

## 3. 测试覆盖率

### 3.1 使用 coverage.py

```bash
# 安装
pip install coverage

# 运行测试并统计覆盖率
coverage run -m pytest

# 查看覆盖率报告
coverage report

# 生成HTML报告
coverage html

# 输出示例：
# Name                Stmts   Miss  Cover
# ---------------------------------------
# my_module.py           50      5    90%
# test_my_module.py      30      0   100%
# ---------------------------------------
# TOTAL                  80      5    94%
```

### 3.2 覆盖率类型

- **语句覆盖**: 代码中的每条语句是否被执行
- **分支覆盖**: 每个条件分支是否被执行
- **函数覆盖**: 每个函数是否被调用
- **路径覆盖**: 所有可能的执行路径

## 4. 集成测试

### 4.1 API 集成测试

```python
import requests
import pytest

BASE_URL = "http://localhost:8000"

class TestUserAPI:
    """用户API集成测试"""

    def test_create_user(self):
        """测试创建用户"""
        response = requests.post(f"{BASE_URL}/api/users", json={
            "name": "张三",
            "email": "zhangsan@example.com"
        })

        assert response.status_code == 201
        data = response.json()
        assert data['name'] == "张三"
        assert 'id' in data

    def test_get_user(self):
        """测试获取用户"""
        # 先创建用户
        create_response = requests.post(f"{BASE_URL}/api/users", json={
            "name": "李四",
            "email": "lisi@example.com"
        })
        user_id = create_response.json()['id']

        # 获取用户
        response = requests.get(f"{BASE_URL}/api/users/{user_id}")
        assert response.status_code == 200

        data = response.json()
        assert data['name'] == "李四"

    def test_get_nonexistent_user(self):
        """测试获取不存在的用户"""
        response = requests.get(f"{BASE_URL}/api/users/99999")
        assert response.status_code == 404
```

### 4.2 数据库集成测试

```python
import pytest
import sqlite3

@pytest.fixture
def db_connection():
    """测试数据库连接"""
    conn = sqlite3.connect(':memory:')  # 内存数据库
    cursor = conn.cursor()

    # 创建测试表
    cursor.execute('''
        CREATE TABLE users (
            id INTEGER PRIMARY KEY,
            name TEXT,
            email TEXT
        )
    ''')

    yield conn  # 提供连接给测试

    conn.close()  # 测试后清理

def test_insert_user(db_connection):
    """测试插入用户"""
    cursor = db_connection.cursor()
    cursor.execute('INSERT INTO users (name, email) VALUES (?, ?)',
                   ('张三', 'zhangsan@example.com'))
    db_connection.commit()

    # 验证插入
    cursor.execute('SELECT * FROM users WHERE name = ?', ('张三',))
    user = cursor.fetchone()

    assert user is not None
    assert user[1] == '张三'
```

## 5. Mock 和 Stub

### 5.1 使用 unittest.mock

```python
from unittest.mock import Mock, patch, MagicMock
import requests

def get_user_data(user_id):
    """从API获取用户数据"""
    response = requests.get(f"https://api.example.com/users/{user_id}")
    return response.json()

def test_get_user_data_with_mock():
    """使用Mock测试API调用"""
    # Mock requests.get
    with patch('requests.get') as mock_get:
        # 设置mock返回值
        mock_response = Mock()
        mock_response.json.return_value = {'id': 1, 'name': '张三'}
        mock_get.return_value = mock_response

        # 调用函数
        result = get_user_data(1)

        # 验证
        assert result['name'] == '张三'
        mock_get.assert_called_once_with("https://api.example.com/users/1")

# Mock类方法
class Database:
    def get_user(self, user_id):
        # 实际的数据库查询
        pass

def test_with_mock_class():
    """Mock类方法"""
    db = Mock(spec=Database)
    db.get_user.return_value = {'id': 1, 'name': '张三'}

    result = db.get_user(1)
    assert result['name'] == '张三'
```

## 6. 性能测试

### 6.1 使用 pytest-benchmark

```python
import pytest

def fibonacci(n):
    """斐波那契数列"""
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

def test_fibonacci_performance(benchmark):
    """性能测试"""
    result = benchmark(fibonacci, 10)
    assert result == 55

# 输出类似：
# test_fibonacci_performance
# Min: 0.0001s
# Max: 0.0002s
# Mean: 0.00015s
```

### 6.2 使用 locust 进行负载测试

```python
from locust import HttpUser, task, between

class WebsiteUser(HttpUser):
    """网站用户模拟"""
    wait_time = between(1, 5)  # 请求间隔1-5秒

    @task(3)  # 权重为3
    def view_homepage(self):
        """访问首页"""
        self.client.get("/")

    @task(1)  # 权重为1
    def view_about(self):
        """访问关于页面"""
        self.client.get("/about")

    def on_start(self):
        """用户开始时执行（如登录）"""
        self.client.post("/login", json={
            "username": "testuser",
            "password": "password"
        })

# 运行：locust -f locustfile.py
# 访问 http://localhost:8089 查看Web界面
```

## 7. 端到端测试

### 7.1 使用 Selenium

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

def test_login():
    """测试登录流程"""
    # 启动浏览器
    driver = webdriver.Chrome()

    try:
        # 访问登录页面
        driver.get("http://localhost:8000/login")

        # 输入用户名和密码
        username_input = driver.find_element(By.ID, "username")
        password_input = driver.find_element(By.ID, "password")

        username_input.send_keys("testuser")
        password_input.send_keys("password")

        # 点击登录按钮
        login_button = driver.find_element(By.ID, "login-button")
        login_button.click()

        # 等待跳转并验证
        WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, "welcome-message"))
        )

        welcome_message = driver.find_element(By.ID, "welcome-message")
        assert "欢迎" in welcome_message.text

    finally:
        driver.quit()
```

## 8. 测试驱动开发 (TDD)

### 8.1 TDD 流程

1. **编写测试**: 先写失败的测试
2. **实现功能**: 编写最少的代码使测试通过
3. **重构代码**: 优化代码，保持测试通过

### 8.2 TDD 示例

```python
# 步骤1: 编写测试
def test_calculate_discount():
    assert calculate_discount(100, 0.1) == 90
    assert calculate_discount(50, 0.2) == 40
    assert calculate_discount(100, 0) == 100

# 步骤2: 实现功能
def calculate_discount(price, discount_rate):
    """计算折扣后价格"""
    if not 0 <= discount_rate <= 1:
        raise ValueError("折扣率必须在0到1之间")
    return price * (1 - discount_rate)

# 步骤3: 添加更多测试和重构
def test_calculate_discount_invalid_rate():
    with pytest.raises(ValueError):
        calculate_discount(100, 1.5)
```

## 9. 持续集成 (CI)

### 9.1 GitHub Actions 配置

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2

    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'

    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run tests
      run: |
        pytest --cov=myapp tests/

    - name: Upload coverage
      uses: codecov/codecov-action@v2
```

## 10. 测试最佳实践

### 10.1 编写好的测试

```python
# 好的测试：清晰、独立、快速
def test_user_creation():
    """测试用户创建功能

    Given: 提供有效的用户数据
    When: 调用创建用户函数
    Then: 应该成功创建用户并返回用户ID
    """
    user_data = {
        'name': '张三',
        'email': 'zhangsan@example.com'
    }

    user = create_user(user_data)

    assert user.id is not None
    assert user.name == '张三'
    assert user.email == 'zhangsan@example.com'

# 不好的测试：不清晰、依赖顺序
def test_all_user_operations():
    """测试所有用户操作（不推荐）"""
    user = create_user({'name': '李四'})
    update_user(user.id, {'name': '王五'})
    delete_user(user.id)
    # 太多操作，难以定位问题
```

### 10.2 测试原则

1. **F.I.R.S.T 原则**:
   - **Fast**: 快速
   - **Independent**: 独立
   - **Repeatable**: 可重复
   - **Self-validating**: 自验证
   - **Timely**: 及时

2. **AAA 模式**:
   - **Arrange**: 准备测试数据
   - **Act**: 执行操作
   - **Assert**: 验证结果

3. **测试覆盖率目标**: 80%以上（但不是100%）

4. **测试命名**: 清晰描述测试内容

5. **一个测试一个断言**: 尽量保持简单

## 11. 常用测试工具

| 工具 | 用途 |
|------|------|
| pytest | Python单元测试框架 |
| unittest | Python标准库测试框架 |
| coverage | 代码覆盖率 |
| mock | 模拟对象 |
| selenium | Web自动化测试 |
| locust | 负载测试 |
| pytest-benchmark | 性能测试 |
| requests-mock | HTTP请求Mock |

## 总结

软件测试的关键要点：
- **测试类型**: 单元测试、集成测试、系统测试
- **测试框架**: pytest, unittest
- **测试技术**: Mock, Stub, Fixture
- **测试实践**: TDD, CI/CD
- **测试原则**: F.I.R.S.T, AAA模式
- **测试工具**: pytest, selenium, locust

良好的测试实践可以提高代码质量、降低bug率、增强开发信心！
