# 数据结构：链表详解

## 1. 链表简介

链表是一种线性数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。

### 1.1 链表 vs 数组

| 特性 | 数组 | 链表 |
|------|------|------|
| 内存分配 | 连续 | 不连续 |
| 插入/删除 | O(n) | O(1) |
| 随机访问 | O(1) | O(n) |
| 内存使用 | 固定 | 动态 |

## 2. 单链表

### 2.1 节点定义

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
```

### 2.2 单链表实现

```python
class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beginning(self, data):
        """在链表头部插入节点"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node

    def insert_at_end(self, data):
        """在链表尾部插入节点"""
        new_node = Node(data)

        if self.head is None:
            self.head = new_node
            return

        current = self.head
        while current.next:
            current = current.next
        current.next = new_node

    def insert_at_position(self, data, position):
        """在指定位置插入节点"""
        new_node = Node(data)

        if position == 0:
            new_node.next = self.head
            self.head = new_node
            return

        current = self.head
        for i in range(position - 1):
            if current is None:
                raise IndexError("Position out of range")
            current = current.next

        new_node.next = current.next
        current.next = new_node

    def delete_node(self, key):
        """删除指定值的节点"""
        current = self.head

        # 如果头节点就是要删除的节点
        if current and current.data == key:
            self.head = current.next
            current = None
            return

        # 查找要删除的节点
        prev = None
        while current and current.data != key:
            prev = current
            current = current.next

        # 如果没找到
        if current is None:
            return

        # 删除节点
        prev.next = current.next
        current = None

    def search(self, key):
        """搜索节点"""
        current = self.head

        while current:
            if current.data == key:
                return True
            current = current.next

        return False

    def get_length(self):
        """获取链表长度"""
        count = 0
        current = self.head

        while current:
            count += 1
            current = current.next

        return count

    def print_list(self):
        """打印链表"""
        elements = []
        current = self.head

        while current:
            elements.append(str(current.data))
            current = current.next

        print(" -> ".join(elements))

# 使用示例
ll = LinkedList()
ll.insert_at_end(1)
ll.insert_at_end(2)
ll.insert_at_end(3)
ll.insert_at_beginning(0)
ll.print_list()  # 0 -> 1 -> 2 -> 3

ll.delete_node(2)
ll.print_list()  # 0 -> 1 -> 3

print(f"链表长度: {ll.get_length()}")  # 3
print(f"搜索3: {ll.search(3)}")  # True
```

## 3. 双向链表

### 3.1 节点定义

```python
class DNode:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None
```

### 3.2 双向链表实现

```python
class DoublyLinkedList:
    def __init__(self):
        self.head = None

    def insert_at_beginning(self, data):
        """在头部插入节点"""
        new_node = DNode(data)

        new_node.next = self.head
        if self.head:
            self.head.prev = new_node
        self.head = new_node

    def insert_at_end(self, data):
        """在尾部插入节点"""
        new_node = DNode(data)

        if self.head is None:
            self.head = new_node
            return

        current = self.head
        while current.next:
            current = current.next

        current.next = new_node
        new_node.prev = current

    def delete_node(self, node):
        """删除指定节点"""
        if self.head is None or node is None:
            return

        # 如果是头节点
        if self.head == node:
            self.head = node.next

        # 修改next指针
        if node.next:
            node.next.prev = node.prev

        # 修改prev指针
        if node.prev:
            node.prev.next = node.next

    def print_list(self):
        """打印链表"""
        elements = []
        current = self.head

        while current:
            elements.append(str(current.data))
            current = current.next

        print(" <-> ".join(elements))

    def print_reverse(self):
        """反向打印链表"""
        # 先找到尾节点
        if self.head is None:
            return

        current = self.head
        while current.next:
            current = current.next

        # 反向遍历
        elements = []
        while current:
            elements.append(str(current.data))
            current = current.prev

        print(" <-> ".join(elements))

# 使用示例
dll = DoublyLinkedList()
dll.insert_at_end(1)
dll.insert_at_end(2)
dll.insert_at_end(3)
dll.print_list()           # 1 <-> 2 <-> 3
dll.print_reverse()        # 3 <-> 2 <-> 1
```

## 4. 循环链表

### 4.1 循环单链表

```python
class CircularLinkedList:
    def __init__(self):
        self.head = None

    def insert_at_end(self, data):
        """在尾部插入节点"""
        new_node = Node(data)

        if self.head is None:
            self.head = new_node
            new_node.next = self.head
            return

        current = self.head
        while current.next != self.head:
            current = current.next

        current.next = new_node
        new_node.next = self.head

    def print_list(self):
        """打印循环链表"""
        if self.head is None:
            return

        elements = []
        current = self.head

        while True:
            elements.append(str(current.data))
            current = current.next
            if current == self.head:
                break

        print(" -> ".join(elements) + " -> (循环)")

# 使用示例
cll = CircularLinkedList()
cll.insert_at_end(1)
cll.insert_at_end(2)
cll.insert_at_end(3)
cll.print_list()  # 1 -> 2 -> 3 -> (循环)
```

## 5. 常见链表问题

### 5.1 反转链表

```python
def reverse_linked_list(head):
    """反转单链表"""
    prev = None
    current = head

    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node

    return prev

# 递归实现
def reverse_recursive(head):
    """递归反转链表"""
    if head is None or head.next is None:
        return head

    new_head = reverse_recursive(head.next)
    head.next.next = head
    head.next = None

    return new_head
```

### 5.2 检测链表中的环

```python
def has_cycle(head):
    """使用快慢指针检测环"""
    if head is None:
        return False

    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

def find_cycle_start(head):
    """找到环的起点"""
    if head is None:
        return None

    # 先找到相遇点
    slow = fast = head
    has_cycle = False

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            has_cycle = True
            break

    if not has_cycle:
        return None

    # 从头和相遇点同时走，相遇点就是环的起点
    slow = head
    while slow != fast:
        slow = slow.next
        fast = fast.next

    return slow
```

### 5.3 合并两个有序链表

```python
def merge_sorted_lists(l1, l2):
    """合并两个有序链表"""
    dummy = Node(0)
    current = dummy

    while l1 and l2:
        if l1.data <= l2.data:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next

    # 连接剩余节点
    current.next = l1 if l1 else l2

    return dummy.next
```

### 5.4 找到链表的中间节点

```python
def find_middle(head):
    """使用快慢指针找到中间节点"""
    if head is None:
        return None

    slow = fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    return slow
```

### 5.5 删除倒数第N个节点

```python
def remove_nth_from_end(head, n):
    """删除倒数第N个节点"""
    dummy = Node(0)
    dummy.next = head

    first = second = dummy

    # first先走n+1步
    for i in range(n + 1):
        if first is None:
            return head
        first = first.next

    # 然后一起走
    while first:
        first = first.next
        second = second.next

    # 删除节点
    second.next = second.next.next

    return dummy.next
```

### 5.6 判断链表是否为回文

```python
def is_palindrome(head):
    """判断链表是否为回文"""
    if head is None:
        return True

    # 找到中间节点
    slow = fast = head
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

    # 反转后半部分
    prev = None
    while slow:
        next_node = slow.next
        slow.next = prev
        prev = slow
        slow = next_node

    # 比较前半部分和反转后的后半部分
    left, right = head, prev
    while right:
        if left.data != right.data:
            return False
        left = left.next
        right = right.next

    return True
```

## 6. LRU Cache 实现

```python
class LRUNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    """使用双向链表和哈希表实现LRU缓存"""

    def __init__(self, capacity):
        self.capacity = capacity
        self.cache = {}  # key -> node
        self.head = LRUNode(0, 0)
        self.tail = LRUNode(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def _remove(self, node):
        """从链表中移除节点"""
        prev = node.prev
        next_node = node.next
        prev.next = next_node
        next_node.prev = prev

    def _add_to_head(self, node):
        """添加节点到头部（最近使用）"""
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node

    def get(self, key):
        """获取值"""
        if key in self.cache:
            node = self.cache[key]
            self._remove(node)
            self._add_to_head(node)
            return node.value
        return -1

    def put(self, key, value):
        """设置值"""
        if key in self.cache:
            node = self.cache[key]
            node.value = value
            self._remove(node)
            self._add_to_head(node)
        else:
            node = LRUNode(key, value)
            self.cache[key] = node
            self._add_to_head(node)

            if len(self.cache) > self.capacity:
                # 移除最久未使用的节点（尾部）
                lru = self.tail.prev
                self._remove(lru)
                del self.cache[lru.key]

# 使用示例
cache = LRUCache(2)
cache.put(1, 1)
cache.put(2, 2)
print(cache.get(1))       # 1
cache.put(3, 3)           # 移除key 2
print(cache.get(2))       # -1
cache.put(4, 4)           # 移除key 1
print(cache.get(1))       # -1
print(cache.get(3))       # 3
print(cache.get(4))       # 4
```

## 7. 时间复杂度对比

| 操作 | 单链表 | 双向链表 | 数组 |
|------|--------|----------|------|
| 头部插入 | O(1) | O(1) | O(n) |
| 尾部插入 | O(n) | O(1)* | O(1)* |
| 中间插入 | O(n) | O(n) | O(n) |
| 删除 | O(n) | O(1)** | O(n) |
| 搜索 | O(n) | O(n) | O(n) |
| 随机访问 | O(n) | O(n) | O(1) |

*需要维护尾指针
**已知节点位置

## 8. 链表应用场景

1. **动态内存分配**: 不需要预先分配固定大小
2. **LRU缓存**: 双向链表实现
3. **浏览器历史记录**: 双向链表
4. **音乐播放器**: 循环链表
5. **图的邻接表**: 链表存储邻接节点
6. **多项式运算**: 链表表示多项式

## 总结

链表是重要的线性数据结构：
- **单链表**: 简单，单向遍历
- **双向链表**: 可双向遍历，删除操作更高效
- **循环链表**: 没有明确的开始和结束
- **关键技巧**: 快慢指针、双指针、哨兵节点
- **应用**: LRU缓存、浏览器历史、图的邻接表

掌握链表操作是算法面试的重要基础。
