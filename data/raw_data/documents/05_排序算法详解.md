# 常用排序算法详解

## 1. 冒泡排序 (Bubble Sort)

### 1.1 算法原理

冒泡排序重复地遍历要排序的列表，比较相邻的元素并交换它们（如果顺序错误）。这个过程重复进行，直到列表排序完成。

### 1.2 代码实现

```python
def bubble_sort(arr):
    """冒泡排序"""
    n = len(arr)

    for i in range(n):
        # 标记是否发生交换
        swapped = False

        # 最后 i 个元素已经排好序
        for j in range(0, n - i - 1):
            # 如果当前元素大于下一个元素，交换它们
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True

        # 如果没有发生交换，说明已经排好序
        if not swapped:
            break

    return arr

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
print("原始数组:", arr)
print("排序后:", bubble_sort(arr.copy()))
```

### 1.3 时间复杂度

- **最好情况**: O(n) - 数组已经有序
- **平均情况**: O(n²)
- **最坏情况**: O(n²) - 数组逆序
- **空间复杂度**: O(1)

## 2. 选择排序 (Selection Sort)

### 2.1 算法原理

选择排序将列表分为已排序和未排序两部分。算法不断从未排序部分选择最小（或最大）的元素，放到已排序部分的末尾。

### 2.2 代码实现

```python
def selection_sort(arr):
    """选择排序"""
    n = len(arr)

    for i in range(n):
        # 找到未排序部分的最小元素
        min_idx = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j

        # 将最小元素交换到已排序部分的末尾
        arr[i], arr[min_idx] = arr[min_idx], arr[i]

    return arr

# 测试
arr = [64, 25, 12, 22, 11]
print("原始数组:", arr)
print("排序后:", selection_sort(arr.copy()))
```

### 2.3 时间复杂度

- **所有情况**: O(n²)
- **空间复杂度**: O(1)

## 3. 插入排序 (Insertion Sort)

### 3.1 算法原理

插入排序类似于整理扑克牌。它将数组分为已排序和未排序两部分，每次从未排序部分取一个元素，插入到已排序部分的正确位置。

### 3.2 代码实现

```python
def insertion_sort(arr):
    """插入排序"""
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1

        # 将大于 key 的元素向后移动
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1

        # 插入 key 到正确位置
        arr[j + 1] = key

    return arr

# 测试
arr = [12, 11, 13, 5, 6]
print("原始数组:", arr)
print("排序后:", insertion_sort(arr.copy()))
```

### 3.3 时间复杂度

- **最好情况**: O(n) - 数组已经有序
- **平均情况**: O(n²)
- **最坏情况**: O(n²)
- **空间复杂度**: O(1)

## 4. 快速排序 (Quick Sort)

### 4.1 算法原理

快速排序采用分治策略：
1. 选择一个基准元素（pivot）
2. 将数组分为两部分：小于基准的和大于基准的
3. 递归地对两部分进行快速排序

### 4.2 代码实现

```python
def quick_sort(arr):
    """快速排序"""
    if len(arr) <= 1:
        return arr

    # 选择基准（这里选择中间元素）
    pivot = arr[len(arr) // 2]

    # 分区
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    # 递归排序并合并
    return quick_sort(left) + middle + quick_sort(right)

# 原地快速排序（更高效）
def quick_sort_inplace(arr, low=0, high=None):
    """原地快速排序"""
    if high is None:
        high = len(arr) - 1

    def partition(arr, low, high):
        """分区函数"""
        pivot = arr[high]
        i = low - 1

        for j in range(low, high):
            if arr[j] <= pivot:
                i += 1
                arr[i], arr[j] = arr[j], arr[i]

        arr[i + 1], arr[high] = arr[high], arr[i + 1]
        return i + 1

    if low < high:
        pi = partition(arr, low, high)
        quick_sort_inplace(arr, low, pi - 1)
        quick_sort_inplace(arr, pi + 1, high)

    return arr

# 测试
arr = [10, 7, 8, 9, 1, 5]
print("原始数组:", arr)
print("排序后:", quick_sort(arr.copy()))
```

### 4.3 时间复杂度

- **最好情况**: O(n log n)
- **平均情况**: O(n log n)
- **最坏情况**: O(n²) - 数组已排序或逆序
- **空间复杂度**: O(log n) - 递归栈

## 5. 归并排序 (Merge Sort)

### 5.1 算法原理

归并排序也采用分治策略：
1. 将数组分成两半
2. 递归地对两半进行排序
3. 合并两个已排序的数组

### 5.2 代码实现

```python
def merge_sort(arr):
    """归并排序"""
    if len(arr) <= 1:
        return arr

    # 分割数组
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    # 合并已排序的数组
    return merge(left, right)

def merge(left, right):
    """合并两个已排序的数组"""
    result = []
    i = j = 0

    # 比较并合并
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # 添加剩余元素
    result.extend(left[i:])
    result.extend(right[j:])

    return result

# 测试
arr = [38, 27, 43, 3, 9, 82, 10]
print("原始数组:", arr)
print("排序后:", merge_sort(arr.copy()))
```

### 5.3 时间复杂度

- **所有情况**: O(n log n)
- **空间复杂度**: O(n)

## 6. 堆排序 (Heap Sort)

### 6.1 算法原理

堆排序利用堆这种数据结构：
1. 将数组构建成最大堆
2. 将堆顶元素（最大值）与末尾元素交换
3. 重新调整堆，重复步骤2

### 6.2 代码实现

```python
def heap_sort(arr):
    """堆排序"""
    n = len(arr)

    # 构建最大堆
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # 一个个从堆中取出元素
    for i in range(n - 1, 0, -1):
        # 将当前最大值（堆顶）移到数组末尾
        arr[0], arr[i] = arr[i], arr[0]

        # 对剩余元素进行堆化
        heapify(arr, i, 0)

    return arr

def heapify(arr, n, i):
    """堆化函数"""
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    # 如果左子节点存在且大于根节点
    if left < n and arr[left] > arr[largest]:
        largest = left

    # 如果右子节点存在且大于当前最大值
    if right < n and arr[right] > arr[largest]:
        largest = right

    # 如果最大值不是根节点
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        # 递归堆化受影响的子树
        heapify(arr, n, largest)

# 测试
arr = [12, 11, 13, 5, 6, 7]
print("原始数组:", arr)
print("排序后:", heap_sort(arr.copy()))
```

### 6.3 时间复杂度

- **所有情况**: O(n log n)
- **空间复杂度**: O(1)

## 7. 计数排序 (Counting Sort)

### 7.1 算法原理

计数排序是一种非比较排序算法，适用于整数排序：
1. 统计每个元素出现的次数
2. 根据计数重建有序数组

### 7.2 代码实现

```python
def counting_sort(arr):
    """计数排序（适用于非负整数）"""
    if not arr:
        return arr

    # 找到最大值
    max_val = max(arr)

    # 创建计数数组
    count = [0] * (max_val + 1)

    # 统计每个元素出现的次数
    for num in arr:
        count[num] += 1

    # 重建数组
    result = []
    for num, cnt in enumerate(count):
        result.extend([num] * cnt)

    return result

# 测试
arr = [4, 2, 2, 8, 3, 3, 1]
print("原始数组:", arr)
print("排序后:", counting_sort(arr.copy()))
```

### 7.3 时间复杂度

- **时间复杂度**: O(n + k) - k 是数值范围
- **空间复杂度**: O(k)

## 8. 排序算法对比

| 算法 | 平均时间 | 最坏时间 | 空间复杂度 | 稳定性 | 适用场景 |
|------|---------|---------|-----------|--------|---------|
| 冒泡排序 | O(n²) | O(n²) | O(1) | 稳定 | 小规模数据 |
| 选择排序 | O(n²) | O(n²) | O(1) | 不稳定 | 小规模数据 |
| 插入排序 | O(n²) | O(n²) | O(1) | 稳定 | 小规模或基本有序 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | 不稳定 | 通用，性能优秀 |
| 归并排序 | O(n log n) | O(n log n) | O(n) | 稳定 | 需要稳定排序 |
| 堆排序 | O(n log n) | O(n log n) | O(1) | 不稳定 | 需要原地排序 |
| 计数排序 | O(n + k) | O(n + k) | O(k) | 稳定 | 整数，范围小 |

## 9. Python 内置排序

### 9.1 sorted() 和 list.sort()

```python
arr = [3, 1, 4, 1, 5, 9, 2, 6]

# sorted() - 返回新列表
sorted_arr = sorted(arr)
print("原数组:", arr)
print("sorted():", sorted_arr)

# list.sort() - 原地排序
arr.sort()
print("sort():", arr)

# 逆序排序
arr.sort(reverse=True)
print("逆序:", arr)

# 自定义排序键
words = ["apple", "pie", "zoo", "a"]
words.sort(key=len)
print("按长度排序:", words)

# 多条件排序
students = [
    ("Alice", 25, 90),
    ("Bob", 22, 85),
    ("Charlie", 25, 95)
]
students.sort(key=lambda x: (x[1], -x[2]))  # 先按年龄升序，再按分数降序
print("多条件排序:", students)
```

### 9.2 排序算法

Python 的内置排序使用 **Timsort** 算法：
- 结合了归并排序和插入排序
- 时间复杂度: O(n log n)
- 稳定排序
- 针对真实数据优化（部分有序数据性能更好）

## 10. 排序算法选择建议

1. **小规模数据 (n < 50)**:
   - 插入排序（简单高效）

2. **中大规模数据**:
   - 快速排序（平均性能最好）
   - Python 内置 sorted() / sort()（推荐）

3. **需要稳定排序**:
   - 归并排序
   - Python 内置排序

4. **空间受限**:
   - 堆排序（原地排序）
   - 快速排序

5. **整数且范围小**:
   - 计数排序（线性时间）

6. **几乎有序的数据**:
   - 插入排序
   - Timsort

## 总结

掌握这些排序算法有助于：
- 理解算法设计思想（分治、贪心等）
- 分析时间和空间复杂度
- 根据场景选择合适的算法
- 理解 Python 内置排序的优势

在实际开发中，通常使用 Python 内置的 `sorted()` 和 `list.sort()`，它们基于 Timsort 算法，性能优秀且稳定。
