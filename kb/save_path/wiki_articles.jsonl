{"title": "人工智能", "text": "人工智能（英語：artificial intelligence，缩写为AI），是指计算机系统执行通常与人类智慧相关的任务的能力，例如学习、推理、解决问题、感知和决策。它是计算机科学的一个研究领域，致力于开发和研究使机器能够感知其环境并利用学习和智能采取行动以最大限度地提高其实现既定目标的可能性的方法和软件。\n\n详细定义\n通常人工智能是指用普通電腦程式來呈現人類智能的技術。該詞也指出研究這樣的智能系統是否能夠實現，以及如何實現。同时，隨著醫學、神經科學、机器人学及統計學等方面的發展，普遍認為人類的部分職業也逐漸被其取代。\n人工智能於一般教材中的定义领域是“智慧主体的研究与设计”，智慧主体指一个可以观察周遭环境并作出行动以达致目标的系统。约翰·麦卡锡于1955年對人工智能的定义是「制造智能机器的科学与工程」。安德烈亚斯·卡普兰和迈克尔·海恩莱因（Michael Haenlein）将人工智能定义为“系统正确解释外部数据，从这些数据中学习，并利用这些知识通过灵活适应实现特定目标和任务的能力”。人工智能可以定義為模仿人類與人類思維相關的認知功能的機器或計算機，如學習和解決問題。人工智能是計算機科學的一個分支，它感知其環境並採取行動，最大限度地提高其成功機會。此外，人工智能能夠從過去的經驗中學習，做出合理的決策，並快速回應。因此，人工智能研究人員的科學目標是通過構建具有象徵意義的推理或推理的計算機程式來理解智慧。在計算基礎設施之外，人工智能的主要基础组成部分是：\n\n学习（包括机器学习、深度学习、强化学习等子领域）\n知识表示、推理与决策\n问题解决——包括使用泛型或特设的方法,以有序的方式,寻找问题解决方案\n感知（例如计算机视觉）\n自然语言处理（NLP）\n生成能力：生成模型与生成式人工智能\n人工智能的研究是高度技术性和专业的，各分支领域都是深入且各不相通的，因而涉及範圍極廣。人工智能的研究可以分为几个技术问题。其分支领域主要集中在解决具体问题，其中之一是，如何使用各种不同的工具完成特定的应用程序。\nAI的核心问题包括建構能夠跟人類相似，甚至超卓的推理、知识、計划、学习、交流、感知、移動 、移物、使用工具和操控机械的能力等。通用人工智能（AGI）目前仍然是该领域的长远目标。目前弱人工智慧已經有初步成果，甚至在一些影像辨識、語言分析、棋類遊戲等等單方面的能力達到了超越人類的水平，而且人工智慧的通用性代表著，能解決上述的問題的是一樣的AI程式，無須重新開發算法就可以直接使用現有的AI完成任務，與人類的處理能力相同，但達到具備思考能力的統合強人工智慧還需要時間研究，比较流行的方法包括统计方法，计算智能和传统意义的AI。目前有大量的工具应用了人工智能，其中包括搜索和数学优化、逻辑推演。而基於仿生學、認知心理學，以及基于概率论和经济学的演算法等等也在逐步探索當中。\n\n概論\n人工智能的定義可以分為兩部分，即「人工」和「智能」。「人工」即由人设计，为人创造、制造。\n關於甚麼是「智能」，较有争议性。這涉及到其它諸如意識、自我、心靈，包括無意識的精神等等問題。人唯一瞭解的智能是人本身的智能，這是普遍認同的觀點。但是目前，人類對人類自身智能，與對構成人所擁有智能的必要元素的瞭解都十分有限，因此很難準確定義甚麼是「人工」製造的「智能」。因此人工智能的研究往往涉及對人智能本身的研究。其它關於動物或其它人造系統的智能也普遍被認為是人工智能相關的研究課題。\n人工智慧目前在電腦領域內，得到了愈加廣泛的发挥。並在機器人、經濟政治決策、控制系統、仿真系統中得到應用。\n人工智能也廣泛應用於許多不同領域。機器人經營餐館和商店並修復城市基礎設施。人工智能管理運輸系統和自動駕駛車輛。智能平台管理多個城市領域，例如垃圾收集和空氣質量監測。事實上，城市人工智能體現在城市空間、基礎設施和技術中，將我們的城市變成了無人監督的自治實體。可以方便地實時實現數字化支持的智能響應服務。許多城市現在主動利用大數據和人工智能，通過為我們的基礎設施提供更好的能源、計算能力和連接性來提高經濟回報。\n最近，由於人工智能減少了行政成本和時間，許多政府開始將人工智能用於各種公共服務。例如，移民流程的機器人自動化減少了處理時間並提高了效率。人工智能為地方政府服務帶來技術突破。人工智能代理協助城市規劃者基於目標導向的蒙特卡羅樹搜索進行場景規劃。目標推理人工智能代理提供最佳的土地利用解決方案，幫助人類制定民主的城市土地利用規劃。人工智能利用在線數據來監控和修改環境威脅政策。在2019 年水危機期間，潛在狄利克雷分配方法確定了Twitter (X) 中討論最多的主題，這是一種樸素的推文分類方法，對乾旱的影響和原因、政府響應和潛在解決方案等主題進行了分類。人工智能工具與司法部門的人類法官相輔相成，提供客觀、一致的風險評估。\n\n發展史\n对机器或“形式”的推理研究起源于古代哲学家和数学家。逻辑学的研究直接催生了艾伦·图灵的计算理论，理论提出，一台通过操作简单符号“0”和“1”的机器，能够模拟任意复杂的数学推理过程。这一理论，连同在控制论、信息论及神经生物学方面的同期发现，推动研究人员考虑构建一台“电子大脑”的可能性。 此外，他们还开拓了未来成为人工智能领域一部分的多个研究分支，比如1943年沃伦·麦卡洛克与沃尔特·皮茨设计的“人工神经元”，以及图灵于1950年发表的具有深远影响的论文《计算机器与智能》，其中提出了“图灵测试”，展示了“机器智能”的可行性。\n人工智能研究领域正式成立于1956年在达特茅斯学院举行的“达特茅斯会议”。\n与会者后来在20世纪60年代成为该领域的先驱者。 他们及其学生研发出的程序被媒体誉为“令人惊叹”： 计算机不仅能学会国际跳棋策略，还能解决代数文字难题、证明逻辑定理，甚至能进行英语对话。在20世纪50年代末至60年代初，许多英国和美国的大学纷纷建立了人工智能实验室。\n20世纪60年代至70年代，研究人员坚信他们的方法最终能够成功创造出具有通用智能的机器，并将此视为他们研究领域的最高目标。赫伯特·西蒙（Herbert Simon）曾预言：“在未来二十年内，机器能够胜任所有人类能够完成的工作。”马文·明斯基（Marvin Minsky）对此表示赞同，他认为：“在一代人的时间内，‘人工智能’这一难题将会得到实质性的解决。”但事实证明他们低估了这个问题所涉及的复杂性。1974年，受到詹姆斯·莱特希尔爵士（Sir James Lighthill）的批评以及美国国会倾向于资助更为有成效项目的趋势，美国和英国政府都中断了探索性研究。明斯基和西摩·佩珀特（Seymour Papert）在其著作《感知器》（Perceptrons）中提出的观点，被误认为已经证明人工神经网络在解决现实世界问题上毫无用处，从而完全否定了这种方法。随后出现了 “人工智能寒冬”，即人工智能项目难以获得资助的时期。\n20世纪80年代初期，人工智能研究因专家系统的商业成功而再次活跃，一种人工智能程序，旨在模拟人类专家的知识和分析技巧。到了1985年，AI市场估值超过10亿美元。与此同时，日本的第五代计算机项目推动英美两国恢复学术研究的资助。但从1987年Lisp机器市场的衰退开始，人工智能再次发展挫折，第二个较长的低迷期开始了。\n在此之前，人工智能的主要资金用于高级符号项目，用以表征如计划、目标、信念等概念性对象。20世纪80年代，一些研究人员开始怀疑，这种方法能否模仿人类认知的所有过程，特别是感知、机器人、学习和模式识别，并开始研究“次符号”方法。罗德尼·布鲁克斯（Rodney Brooks）普遍不认同“表征”这一概念，并将研究重心转向了设计能够移动和自持生存的机器工程。 朱迪亚·珀尔、卢特菲·泽德等学者发展了多种方法，这些方法基于合理推断处理不完备或不确定的信息，而非依赖于严格的逻辑。但最显著的进展是，杰弗里·辛顿与其他研究者协力，在“联结主义”及其涉及的神经网络研究方面，取得了重要突破。1990年，杨立昆（Yann Le Cun）展示了卷积神经网络能够识别手写数字，这项突破性的研究为神经网络在多个实际应用领域的应用奠定了基础。\n20世纪末至21世纪初期，人工智能利用形式化的数学方法，结合针对特定问题制定的策略，逐步在学术界重建了声誉。这种“聚焦”与“规范化”的研究方法让研究者能产出可验证的成果，并促进了与统计学、经济学及数学等其他学科的交叉合作。至2000年，人工智能领域研究的解决方案获得了广泛的应用，尽管在1990年代，这些方案往往不被直接标识为“人工智能”。当前，部分人工智能领域的学者提出观点，关注研究重点可能未全面覆盖创造具备多功能性和全面智能的机器这一初始目标。2002至2010年间，通用人工智能（AGI）领域内成立了多个获得充分资金支持的研究机构。\n2012年以来，深度学习开始主导行业标准，并迅速成为该领域内广泛采用的方法。在多种场合，替代性方法被淘汰，深度学习得到优先采用。深度学习的突破性成果，既得力于硬件的显著进步（如计算速度更快的电脑、图形处理单元以及云计算技术），也依赖于广泛的数据可用性（包括精心策划的数据集，譬如ImageNet）。深度学习的成果引发了公众对于人工智能的浓厚兴趣并促使资金投入的大幅度增加。2015年至2019年期间，机器学习领域的出版物数目上升了50%。\n2016年，在机器学习会议上，公平性与技术滥用成为突出话题；相关论文发表数量急剧增加，研究经费随之提供，众多研究人员转而聚焦这些议题。对齐问题逐渐成为学术探讨的重要议题。\n2010年代末至2020年代初，AGI公司推出引发广泛关注的程序。2015年，由Google DeepMind研发的“阿尔法狗”战胜了世界围棋冠军。该程序仅被输入了游戏规则并自主形成了策略。GPT-3是OpenAI在2020年推出的一款强大的语言模型，它能生成高质量、类人的文本。这些及其他程序引发了剧烈的AI热潮，主要企业投入数十亿美元于AI研究。AI Impacts预测，到2022年，仅在美国，人工智能领域的年投资就将达到约500亿美元，大约20%的美国新晋计算机科学博士生将专注于AI领域。在2022年，美国预计将有大约80万的人工智能相关职位空缺。\n進入2023年，OpenAI推出了GPT-4，其多模態能力和推理性能顯著提升，能處理文本和圖像輸入，並在複雜問題解決方面展現出更強大的能力。隔年(2024年)，OpenAI進一步發布GPT-4o，這款模型能夠處理文本、圖像等多種數據類型，並以更自然的對話能力獲得廣泛應用。\n截至2024年，AI技術的應用範圍進一步擴大。例如，Anthropic的Claude模型因其安全性和可解釋性受到關注，被廣泛用於企業應用。與此同時，xAI於2023年推出Grok，旨在加速人類科學發現，特別是在太空探索和物理學領域。根據市場研究，至2024年，全球AI市場規模已達到約1640億美元，並預計以年複合增長率（CAGR）36.6%持續增長。\n2025年，中小型AI模型開始崛起，這些模型以更低的計算需求提供高效性能，受到廣泛關注。DeepSeek於2024年12月24日推出了DeepSeek V3，這是一款通用大型語言模型（LLM），並於2025年1月發布DeepSeek R1，專注於複雜邏輯任務的推理模型，兩者均提供開源權重和訓練方法。DeepSeek R1擁有6710億(610B)個參數，被認為在推理能力上與OpenAI的o1模型相當，並因其高效的訓練方法引发了全球AI競爭的熱潮。2025年3月6日，Alibaba Group發布了QwQ-32B，一款320億(32B)參數的開源推理模型，據稱其性能可媲美DeepSeek R1，並在數學、編碼和一般問題解決等基準測試中超越OpenAI的o1-mini，且計算需求顯著降低。QwQ-32B的發布使阿里巴巴香港上市股票在2025年3月6日上漲超過8%，反映市場對中小型高效模型的看好。\n\n研究課題\n目前人工智慧的研究方向已經被分成幾個子領域，研究人員希望一個人工智慧系統應該具有某些特定能力，以下將這些能力列出並說明。\n\n演绎、推理和解决问题\n早期的人工智慧研究人员直接模仿人类进行逐步的推理，就像是玩棋盘游戏或进行逻辑推理时人类的思考模式。到了1980和1990年代，利用概率和经济学上的概念，人工智慧研究还发展了非常成功的方法处理不确定或不完整的资讯。\n对于困难的问题，有可能需要大量的运算资源，也就是发生了「可能组合爆增」：当问题超过一定的规模时，电脑会需要天文数量级的存储器或是运算时间。寻找更有效的演算法是优先的人工智慧研究项目。\n人类解决问题的模式通常是用最快捷、直观的判断，而不是有意识的、一步一步的推导，早期人工智慧研究通常使用逐步推导的方式。人工智慧研究已经于这种「次表征性的」解决问题方法取得进展：实体化Agent研究强调感知运动的重要性。神经网络研究试图以模拟人类和动物的大脑结构重现这种技能。\n\n知識表示法\n知识表示是人工智能领域的核心研究问题之一，它的目标是让机器存储相应的知识，并且能够按照某种规则推理演绎得到新的知识。有许多需要解决的问题需要大量的对世界的知识,这些知识包括事先存储的先验知识和通过智能推理得到的知识。事先存储的先验知识指：人类用某种方式告诉给机器的知识。通过智能推理得到的知识指：结合先验知识和某种特定的推理规则（逻辑推理）得到的知识。首先，先验知识可以指描述目标，特征，种类及物件之间的关系的知识， 也可以描述事件，时间，状态，原因和结果， 以及任何知识你想要机器存储的。比如：今天没有太阳，没有太阳就是阴天。那么以命题逻辑语言，这些知识可以被表示为：今天 → 没有太阳，没有太阳 → 阴天。这些知识是先验知识，那么推理可以得到新知识：今天 → 阴天。由此例子可以看出，先验知识的正确性非常重要，这个例子中没有太阳就是阴天，这个命题是不严谨的、比较笼统的，因为没有太阳可能是下雨，也可能下雪。另外如果人工智慧能看出太陽，除了該如何判斷的這件問題，在這個前提之下，應該也能判斷出陰天與晴天的差異。逻辑命题表示在知识表示中非常重要，逻辑推理规则是目前主要推理规则。可以在机器中用逻辑符号定义每一个逻辑命题，然后再让机器存储相应的逻辑推理规则，那么自然而然机器便可进行推理。目前知识表达有许多困境尚无法解决，比如：建立一个完备的知识库几乎不可能，所以知识库的资源受到限制；先验知识的正确性需要进行检验，而且先验知识有时候不一定是只有对或者错两种选择。\n\n规划\n智能Agent必须能够制定目标和实现这些目标。他们需要一种方法来建立一个可预测的世界模型（将整个世界状态用数学模型表现出来，并能预测它们的行为将如何改变这个世界），这样就可以选择功效最大的行为。\n在传统的规划问题中，智能Agent被假定它是世界中唯一具有影响力的，所以它要做出什么行为是已经确定的。但是，如果事实并非如此，它必须定期检查世界模型的状态是否和自己的预测相符合。如果不符合，它必须改变它的计划。因此智能代理必须具有在不确定结果的状态下推理的能力。在多Agent中，多个Agent规划以合作和竞争的方式去完成一定的目标，使用演化演算法和群体智慧可以达成一个整体的突现行为目标。\n\n機器學習\n机器学习的主要目的是为了让机器从使用者和输入数据等处获得知识，从而让机器自动地去判断和输出相应的结果。这一方法可以帮助解决更多问题、减少错误，提高解决问题的效率。对于人工智能来说，机器学习从一开始就很重要。\n机器学习的方法各种各样，主要分为监督学习和非监督学习两大类。监督学习指事先给定机器一些训练样本并且告诉样本的类别，然后根据这些样本的类别进行训练，提取出这些样本的共同属性或者训练一个分类器，等新来一个样本，则通过训练得到的共同属性或者分类器进行判断该样本的类别。监督学习根据输出结果的离散性和连续性，分为分类和回归两类。非监督学习是不给定训练样本，直接给定一些样本和一些规则，让机器自动根据一些规则进行分类。无论哪种学习方法都会进行误差分析，从而知道所提的方法在理论上是否误差有上限。\n\n自然語言處理\n自然語言處理探討如何處理及運用自然語言，自然語言認知則是指讓電腦「懂」人類的語言。自然語言生成系統把計算機數據轉化為自然語言。自然語言理解系統把自然語言轉化為計算機程序更易于處理的形式。\n\n運動和控制\n機器感知\n機器感知是指能夠使用感測器所輸入的資料（如照相機、麥克風、聲納以及其他的特殊感測器）然後推斷世界的狀態。電腦視覺能夠分析影像輸入。另外還有語音識別、人臉辨識和物體辨識。\n\n社交\n情感和社交技能對於一個智能agent是很重要的。首先，通过了解他們的動機和情感狀態，代理人能夠預測別人的行動（這涉及要素 博弈論、決策理論以及能夠塑造人的情感和情緒感知能力檢測）。此外，為了良好的人機互動，智慧代理人也需要表現出情緒來。至少它必須出現禮貌地和人類打交道。至少，它本身應該有正常的情緒。\n\n創造力\n一個人工智慧的子領域，代表了理論（從哲學和心理學的角度）和實際（通過特定的實現產生的系統的輸出是可以考慮的創意，或系統識別和評估創造力）所定義的創造力。相關領域的研究包括了人工直覺和人工想像。\n\n研究方法\n目前没有统一的原理或范式指导人工智能研究。许多问题上研究者都存在争论。\n其中几个长久以来仍没有结论的问题是：是否应从心理或神经方面模拟人工智能?或者像鸟类生物学对于航空工程一样，人类生物学对于人工智能研究是没有关系的？智能行为能否用简单的原则（如逻辑或优化）来描述？还是必须解决大量完全无关的问题？\n智能是否可以使用高级符号表达，如词和想法？还是需要“子符号”的处理？約翰·豪格兰德（John Haugeland）提出了GOFAI（出色的老式人工智能）的概念，也提议人工智能应归类为synthetic intelligence，这个概念后来被某些非GOFAI研究者采纳。\n\n控制论与大脑模拟\n20世纪40年代到50年代，许多研究者探索神经学、信息理论及控制论之间的联系。其中还造出一些使用电子网络构造的初步智能，如威廉·格雷·沃尔特的烏龜（turtle）和約翰霍普金斯野獸。\n这些研究者还经常在普林斯顿大学和英国的Ratio Club举行技术协会会议。直到1960，大部分人已经放弃这个方法，尽管在80年代再次提出这些原理。\n\n符号处理\n当20世纪50年代，數位计算机研制成功，研究者开始探索人类智能是否能简化成符号处理。研究主要集中在卡内基梅隆大学，斯坦福大学和麻省理工學院，而各自有独立的研究风格。約翰·豪格兰德（John Haugeland）称这些方法为GOFAI（出色的老式人工智能）。60年代，符号方法在小型证明程序上模拟高级思考有很大的成就。基于控制论或人工神经网络的方法则置于次要。60－70年代的研究者确信符号方法最终可以成功创造强人工智能的机器，同时这也是他们的目标。\n\n认知模拟：经济学家赫伯特·西蒙和艾伦·纽厄尔研究人类问题解决能力和尝试将其形式化，同时他们为人工智能的基本原理打下基础，如认知科学、运筹学和经营科学。他们的研究团队使用心理学实验的结果开发模拟人类解决问题方法的程序。这方法一直在卡内基梅隆大学沿袭下来，并在80年代于Soar发展到高峰。\n基于逻辑：不像艾伦·纽厄尔和赫伯特·西蒙，约翰·麦卡锡认为机器不需要模拟人类的思想，而应尝试找到抽象推理和解决问题的本质，不管人们是否使用同样的算法。他在斯坦福大学的实验室致力于使用形式化逻辑解决多种问题，包括知识表示，智能规划和机器学习。致力于逻辑方法的还有爱丁堡大学，而促成欧洲的其他地方开发编程语言Prolog和逻辑编程科学。\n“反逻辑”: 斯坦福大学的研究者 （如马文·明斯基和西摩爾·派普特）发现要解决计算机视觉和自然语言处理的困难问题，需要专门的方案：他们主张不存在简单和通用原理（如逻辑）能够达到所有的智能行为。罗杰·尚克描述他们的“反逻辑”方法为“scruffy”。常识知识库（如道格拉斯·莱纳特的Cyc）就是“scruffy”AI的例子，因为他们必须人工一次编写一个复杂的概念。\n基于知识：大约在1970年出现大容量内存计算机，研究者分别以三个方法开始把知识构造成应用软件。这场“知识革命”促成专家系统的开发与计划，这是第一个成功的人工智能软件形式。“知识革命”同时让人们意识到许多简单的人工智能软件可能需要大量的知识。\n\n子符号方法\n1980年代符号人工智能停滞不前，很多人认为符号系统永远不可能模仿人类所有的认知过程，特别是感知、机器人、机器学习和模式识别。很多研究者开始关注子符号方法解决特定的人工智能问题。\n\n自下而上、接口agent、嵌入环境（机器人）、行为主义、新式AI：机器人领域相关的研究者，如罗德尼·布鲁克斯，否定符号人工智能而专注于机器人移动和求生等基本的工程问题。他们的工作再次关注早期控制论研究者的观点，同时提出了在人工智能中使用控制理论。这与认知科学领域中的表征感知论点是一致的:更高的智能需要个体的表征（如移动，感知和形象）。\n计算智能：1980年代中David Rumelhart等再次提出神经网络和联结主义。这和其他的子符号方法，如模糊控制和进化计算，都属于计算智能学科研究范畴。\n\n统计学方法\n1990年代，人工智能研究发展出复杂的数学工具来解决特定的分支问题。这些工具是真正的科学方法，即这些方法的结果是可测量的和可验证的，同时也是近期人工智能成功的原因。共用的数学语言也允许已有学科的合作（如数学，经济或运筹学）。斯图亚特·鲁塞尔和彼德·諾米格指出这些进步不亚于“革命”和“neats的成功”。有人批评这些技术太专注于特定的问题，而没有考虑长远的强人工智能目标。\n\n集成方法\n智能agent范式：智能agent是一个会感知环境并作出行动以达致目标的系统。最简单的智能agent是那些可以解决特定问题的程序。更复杂的agent包括人类和人类组织（如公司）。这些范式可以让研究者研究单独的问题和找出有用且可验证的方案，而不需考虑单一的方法。一个解决特定问题的agent可以使用任何可行的方法-一些agent用符号方法和逻辑方法，一些则是子符号神经网络或其他新的方法。范式同时也给研究者提供一个与其他领域沟通的共同语言—如决策论和经济学（也使用abstract agents的概念）。1990年代智能agent范式被广泛接受。\n代理架構和認知架構：研究者设计出一些系统来处理多agent系统中智能agent之间的相互作用。一个系统中包含符号和子符号部分的系统称为混合智能系統，而对这种系统的研究则是人工智能系统集成。分级控制系统则给反应级别的子符号AI和最高级别的传统符号AI提供桥梁，同时放宽了规划和世界建模的时间。\n\n基本應用\n人工智慧基本的應用（Fundamental Applications）可分為四大部分：\n\n感知能力（Perception）\n指的是人類透過感官所收到環境的刺激，察覺訊息的能力，簡單的說就是人類五官的看、聽、說、讀、寫等能力，學習人類的感知能力是AI目前主要的焦點之一，包括：\n\n「看」：電腦視覺（Computer Vision）、圖像辨識（Image Recognition）、人臉辨識（Face Recognition）、物件偵測（Object Detection）。\n「聽」：語音辨識（Sound Recognition）。\n「說」：語音生成（Sound Generation）、文本轉換語音（Text-to-Speech）。\n「讀」：自然語言處理（Natural Language Processing，NLP）、語音轉換文本（Speech-to-Text）。\n「寫」：機器翻譯（Machine Translation）、文本生成（Text Generation）\n\n認知能力（Cognition）\n指的是人類透過學習、判斷、分析等等心理活動來瞭解訊息、獲取知識的過程與能力，對人類認知的模仿與學習也是目前AI第二個焦點領域，主要包括：\n\n分析辨識能力：例如醫學圖像分析、產品推薦、垃圾郵件辨識、法律案件分析、犯罪偵測、信用風險分析、消費行為分析等。\n預測能力：例如AI執行的預防性維修（Predictive Maintenance）、智慧天然災害預測與防治。\n判斷能力：例如AI下圍棋、自動駕駛車、健保詐欺判斷、癌症判斷等。\n學習能力：例如機器學習、深度學習、增強式學習等等各種學習方法。\n\n創造力（Creativity）\n指的是人類產生新思想，新發現，新方法，新理論，新設計，創造新事物的能力，它是結合知識、智力、能力、個性及潛意識等各種因素優化而成，這個領域目前人類仍遙遙領先AI，但AI也試著急起直追，主要領域包括：AI作曲、AI作詩、AI小說、AI繪畫、AI設計等。\n\n智慧（Wisdom）\n指的是人類深刻瞭解人、事、物的真相，能探求真實真理、明辨是非，指導人類可以過著有意義生活的一種能力，這個領域牽涉人類自我意識、自我認知與價值觀，是目前AI尚未觸及的一部分，也是人類最難以模仿的一個領域。\n\n實際應用\n机器视觉、指纹识别、人脸识别、视网膜识别、虹膜识别、掌纹识别、专家系统、自动规划、無人載具等。\n\n應用領域\n智能控制\n機器人學\n自動化技術\n語言和圖像理解\n遺傳編程\n法學資訊系統\n下棋\n醫學領域\n\n人工智能倫理\n倫理管理\n史蒂芬·霍金、比爾蓋茲、埃隆·马斯克、Jaan Tallinn以及Nick Bostrom等人都對於人工智慧技術的未來公開表示憂心，人工智慧若在許多方面超越人類智慧水平的智能、不斷更新、自我提升，進而取得控制管理權，人類是否有足夠的能力及時停止人工智慧領域的「軍備競賽」，能否保有最高掌控權，現有事實是：機器常失控導致人員傷亡，這樣的情況是否會更加擴大規模出現，歷史顯然無法給出可靠的樂觀答案。特斯拉電動車馬斯克（Elon Musk）在麻省理工學院（MIT）航空航天部門百年紀念研討會上稱人工智能是「召喚惡魔」行為，英國發明家Clive Sinclair認為一旦開始製造抵抗人類和超越人類的智能機器，人類可能很難生存，蓋茲同意馬斯克和其它人所言，且不知道為何有些人不擔憂這個問題。\nGoogle DeepMind的人工智慧（AI）系統在2016年「AlphaGo」對戰南韓棋王李世乭獲勝，開發商表示在內部設立倫理委員會，針對人工智慧的應用制定政策，防範人工智慧淪為犯罪開發者。\n科技進步，人工智慧科技產生「自主武器」軍備競賽已悄悄展開，英國、以色列與挪威，都已部署自主飛彈與無人操控的無人機，具「射後不理」（fire-and-forget）能力的飛彈，多枚飛彈還可互相溝通，分享找到攻擊目標。這些武器還未被大量投入，但很快就會出現在戰場上，且並非使用人類所設計的程序，而是完全利用機器自行決策。 霍金等人在英國獨立報發表文章警告未來人工智慧可能會比人類金融市場、科學家、人類領袖更能操縱人心、甚至研發出人們無法理解的武器。專家恐發展到無法控制的局面，援引聯合國禁止研發某些特定武器的「特定常規武器公約」加以限制。新南威尔士大学人工智慧的托比·沃尔什教授認為這是一種欺騙，因為機器無區別戰敵和平民的技術。\n\n經濟衝擊\nCNN財經網數字媒體未來學家Amy Webb、美国在线等紛紛預測一些即將被機器人取代的職業，日本野村综合研究所也與英國牛津大学的研究學者共同調查指出，10至20年後，日本有49%的職業（235種職業）可能會被機械和人工智慧取代而消失，直接影響約達2500萬人，例如：超市店員、一般事務員、計程車司機、收費站運營商和收銀員、市場營銷人員、客服人員、製造業工人、金融中間人和分析師、新聞記者、電話公司職員、麻醉師、士兵和保安、律師、醫生、軟體開發者和操盤手、股票交易員等等高薪酬的腦力職業將最先受到衝擊。\n2017年6月份马云在美國底特律舉行「鏈結世界」（Gateway 17）產業大會，會上提出人工智慧可能導致第三次世界大戰，因為前兩次產業革命都導致兩次大戰，戰爭原因並非這些創新發明本身，而是發明對社會上許多人的生活方式衝擊處理不當，新科技在社會上產生新工作也取代舊工作，產生了新的輸家和贏家，若是輸家的人數太多將造成一股社會不穩的能量而這股能量被有心人利用可能導致各種事件。他認為各國應該強制訂定規定AI機器只能用於人類不能做的工作，避免短時間大量人類被取代的失業大潮，但馬雲沒有提出這種世界性規定將如何實現並確保遵守的細節方案。\n数据科学和人工智能被哈佛商業評論称为《二十一世纪最Sexy的職业》，人工智能需求量大，鼓励了不少大学诸如伯克利大学专门成立数据科学系。硅谷和纽约为主的《The Data Incubator》公司於2012年成立，焦点是数据科学，大数据，和人工智能企业培训，提供国际大数据培训服务。\n\nAI對人類的威脅\n此議題目前分成兩個學派：\n\n悲觀學派\n此學派的代表是天文物理學家史蒂芬·霍金，以及特斯拉執行長伊隆·馬斯克。霍金認為AI對人類將來有很大的威脅，主要有以下理由：\n\nAI會遵循科技發展的加速度理論。\nAI可能會有自我改造創新的能力。\nAI進步的速度遠遠超過人類。\n人類會有被滅絕的危機。\n\n樂觀學派\n主要是Google、Facebook等AI的主要技術發展者，他們對AI持樂觀看法的理由：\n\n人類只要關掉電源就能除掉AI機器人。\n任何的科技都會有瓶頸，摩爾定律到目前也遇到相當的瓶頸，AI科技也不會無限成長，依然存在許多難以克服的瓶頸。\n依目前的研究方向，電腦無法突變、甦醒、產生自我意志，AI也不可能具有創意與智慧、同情心與審美等這方面的能力。\n\nAI與管理\nAI逐漸普及後，將會在企業管理中扮演很重要的角色，而人類的管理者應如何適度的調整自己的工作職能，有以下幾點建議：\n\n放棄行政工作；\n退守分析預測的領域而強化自己的綜合判斷力；\n把AI當作同事，形成協同合作的團隊；\n多琢磨在創造力以及各種流程架構設計師角色；\n強化自己人際網路、溝通協調、談判上的能力；\n培養自身領導能力，能有效地帶領一個士氣高、團結及凝結力高的工作夥伴。\n\n滥用\n2019年6月，基于神经网络技术DeepNude软件面世，该软件可以将人物照片的衣着褪去，显示出裸体。随后，经该软件处理后的色情图片在网络上泛滥并引发争议，此后该软件在批评声中被下架。据美国网络安全公司Sensity统计，DeepNude已经产生了68万以上女性的假裸照，其中70%的原照片来自社交网络中的真实女性，而经DeepFake技术处理的视频在以每6个月翻一番的数量增长。截至2020年12月 (2020-12)，Sensity检测到的相关视频数量超过8.5万个。而恶用该技术则可能涉嫌违反《著作权法》等法律，日本警方便多次处理过使用人工智能技术去除色情影片中的马赛克、替换色情影片中女优容貌等相关案件。\n\n學科範疇\n人工智能是一門邊緣學科，屬於自然科學和社會科學的交叉。\n\n涉及学科\n认知科学\n数学及统计学\n物理学\n逻辑学\n控制论及決定論\n社会学\n犯罪學及智慧犯罪学\n\n研究範疇\n哲學\n強人工智能和弱人工智能\n人工智能的一個比較流行的定義，也是該領域較早的定義，是由當時麻省理工學院的约翰·麦卡锡于1956年的達特矛斯會議上提出的：人工智能就是要讓機器的行為看起來就像是人所表現出的智能行為一樣。但是這個定義似乎忽略了強人工智能的可能性（見下）。另一個定義指人工智能是人造機器所表現出來的智能。總體來講，目前對人工智能的定義大多可劃分為四類，即機器「像人一樣思考」、「像人一樣行動」、「理性地思考」和「理性地行動」。這裡「行動」應廣義地理解為採取行動，或制定行動的決策，而不是肢體動作。\n\n強人工智能\n強人工智能觀點認為「有可能」製造出「真正」能推理和解決問題的智能機器，並且，這樣的機器將被認為是具有知覺、有自我意識的。強人工智能可以有兩類：\n\n人類的人工智能，即機器的思考和推理就像人的思維一樣。\n非人類的人工智能，即機器產生了和人完全不一樣的知覺和意識，使用和人完全不一樣的推理方式。\n\n弱人工智能\n弱人工智能觀點認為「不可能」製造出能「真正」地推理和解決問題的智能機器，這些機器只不過「看起來」像是智能的，但是並不真正擁有智能，也不會有自主意識。\n弱人工智能是對比強人工智能才出現的，因為人工智能的研究一度處於停滯不前的狀態下，直到類神經網路有了強大的運算能力加以模擬後，才開始改變並大幅超前。但人工智能研究者不一定同意弱人工智能，也不一定在乎或者了解強人工智能和弱人工智能的內容與差別，對定義爭論不休。\n就當下的人工智能研究領域來看，研究者已大量造出「看起來」像是智能的機器，取得相當豐碩的理論上和實質上的成果，如2009年康乃爾大學教授Hod Lipson 和其博士研究生Michael Schmidt 研發出的 Eureqa電腦程式，只要給予一些資料，這電腦程式自己只用幾十個小時計算就推論出牛頓花費多年研究才發現的牛頓力學公式，等於只用幾十個小時就自己重新發現牛頓力學公式，這電腦程式也能用來研究很多其他領域的科學問題上。這些所謂的弱人工智慧在神經網路發展下已經有巨大進步，但對於要如何整合成強人工智慧，現在還沒有明確定論。\n\n對強人工智能的哲學爭論\n主條目：人工智能哲學、图灵测试、物理符號系統、皇帝新脑、德雷福斯對人工智能的看法、AI效應\n「強人工智能」一詞最初是约翰·瑟尔針對電腦和其它資訊處理機器創造的，其定義為：\n「強人工智能觀點認為計算機不僅是用來研究人的思維的一種工具；相反，只要运行適當的程序，計算機本身就是有思維的。」（J Searle in Minds Brains and Programs. The Behavioral and Brain Sciences, vol. 3, 1980）\n關於強人工智能的爭論，不同於更廣義的一元論和二元論的爭論。其爭論要點是：如果一台機器的唯一工作原理就是轉換編碼數據，那麼這台機器是不是有思維的？希爾勒認為這是不可能的。他舉了個中文房間的例子來說明，如果機器僅僅是轉換數據，而數據本身是對某些事情的一種編碼表現，那麼在不理解這一編碼和這實際事情之間的對應關係的前提下，機器不可能對其處理的數據有任何理解。基於這一論點，希爾勒認為即使有機器通過了圖靈測試，也不一定說明機器就真的像人一樣有自我思維和自由意識。\n也有哲學家持不同的觀點。丹尼爾·丹尼特在其著作《意識的解釋》（Consciousness Explained）裡認為，人也不過是一台有靈魂的機器而已，為什麼我們認為：「人可以有智能，而普通機器就不能」呢？他認為像上述的數據轉換機器是有可能有思維和意識的。\n有的哲學家認為如果弱人工智能是可實現的，那麼強人工智能也是可實現的。比如西蒙·布莱克本（Simon Blackburn）在其哲學入門教材Think裡說道，一個人的看起來是「智能」的行動並不能真正說明這個人就真的是智能的。我永遠不可能知道另一個人是否真的像我一樣是智能的，還是說她／他僅僅是「看起來」是智能的。基於這個論點，既然弱人工智能認為可以令機器「看起來」像是智能的，那就不能完全否定這機器是真的有智能的。布莱克本認為這是一個主觀認定的問題。\n需要指出的是，弱人工智能並非和強人工智能完全對立，也就是說，即使強人工智能是可能的，弱人工智能仍然是有意義的。至少，今日的計算機能做的事，像算術運算等，在一百多年前是被認為很需要智能的。並且，即使強人工智能被證明為可能的，也不代表強人工智能必定能被研製出來。\n\n挑战与风险\n幻觉 (人工智能)——由AI做出的非事實聲稱\n可解释人工智能\n人工智能安全及人工智能伦理\n人工智能法案——歐盟法律\nartificial intelligence in the labour market\n通用人工智能的生存风险——一种认为通用人工智能最终可能毁灭人类的假说\n\n參看\n参考文献\n引用\n来源\n注解\n扩展阅读\n外部連結\n\nWhat Is AI?—An introduction to artificial intelligence by AI founder John McCarthy.\n开放目录项目中的“AI”\nAITopics—A large directory of links and other resources maintained by the Association for the Advancement of Artificial Intelligence, the leading organization of academic AI researchers.\nArtificial Intelligence Discussion group （页面存档备份，存于互联网档案馆）\n机器人智能机器人智能\nLoebner Prize website（页面存档备份，存于互联网档案馆）\nGame AI—計算機遊戲開發者的AI資源\nKurzweil CyberArt Technologies（页面存档备份，存于互联网档案馆）—關於人工智能藝術的網站，裡面有著名的人工智能繪畫程序AARON\n中華民國人工智慧學會 （页面存档备份，存于互联网档案馆）—以促進中華民國人工智慧及相關領域之研究、發展、應用與交流為宗旨的民間組織。"}
{"title": "15.ai", "text": "15.ai是一个免费的非商业化网络应用程序，利用人工智能生成热门媒体中虚构角色的文本转语音。由一位在麻省理工学院期间名为15的人工智能研究员开发，该应用允许用户让电子游戏、电视节目和电影中的角色以定制文本进行情感化语音表达，其生成速度比实时还快。该平台因其使用极少的训练数据就能生成逼真的语音而闻名——\"15.ai\"这一名称即源于开发者声称只需15秒的音频即可克隆出语音。\n15.ai于2020年3月推出，在2021年初因在YouTube和Twitter等社交媒体平台上爆红而广受关注，并迅速在互联网粉丝群体中流行，包括《我的小马驹：友谊就是魔法》、《军团要塞2》以及《海绵宝宝》的粉丝群体。该服务通过支持表情符号表达情感语境以及通过音标转录实现精准发音控制而脱颖而出。15.ai被认为是首个在迷因和内容创作中普及人工智能语音克隆（音频深度伪造）的主流平台。\n15.ai在数据高效语音合成和情感表达方面的创新对后续的AI文本转语音技术发展产生了深远影响。2022年1月，Voiceverse NFT爆出争议，因其与声优Troy Baker合作的公司被发现盗用了15.ai的工作成果。最终，该服务于2022年9月下线，其停运促使之后几年中各种商业替代品的涌现。\n\n參見\n人工智能热潮\nCharacter.ai\n深度偽造\nWaveNet\n彩虹小馬：友情就是魔法影迷\n\n註釋\n\n\n== 參考資料 =="}
{"title": "ACM 电脑分类系统", "text": "ACM电脑分类系统（ACM Computing Classification System，CCS）是由美国计算机协会(ACM)设计的计算学科分类系统。该系统在范围、目标和结构上可与数学学科分类标准(MSC)相媲美，因此被各种ACM期刊用于按区域组织主题。\n\n历史\n该系统历经七次修订，第一版于1964年发布，于1982年、1983年、1987年、1991年、1998年修订，目前最新的版本于2012年修订。\n\n结构\n它按层次结构分为四个层次。例如，层次结构的一个分支包含：\n\n计算方法\n人工智能\n知识表示与推理\n本体工程\n\n参见\n计算机科学本体\n物理和天文学分类方案\narXiv\nPhysics Subject Headings\n\n参考资料\nCoulter, Neal, ACM's computing classification system reflects changing times, Communications of the ACM (New York, NY, USA: ACM), 1997, 40 (12): 111–112, doi:10.1145/265563.265579 .\nCoulter, Neal (chair); French, James; Glinert, Ephraim; Horton, Thomas; Mead, Nancy; Ralston, Anthony; Rada, Roy; Rodkin, Craig; Rous, Bernard, Computing Classification System 1998: Current Status and Future Maintenance Report of the CCS Update Committee (PDF), Computing Reviews (New York, NY, USA: ACM), January 21, 1998: 1–5  [2022-05-07], （原始内容 (PDF)存档于2017-08-30） .\nMirkin, Boris; Nascimento, Susana; Pereira, Luis Moniz, Representing a Computer Science Research Organization on the ACM Computing Classification System, Eklund, Peter; Haemmerlé, Ollivier  (编), Supplementary Proceedings of the 16th International Conference on Conceptual Structures (ICCS-2008) (PDF), CEUR Workshop Proceedings 354, RWTH Aachen University: 57–65, 2008  [2022-05-07], （原始内容 (PDF)存档于2021-08-31） .\n\n外部链接\n[1] （页面存档备份，存于互联网档案馆）：ACM系统的主页，包括系统的四个完整版本的链接，即1964 [2] （页面存档备份，存于互联网档案馆） ，1991 [3] （页面存档备份，存于互联网档案馆） 、1998 [4] （页面存档备份，存于互联网档案馆）和当前的 2012 版本[5] （页面存档备份，存于互联网档案馆） 。\nACM Computing Research Repository （页面存档备份，存于互联网档案馆）使用的分类方案 （页面存档备份，存于互联网档案馆）比 ACM 主题分类粗得多，并且不涵盖 CS 的所有领域，但旨在更好地涵盖活跃的研究领域。此外，该存储库中的论文根据 ACM 学科分类进行分类。"}
{"title": "AI", "text": "AI可以指：\n\n人工智能（Artificial Intelligence）\n人工智能 (电影)（A.I. Artificial Intelligence），2001年斯蒂芬·斯皮尔伯格（Steven Spielberg）科幻电影\n人工授精（Artificial Insemination）\n國際特赦組織（Amnesty International）\nAdobe Illustrator，Adobe系統公司推出的基於向量的圖形製作軟件。\n美國偶像（American Idol），美國真人秀節目\n欣赏指数（Appreciation Index），英国电视、广播评价指标\n印度航空的IATA編號\n瑞士内阿彭策尔州的州份代码\nAI (歌手)，日本女性R&B歌手。\n艾倫·艾佛森（Allen Iverson），前美國NBA，綽號AI。\n絆愛（Kizuna AI），日本的虛擬YouTuber\nai (复合元音)， 一些语言的复合母音。\nab initio，拉丁语词汇。\n抽象解释（Abstract Interpretation），計算理論中形式語義學的一項概念。"}
{"title": "机器学习", "text": "机器学习（英語：machine learning，简称ML）是人工智能的一个分支。机器学习理论主要是设计和分析一些让计算机可以自动“学习”的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。因为学习算法中涉及了大量的统计学理论，机器学习与推断统计学联系尤为密切，也被称为统计学习理论。算法设计方面，机器学习理论关注可以实现的，行之有效的学习算法（要防止錯誤累積）。很多推论问题属于非程序化決策，所以部分的机器学习研究是开发容易处理的近似算法。\n机器学习已广泛应用于数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡詐騙、证券市场分析、DNA序列测序、语音和手写识别、游戏和机器人等领域。机器学习在近30多年已发展为一门多领域科际整合，涉及概率论、统计学、逼近论、凸分析、计算复杂性理论、資訊理論等多门学科。\n\n定義\n機器學習有下面幾種定義：\n\n機器學習是一門人工智能的科學，該領域的主要研究對象是人工智能，特別是如何在經驗學習中改善具體算法的性能。\n機器學習是對能通過經驗自動改進的計算機算法的研究。\n機器學習是用數據或以往的經驗，以此優化計算機程序的性能標準。\n另外，電腦科學家湯姆·米切爾在其著作的Machine Learning一書中定義的機器學習為：\n\nA computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.\n\n历史\n与其他领域的关系\n作为一项科学事业，机器学习起源于人类对人工智能（Artificial Intelligence，简称AI）的探索。在AI作为学术领域早期阶段，一些研究者希望能让机器从数据中学习。他们尝试通过多种符号方法（symbolic methods）来解决这个问题，同时也采用了当时称为“神经网络”（neural networks）的方法。这些神经网络模型主要包括感知机（perceptrons）以及其他一些模型，后来发现这些模型实际上是统计学中广义线性模型（generalized linear models）的重新发明。此外，当时研究者还广泛使用概率推理（probabilistic reasoning）方法，尤其是在自动化医学诊断领域。\n然而，随着学术界对逻辑和基于知识的（knowledge-based）方法日益强调，人工智能（AI）和机器学习之间逐渐产生了分歧。概率系统（probabilistic systems）也面临着数据获取和数据表示方面的理论与实际问题。到1980年左右，专家系统（expert systems）开始在人工智能领域占据主导地位，统计学方法逐渐被边缘化。在AI领域内部，符号学习（symbolic learning）或知识学习（knowledge-based learning）的研究依然继续，并催生了归纳逻辑编程（inductive logic programming，简称ILP）。而更为侧重统计方法的研究，则逐渐被归类到模式识别（pattern recognition）和信息检索（information retrieval）等领域，不再属于AI的核心研究方向。同时，神经网络（neural networks）的研究也在AI和计算机科学（computer science）领域被逐渐放弃。这条研究路径后来在AI和计算机科学之外继续发展，形成了以“联结主义”（connectionism）为代表的学派，由其他领域的研究者推动，如约翰·霍普菲尔德（John Hopfield）、大卫·鲁梅尔哈特（David Rumelhart）和杰弗里·辛顿（Geoffrey Hinton）等人。他们的研究在1980年代中期取得了重要突破，其中以反向传播算法（backpropagation）的重新发现最为显著。\n机器学习（Machine Learning，简称ML）在1990年代被重新整合并确立为独立的研究领域，并开始蓬勃发展。这一领域的目标也从最初追求实现人工智能（Artificial Intelligence，简称AI），转变为解决实际中能够被有效解决的问题。研究重心逐渐远离了继承自AI的符号方法（symbolic approaches），转向了从统计学（statistics）、模糊逻辑（fuzzy logic）以及概率理论（probability theory）中借鉴的方法和模型。\n\n理论\n学习器（learner）的核心目标之一是从经验中进行泛化（generalize）。在这一背景下，泛化指的是学习机器在经历了训练数据集（learning data set）之后，能够在新出现的、未曾见过的样本或任务上准确表现的能力。这些训练样本通常来自某个未知的概率分布（probability distribution，这个概率分布被认为能代表真实场景中事件的分布空间），学习器需要基于这些数据构建出一个一般化的模型，从而能够对新的情景或样本做出足够准确的预测。\n对机器学习算法及其性能进行的计算分析，是理论计算机科学（theoretical computer science）的一个分支，称为计算学习理论（computational learning theory），通常通过概率近似正确学习模型（probably approximately correct learning，简称PAC Learning）实现。由于训练集（training sets）是有限的，而未来又充满不确定性，因此学习理论通常并不能绝对保证算法的表现；取而代之的是，通常会给出算法性能的概率性界限（probabilistic bounds）。偏差-方差分解（bias–variance decomposition）是一种用于量化泛化误差（generalization error）的方法。\n为了获得最佳的泛化（generalization）性能，假设（hypothesis，也即模型）的复杂度应与数据背后的真实函数（function）的复杂度相匹配。如果假设的复杂度低于真实函数的复杂度，那么模型就会出现欠拟合（underfitting）的现象；在这种情况下，适当增加模型的复杂度可以降低训练误差（training error）。然而，如果假设的复杂度过高，模型又会面临过拟合（overfitting）问题，从而导致泛化能力下降。\n除了研究性能界限（performance bounds）之外，学习理论的研究人员也关注学习的时间复杂度（time complexity）和可行性（feasibility）。在计算学习理论（computational learning theory）中，如果某个计算可以在多项式时间（polynomial time）内完成，那么就被视为是可行的（feasible）。关于时间复杂度，有两种类型的结果：\n\n正面结果（Positive results） 表明某一类函数可以在多项式时间内被学习；\n负面结果（Negative results） 表明某些函数类别无法在多项式时间内被学习。\n\n分类\n机器学习方法传统上被划分为以下几类，对应不同的学习范式（learning paradigms），具体取决于学习系统可获得的“信号”或“反馈”的类型：\n\n监督学习：从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类。监督学习和非监督学习的差别就是训练集目标是否有人为标注。他们都有训练集 且都有输入和输出\n无监督学习：与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成對抗網絡（GAN）、聚类。\n半监督学习：介于监督学习与无监督学习之间。\n强化学习：机器为了达成目标，随着环境的变动，而逐步调整其行为，并评估每一个行动之后所到的回馈是正向的或负向的。\n\n模型与方法\n机器学习模型是一种数学模型，在经过某个数据集的“训练”之后，可以用于对新数据进行预测或分类。在训练过程中，学习算法会通过迭代不断调整模型的内部参数，以尽可能减少预测误差。广义上，“模型”一词可以指代不同层级的内容：既可以是某一类模型及其对应的学习算法，也可以是所有内部参数都已经调整完毕、训练完成的具体模型。\n在机器学习系统中，已经研究和应用了多种类型的模型。为特定任务选择最合适的模型的过程被称为模型选择（model selection）**。\n具体的机器学习模型有：\n\n构造间隔理论分布：聚类分析和模式识别\n人工神经网络\n决策树\n感知器\n支援向量機\n集成学习AdaBoost\n降维与度量学习\n聚类\n贝叶斯分类器\n构造条件概率：回归分析和统计分类\n高斯过程回归\n线性判别分析\n最近邻居法\n径向基函数核\n通过再生模型构造概率密度函数：\n最大期望算法\n概率图模型：包括貝氏網路和Markov随机场\nGenerative Topographic Mapping\n近似推断技术：\n马尔可夫链\n蒙特卡罗方法\n变分法\n最优化：大多数以上方法，直接或者间接使用最优化算法。\n量子機器學習\n\n人工神经网络\n人工神经网络（Artificial Neural Networks，简称ANNs），又称联结主义系统（connectionist systems），是一类受动物大脑中生物神经网络启发而构建的计算系统。这类系统通过学习样本来完成任务，而通常不依赖于任何针对特定任务的预设规则。换句话说，它们是通过观察大量示例，逐步“学会”如何解决问题的。\n人工神经网络（ANN）是一种由多个相互连接的单元或节点构成的模型，这些节点被称为“人工神经元”，其灵感来源于生物大脑中的神经元。在人工神经网络中，每个连接类似于生物大脑中的突触，可以在人工神经元之间传递信息，也就是“信号”。\n一个接收到信号的人工神经元可以对其进行处理，并将处理后的信号传递给与其连接的其他人工神经元。在常见的ANN实现中，神经元之间连接所传递的信号是一个实数，而每个人工神经元的输出是其所有输入的加权和经过某种非线性函数变换后的结果。\n神经元之间的连接称为“边”（edges）。人工神经元和连接边通常都带有一个权重，这个权重会随着学习过程的进行而调整。权重决定了信号传递的强度，权重越大，信号越强。有些人工神经元还设有阈值：只有当接收到的总信号超过该阈值时，才会传递输出信号。\n通常，人工神经元会被组织成不同的层（layers）。不同的层可能对输入执行不同类型的变换。信号从第一层（输入层）开始，一直传递到最后一层（输出层），过程中可能会多次经过中间的隐藏层。\n人工神经网络（ANN）最初的目标是模拟人脑的工作方式来解决问题。然而，随着时间的推移，研究重点逐渐转向如何高效地完成特定任务，这也导致了神经网络的发展逐渐偏离了生物学上的真实神经结构。\n尽管如此，人工神经网络已经在众多领域得到了广泛应用，包括：  \n\n计算机视觉（computer vision）\n语音识别（speech recognition）\n机器翻译（machine translation）\n社交网络内容过滤（social network filtering）\n棋类与电子游戏（playing board and video games）\n医学诊断（medical diagnosis）\n这些成功应用证明了神经网络在解决复杂、非线性问题方面的强大能力。\n深度学习（Deep Learning）是指在人工神经网络中引入多个隐藏层（hidden layers）的一种方法。这种方法试图模拟人脑将光和声音转化为视觉和听觉的处理方式。深度学习在多个领域取得了显著成果，其中计算机视觉（computer vision）和语音识别（speech recognition）是其最成功的应用之一。\n\n决策树\n决策树学习（Decision Tree Learning）是一种使用决策树作为预测模型的方法，通过对一个对象的观察（表示在树的分支上），推导出该对象的目标值（表示在叶子节点上）。它是统计学、数据挖掘和机器学习中常用的一种预测建模方法。\n\n当目标变量是离散值（例如分类标签）时，所构建的树被称为分类树（Classification Tree）。在这类树结构中，叶子节点代表类别标签，分支则代表导致这些标签的特征组合。\n当目标变量是连续值（通常是实数）时，该树称为回归树（Regression Tree）。\n在决策分析（Decision Analysis）中，决策树可以被用来直观、明确地表示决策过程及其可能结果。而在数据挖掘（Data Mining）中，决策树不仅可以用来描述数据本身，其生成的分类树还可以作为后续决策的依据。\n总结来说，决策树是一种结构清晰、解释性强的模型，适合处理既有分类又有回归问题。\n\n随机森林回归\n随机森林回归（Random forest regression, RFR）属于基于决策树的模型范畴。RFR 是一种集成学习方法（ensemble learning method），它通过构建多个决策树并对其预测结果进行平均，从而提高预测的准确性并有效避免过拟合。\n在构建决策树的过程中，RFR 采用自助采样法（bootstrapped sampling），也就是说，每棵决策树都是在训练集中随机抽取的一部分数据上进行训练的。这种训练方式的“随机性”有助于减少模型的偏差，使预测结果更加准确。\nRFR 会生成相互独立的多个决策树，它既可以用于单一输出变量的回归问题，也可以用于多回归任务（multiple regressor task）。这种灵活性使得 RFR 能够被广泛应用于各种实际场景中。\n\n支持向量机\n支持向量机（SVM），也称为支持向量网络（Support-Vector Networks），是一组用于分类（classification）和回归（regression）的监督学习方法。在给定一组训练样本的前提下，其中每个样本都被标注为属于两个类别之一，SVM 的训练算法会构建一个模型，用来预测新的样本属于哪个类别。SVM 是一种非概率性的二分类线性分类器，虽然也有像 Platt scaling 这样的扩展方法，可以使其应用于概率分类任务。\n除了进行线性分类，SVM 还可以借助所谓的核技巧（kernel trick），高效地实现非线性分类。这种方法通过隐式地将输入映射到高维特征空间，使得在原本线性不可分的问题中，也能找到一个可分的超平面，从而实现更复杂的分类效果。\n\n回归分析\n回归分析（Regression analysis）是一个涵盖广泛的统计方法集合，主要用于估计输入变量与其相关特征之间的关系。其中最常见的形式是线性回归（Linear Regression），通过一条直线来最优地拟合给定数据，这条线通常依据某种数学准则（如最小二乘法，Ordinary Least Squares）确定。\n为了减轻过拟合（overfitting）和偏差（bias）的问题，线性回归往往会结合正则化方法（regularization methods）进行扩展，例如岭回归（Ridge Regression）。\n在面对非线性问题时，常用的替代模型包括：\n\n多项式回归（Polynomial Regression）：如 Microsoft Excel 中用于趋势线拟合的工具；\n逻辑回归（Logistic Regression）：广泛用于统计分类任务；\n核回归（Kernel Regression）：利用核技巧（kernel trick）将输入变量隐式映射到更高维空间，从而引入非线性。\n这些模型能够更灵活地拟合和预测现实中复杂的数据关系。\n多元线性回归（Multivariate Linear Regression）是在传统线性回归的基础上扩展而来的，用于同时处理多个因变量（输出变量）的情况。这种方法通过拟合一个多维线性模型，来估计一组输入变量与多个输出变量之间的关系。\n多元线性回归特别适用于以下场景：\n\n输出变量之间存在相互依赖关系；\n多个输出共享某种潜在的模式或结构。\n例如：\n\n同时预测多个经济指标；\n重建图像数据（图像本身是多维结构）。\n这种方法在处理复杂、关联性强的多输出问题时，能提供更全面和准确的建模能力。\n\n贝叶斯网络\n贝叶斯网络（Bayesian Network），又称信念网络（Belief Network）或有向无环图模型（Directed Acyclic Graphical Model），是一种概率图模型（probabilistic graphical model），它通过一个有向无环图（Directed Acyclic Graph,DAG）来表示一组随机变量之间的条件独立性关系。\n例如，一张贝叶斯网络可以用于表示疾病与症状之间的概率关系。当给定一些症状时，可以利用该网络计算出不同疾病出现的概率，从而辅助判断可能的病因。\n贝叶斯网络配有高效的推理与学习算法，能够处理复杂的概率推断任务。\n进一步扩展：\n\n如果贝叶斯网络用于表示变量序列（如语音信号、蛋白质序列等），这样的模型称为动态贝叶斯网络（Dynamic Bayesian Networks）。\n能够在不确定性下表示并解决决策问题的贝叶斯网络模型，称为影响图（Influence Diagrams）。\n这些图模型在医学诊断、语音识别、机器人决策等领域都有重要应用。\n\n高斯过程\n高斯过程（Gaussian Processes）是一种随机过程（stochastic process），其特点是：在该过程中，任意有限数量的随机变量都服从一个多元正态分布（multivariate normal distribution）。高斯过程依赖于一个预定义的协方差函数（covariance function）或称核函数（kernel），用于建模不同点之间的关系，这种关系取决于它们在空间中的位置。\n在给定一组已观测的数据点（即输入-输出样本）后，我们可以通过这些已知点之间的协方差，以及它们与某个新的、未观测点之间的协方差，直接计算该新点的输出值的概率分布，这是高斯过程的核心能力之一。\n高斯过程在贝叶斯优化（Bayesian Optimization）中非常受欢迎，常被用作替代模型（surrogate model），特别适合用于超参数优化（hyperparameter optimization）等任务。\n\n软件\n包含各種機器學習演算法的軟體套裝包括：\n\n自由开源软件\nPython软件库及框架\n参考文献\n引用\n来源\n\n\n== 参见 =="}
{"title": "AdaBoost", "text": "AdaBoost為英文\"Adaptive Boosting\"（自适应增强）的缩写，是一种机器学习方法，由約阿夫·弗羅因德和羅伯特·沙皮爾提出。AdaBoost方法的自适应在于：前一个分类器分错的样本会被用来训练下一个分类器。AdaBoost方法对于噪声数据和异常数据很敏感。但在一些问题中，AdaBoost方法相对于大多数其它学习算法而言，不会很容易出现过拟合现象。AdaBoost方法中使用的分类器可能很弱（比如出现很大错误率），但只要它的分类效果比随机好一点（比如两类问题分类错误率略小于0.5），就能够改善最终得到的模型。而错误率高于随机分类器的弱分类器也是有用的，因为在最终得到的多个分类器的线性组合中，可以给它们赋予负系数，同样也能提升分类效果。\nAdaBoost方法是一种迭代算法，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率。每一个训练样本都被赋予一个权重，表明它被某个分类器选入训练集的概率。如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它被选中的概率就被降低；相反，如果某个样本点没有被准确地分类，那么它的权重就得到提高。通过这样的方式，AdaBoost方法能“聚焦于”那些较难分（更富信息）的样本上。在具体实现上，最初令每个样本的权重都相等，对于第k次迭代操作，我们就根据这些权重来选取样本点，进而训练分类器Ck。然后就根据这个分类器，来提高被它分错的样本的权重，并降低被正确分类的样本权重。然后，权重更新过的样本集被用于训练下一个分类器Ck。整个训练过程如此迭代地进行下去。\n\nAdaBoost算法\n用xi和yi表示原始样本集D的样本点和它们的类标。用Wk(i)表示第k次迭代时全体样本的权重分布。这样就有如下所示的AdaBoost算法：\n\n初始化：输入参数为训练集D={x1，y1，...，xn，yn}，最大循环次数kmax，采样权重Wk(i)=1/n，i=1，...，n；\n迭代计数器k赋值为0；\n计数器k自增1；\n使用Wk(i)采样权重对弱学习器Ck进行训练；\n对弱学习器Ck的训练结果进行评估并记录进误差矩阵Ek中；\n\n  \n    \n      \n        \n          α\n          \n            k\n          \n        \n        ←\n        \n          \n            \n              1\n              2\n            \n          \n        \n        ln\n        ⁡\n        \n          \n            \n              1\n              −\n              \n                E\n                \n                  k\n                \n              \n            \n            \n              E\n              \n                k\n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\alpha _{k}\\gets {\\tfrac {1}{2}}\\ln {\\frac {1-E_{k}}{E_{k}}}}\n  \n\n  \n    \n      \n        \n          W\n          \n            k\n            +\n            1\n          \n        \n        (\n        i\n        )\n        ←\n        \n          \n            \n              \n                \n                  W\n                  \n                    k\n                  \n                \n                (\n                i\n                )\n              \n              \n                Z\n                \n                  k\n                \n              \n            \n          \n        \n        ×\n        \n          \n            {\n            \n              \n                \n                  \n                    e\n                    \n                      −\n                      \n                        α\n                        \n                          k\n                        \n                      \n                    \n                  \n                  ,\n                \n                \n                  \n                    \n                      if \n                    \n                  \n                  \n                    h\n                    \n                      k\n                    \n                  \n                  (\n                  \n                    x\n                    \n                      i\n                    \n                  \n                  )\n                  =\n                  \n                    y\n                    \n                      i\n                    \n                  \n                \n              \n              \n                \n                  \n                    e\n                    \n                      \n                        α\n                        \n                          k\n                        \n                      \n                    \n                  \n                  ,\n                \n                \n                  \n                    \n                      if \n                    \n                  \n                  \n                    h\n                    \n                      k\n                    \n                  \n                  (\n                  \n                    x\n                    \n                      i\n                    \n                  \n                  )\n                  ≠\n                  \n                    y\n                    \n                      i\n                    \n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle W_{k+1}(i)\\gets {\\dfrac {W_{k}(i)}{Z_{k}}}\\times {\\begin{cases}e^{-\\alpha _{k}},&{\\mbox{if  }}h_{k}(x^{i})=y_{i}\\\\e^{\\alpha _{k}},&{\\mbox{if  }}h_{k}(x^{i})\\neq y_{i}\\end{cases}}}\n  \n\n当k=kmax时停止训练\n返回结果 Ck和αk，k=1，...，kmax（带权值分类器的总体）\n结束\n注意第5行中，当前权重分布必须考虑到分类器Ck的误差率。在第7行中，Zk只是一个归一化系数，使得Wk(i)能够代表一个真正的分布，而hk(xi)是分量分类器Ck给出的对任一样本点xi的标记（+1或-1），hk(xi) = yi时，样本被正确分类。第8行中的迭代停止条件可以被换为判断当前误差率是否小于一个阈值。\n最后的总体分类的判决可以使用各个分量分类器加权平均来得到：\n\n  \n    \n      \n        g\n        (\n        x\n        )\n        =\n        [\n        \n          ∑\n          \n            k\n            =\n            1\n          \n          \n            \n              k\n              \n                m\n                a\n                x\n              \n            \n          \n        \n        \n          α\n          \n            k\n          \n        \n        \n          h\n          \n            k\n          \n        \n        (\n        x\n        )\n        ]\n      \n    \n    {\\displaystyle g(x)=[\\sum _{k=1}^{k_{max}}\\alpha _{k}h_{k}(x)]}\n  \n\n这样，最后对分类结果的判定规则是：\n\n  \n    \n      \n        H\n        (\n        x\n        )\n        =\n        \n          \n            sign\n          \n        \n        \n          (\n          \n            g\n            (\n            x\n            )\n          \n          )\n        \n      \n    \n    {\\displaystyle H(x)={\\textrm {sign}}\\left(g(x)\\right)}\n\n软件实现\nAdaBoost and the Super Bowl of Classifiers - A Tutorial on AdaBoost.（页面存档备份，存于互联网档案馆）\nAdaboost in C++（页面存档备份，存于互联网档案馆）, an implementation of Adaboost in C++ and boost by Antonio Gulli\nicsiboost（页面存档备份，存于互联网档案馆）, an open source implementation of Boostexter\nJBoost（页面存档备份，存于互联网档案馆）, a site offering a classification and visualization package, implementing AdaBoost among other boosting algorithms.\nMATLAB AdaBoost toolbox. Includes Real AdaBoost, Gentle AdaBoost and Modest AdaBoost implementations.\nA Matlab Implementation of AdaBoost（页面存档备份，存于互联网档案馆）\nMulti-threaded MATLAB-compatible implementation of Boosted Trees（页面存档备份，存于互联网档案馆）\nmilk（页面存档备份，存于互联网档案馆） for Python implements AdaBoost.\nMPBoost++（页面存档备份，存于互联网档案馆）, a C++ implementation of the original AdaBoost.MH algorithm and of an improved variant, the MPBoost algorithm.\nmultiboost, a fast C++ implementation of multi-class/multi-label/multi-task boosting algorithms. It is based on AdaBoost.MH but also implements popular cascade classifiers and FilterBoost along with a batch of common multi-class base learners（stumps, trees, products, Haar filters）。\nNPatternRecognizer （页面存档备份，存于互联网档案馆）, a fast machine learning algorithm library written in C#. It contains support vector machine, neural networks, bayes, boost, k-nearest neighbor, decision tree, ..., etc.\nOpenCV implementation of several boosting variants\nInto contains open source implementations of many AdaBoost and FloatBoost variants in C++.\nMallet（页面存档备份，存于互联网档案馆） Java implementation.\nadabag adabag: An R package for binary and multiclass Boosting and Bagging.\nScikit-learn Python implementation.\n\n\n== 参考书目 =="}
{"title": "AlphaFold", "text": "AlphaFold（直譯：阿爾法折疊）是Alphabet旗下Google旗下DeepMind开发的一款蛋白質結構預測程式。該程序被設計為一個深度學習系統。\nAlphaFold人工智能有2個主要版本：AlphaFold 1（2018）和AlphaFold 2（2020）。前者使用AlphaFold 1在2018年12月的第13屆CASP（英語：Critical Assessment of protein Structure Prediction，直譯：蛋白質結構預測的關鍵評估）的排名中第一。該程序特別成功地預測了被競賽組織者評為最困難的目標的最準確結構，其中沒有來自具有部分相似序列的蛋白質的現有模板結構。\n蛋白质通过卷曲折叠會构成三维结构，蛋白质的功能正由其結構決定。了解蛋白質結構有助於開發治療疾病的藥物。DeepMind稱，AlphaFold能在数天内识别蛋白质的形状，而此前學界識別蛋白质形状經常需花費數年時間。2020年11月，在第14届CASP（英語：Critical Assessment of protein Structure Prediction，直譯：蛋白質結構預測的關鍵評估）競賽中，AlphaFold 2(2020)表現良好，中位分数为92.4（满分100分）。它的准确度远远高于其他任何程式。\n2021年7月15日，AlphaFold 2論文在《自然》雜誌上作為高級訪問出版物與開源軟件和可搜索的物種蛋白質組數據庫一起發表。\n2024年5月8日，AlphaFold 3发布。它可以预测蛋白质与DNA、RNA、各种配体和离子形成的复合物的结构。\n\n蛋白質折疊問題\n蛋白質由蛋白質一級結構組成，蛋白質折疊的過程中蛋白質會自發折疊形成蛋白質三級結構。蛋白質結構對蛋白質生物學功能至關重要。然而，了解氨基酸序列如何確定蛋白質三級結構極具挑戰性，這被稱為「蛋白質折疊問題」。「蛋白質折疊問題」涉及折疊穩定結構的原子間力熱力學、蛋白質以極快速達到其最終折疊狀態的機制和途徑，以及如何從氨基酸序列預測蛋白質天然結構。\n蛋白質結構過去通過諸如X射線晶體學、低溫電子顯微鏡和核磁共振等技術進行實驗確定，這些技術既昂貴又耗時。\n過去60年努力只確定了約170,000種蛋白質結構，而所有生命形式中已知蛋白質超過2億種。\n如果可以僅從氨基酸序列預測蛋白質結構，將極大地促進科學研究。然而利文索爾佯謬表明，雖蛋白質可在幾毫秒內折疊，但隨機計算所有可能的結構以確定真正的天然結構所需的時間比已知宇宙的年齡要長，這使得預測蛋白質為科學家們構建了生物學中的一項重大挑戰。\n多年來，研究人員應用了許多計算方法來解決蛋白質結構預測問題，但除了小而簡單的蛋白質外，它們準確性還遠遠遠沒有接近實驗技術，從而限制了科學研究。\nCASP於1994年發起，旨在挑戰科學界做出最好的蛋白質結構預測，結果對於最困難的到2016年的蛋白質發現GDT分數也只能達到100滿分的40分。\n2018年，AlphaFold使用人工智能深度學習技術參加CASP。\n\n算法\nAlphaFold蛋白質結構數據庫\nAlphaFold蛋白質結構數據庫於2021年7月22日啟動，這是AlphaFold和歐洲分子生物學實驗室的歐洲生物信息研究所的共同努力。AlphaFold提供對超過2億個蛋白質結構預測的開放訪問，以加速科學研究。在啟動時，該數據庫包含人類和20種模式生物的幾乎完整UniProt蛋白質組的AlphaFold預測蛋白質結構模型，總計超過365,000種蛋白質（該數據庫不包括少於16個或多於2700個氨基酸殘基蛋白質，但對人類而言，殘基蛋白質可在文件中獲得。）。\nAlphaFold目標是覆蓋UniRef90中1億個蛋白質大部分集合。截至2022年5月15日，已有992,316個可用。\n\n應用\nAlphaFold已被用於預測SARS-CoV-2（COVID-19的病原體）的蛋白質結構。 這些蛋白質的結構在2020年初有待實驗檢測。在將結果發佈到更大的研究界之前，英國弗朗西斯·克里克研究所(Francis Crick Institute)的科學家們對結果進行了檢查。該團隊還證實了對實驗確定的SARS-CoV-2刺突蛋白的準確預測，該蛋白在國際開放存取數據庫蛋白質資料庫(Protein Data Bank)中共享，然後發布了計算確定的未充分研究的蛋白質分子的結構。\n\n參見\nFolding@home\nRosetta@home\nAlphaZero\nAlphaGo\nFoldit\n\n参考文献\n外部链接\nAlphaFold(2018年)\nAlphaFold: The making of a scientific breakthrough （页面存档备份，存于互联网档案馆）, DeepMind, via YouTube.\nSenior, Andrew. AlphaFold: improved protein structure prediction using potentials from deep learning. Institute for Protein Design. 2019-08-23  [2020-12-03]. （原始内容存档于2020-12-19） –通过YouTube. \nGitHub上的AlphaFold code used at CASP13\nGitHub上的Open source community implementationTemplate:SpndProSPr\n\nAlphaFold 2(2020年)\nGitHub上的AlphaFold v2.1 code and links to model\nOpen access to protein structure predictions for the human proteome and 20 other key organisms （页面存档备份，存于互联网档案馆） at 欧洲生物信息研究所(EMBL-EBI)\nCASP 14 （页面存档备份，存于互联网档案馆） website\nAlphaFold: The making of a scientific breakthrough （页面存档备份，存于互联网档案馆）, DeepMind, via YouTube.\nColabFold （页面存档备份，存于互联网档案馆） (Mirdita, Milot; Ovchinnikov, Sergey; Steinegger, Martin. ColabFold - Making protein folding accessible to all. 2021-08-15. bioRxiv 10.1101/2021.08.15.456425  （英语）.  ),  version （页面存档备份，存于互联网档案馆） for homooligomeric prediction and complexes （页面存档备份，存于互联网档案馆）"}
{"title": "深度学习", "text": "深度学习（英語：deep learning）是机器学习的分支，是一種以人工神經網路為架構，對資料進行表徵學習的算法。深度学习中的形容词“深度”是指在网络中使用多层。 早期的工作表明，线性感知器不能成为通用分类器，但具有非多项式激活函数和一个无限宽度隐藏层的网络可以成为通用分类器。\n深度学习是机器学习中一种基于对数据进行表征学习的算法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域等。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。深度学习的好处是用非监督式或半监督式的特征学习和分层特征提取高效算法来替代手工获取特征。\n表征学习的目标是寻求更好的表示方法并建立更好的模型来从大规模未标记数据中学习这些表示方法。表示方法来自神经科学，并松散地建立在類似神经系统中的信息处理和对通信模式的理解上，如神经编码，试图定义拉動神经元的反应之间的关系以及大脑中的神经元的电活动之间的关系。\n至今已有數种深度学习框架，如深度神经网络、卷积神经网络和深度置信网络和循环神经网络已被应用在计算机视觉、语音识别、自然语言处理、音频识别与生物信息学等领域并取得了极好的效果。\n另外，「深度学习」已成為時髦術語，或者说是人工神经网络的品牌重塑。\n\n简介\n深度学习框架，尤其是基于人工神经网络的框架可以追溯到1980年福岛邦彦提出的新认知机，而人工神经网络的历史更为久远。1989年，扬·勒丘恩（Yann LeCun）等人开始将1974年提出的标准反向传播算法应用于深度神经网络，这一网络被用于手写邮政编码识别。尽管算法可以成功执行，但计算代价非常巨大，神经网络的训练时间达到了3天，因而无法投入实际使用。许多因素导致了这一缓慢的训练过程，其中一种是由于尔根·施密德胡伯的学生赛普·霍克赖特于1991年提出的梯度消失问题。\n最早的进行一般自然杂乱图像中自然物体识别的深度学习网络是翁巨扬（Juyang Weng）等在1991和1992发表的生长网（Cresceptron）。它也是第一个提出了后来很多实验广泛采用的一个方法：现在称为最大汇集（max-pooling）以用于处理大物体的变形等问题。生长网不仅直接从杂乱自然场景中学习老师指定的一般物体，还用网络反向分析的方法把图像内被识别了的物体从背景图像中分割出来。\n2007年前后，杰弗里·辛顿和鲁斯兰·萨拉赫丁诺夫（Ruslan Salakhutdinov）提出了一种在前馈神经网络中进行有效训练的算法。这一算法将网络中的每一层视为无监督的受限玻尔兹曼机，再使用有监督的反向传播算法进行调优。在此之前的1992年，在更为普遍的情形下，施密德胡伯也曾在循环神经网络上提出一种类似的训练方法，并在实验中证明这一训练方法能够有效提高有监督学习的执行速度。\n自深度学习出现以来，它已成为很多领域，尤其是在计算机视觉和语音识别中，成为各种领先系统的一部分。在通用的用于检验的数据集，例如语音识别中的TIMIT和图像识别中的ImageNet、CIFAR-10上的实验证明，深度学习能够提高识别的精度。与此同时，神经网络也受到了其他更加简单归类模型的挑战，支持向量机等模型在20世纪90年代到21世纪初成为过流行的机器学习算法。\n硬件的进步也是深度学习重新获得关注的重要因素。高性能图形处理器的出现极大地提高了数值和矩阵运算的速度，使得机器学习算法的运行时间得到了显著的缩短。\n由于脑科学方面的大量研究已表明人脑网络不是一个级联的结构，深度学习网络在2001年后正逐渐被更有潜力的基于脑模型的网络所替代。\n\n基本概念\n深度学习的基础是机器学习中的分散表示（distributed representation）。分散表示假定观测值是由不同因子相互作用生成。在此基础上，深度学习进一步假定这一相互作用的过程可分为多个层次，代表对观测值的多层抽象。不同的层数和层的规模可用于不同程度的抽象。\n深度学习运用了这分层次抽象的思想，更高层次的概念从低层次的概念学习得到。这一分层结构常常使用贪婪算法逐层构建而成，并从中选取有助于机器学习的更有效的特征。\n不少深度学习算法都以无监督学习的形式出现，因而这些算法能被应用于其他算法无法企及的无标签数据，这一类数据比有标签数据更丰富，也更容易获得。这一点也为深度学习赢得了重要的优势。\n\n人工神经网络下的深度学习\n一部分最成功的深度学习方法涉及到对人工神经网络的运用。人工神经网络受到了1959年由诺贝尔奖得主大卫·休伯尔（David H. Hubel）和托斯坦·威泽尔（Torsten Wiesel）提出的理论启发。休伯尔和威泽尔发现，在大脑的初级视觉皮层中存在两种细胞：简单细胞和复杂细胞，这两种细胞承担不同层次的视觉感知功能。受此启发，许多神经网络模型也被设计为不同节点之间的分层模型。\n福岛邦彦提出的新认知机引入了使用无监督学习训练的卷积神经网络。扬·勒丘恩将有监督的反向传播算法应用于这一架构。事实上，从反向传播算法自20世纪70年代提出以来，不少研究者都曾试图将其应用于训练有监督的深度神经网络，但最初的尝试大都失败。赛普·霍克赖特在其博士论文中将失败的原因归结为梯度消失，这一现象同时在深度前馈神经网络和循环神经网络中出现，后者的训练过程类似深度网络。在分层训练的过程中，本应用于修正模型参数的误差随着层数的增加指数递减，这导致了模型训练的效率低下。\n为了解决这一问题，研究者们提出了一些不同的方法。于尔根·施密德胡伯于1992年提出多层级网络，利用无监督学习训练深度神经网络的每一层，再使用反向传播算法进行调优。在这一模型中，神经网络中的每一层都代表观测变量的一种压缩表示，这一表示也被传递到下一层网络。\n另一种方法是赛普·霍克赖特和于尔根·施密德胡伯提出的長短期記憶神經網路（LSTM）。2009年，在ICDAR 2009举办的连笔手写识别竞赛中，在没有任何先验知识的情况下，深度多维长短期记忆神经网络取得了其中三场比赛的胜利。\n斯文·贝克提出了在训练时只依赖梯度符号的神经抽象金字塔模型，用以解决图像重建和人脸定位的问题。\n其他方法同样采用了无监督预训练来构建神经网络，用以发现有效的特征，此后再采用有监督的反向传播以区分有标签数据。杰弗里·辛顿等人于2006年提出的深度模型提出了使用多层隐变量学习高层表示的方法。这一方法使用斯摩棱斯基于1986年提出的受限玻尔兹曼机对每一个包含高层特征的层进行建模。模型保证了数据的对数似然下界随着层数的提升而递增。当足够多的层数被学习完毕，这一深层结构成为一个生成模型，可以通过自上而下的采样重构整个数据集。辛顿声称这一模型在高维结构化数据上能够有效地提取特征。\n吴恩达和杰夫·迪恩领导的谷歌大脑团队创建了一个仅通过YouTube视频学习高层概念（例如猫）的神经网络\n。\n其他方法依赖了现代电子计算机的强大计算能力，尤其是GPU。2010年，在于尔根·施密德胡伯位于瑞士人工智能实验室IDSIA的研究组中，丹·奇雷尚（Dan Ciresan）和他的同事展示了利用GPU直接执行反向传播算法而忽视梯度消失问题的存在。这一方法在扬·勒丘恩等人给出的手写识别MNIST数据集上战胜了已有的其他方法。\n截止2011年，前馈神经网络深度学习中最新的方法是交替使用卷积层（convolutional layers）和最大值池化层（max-pooling layers）并加入单纯的分类层作为顶端。训练过程也无需引入无监督的预训练。从2011年起，这一方法的GPU实现多次赢得了各类模式识别竞赛的胜利，包括IJCNN 2011交通标志识别竞赛和其他比赛。\n这些深度学习算法也是最先在某些识别任务上达到和人类表现具备同等竞争力的算法。\n\n深度学习结构\n通常将具有两层或两层以上隐藏层的神经网络叫做深度神经网络。与浅层神经网络类似，深度神经网络也能够为复杂非线性系统提供建模，但多出的层次为模型提供了更高的抽象层次，因而提高了模型的能力。深度神经网络通常都是前馈神经网络，但也有语言建模等方面的研究将其拓展到循环神经网络。卷积深度神经网络（Convolutional Neural Networks, CNN）在计算机视觉领域得到了成功的应用。此后，卷积神经网络也作为听觉模型被使用在自动语音识别领域，较以往的方法获得了更优的结果。\n\n深度神经网络\n深度神经网络（Deep Neural Networks, DNN）是一种判别模型，可以使用反向传播算法进行训练。权重更新可以使用下式进行随机梯度下降法求解：\n\n  \n    \n      \n        Δ\n        \n          w\n          \n            i\n            j\n          \n        \n        (\n        t\n        +\n        1\n        )\n        =\n        Δ\n        \n          w\n          \n            i\n            j\n          \n        \n        (\n        t\n        )\n        +\n        η\n        \n          \n            \n              ∂\n              C\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\Delta w_{ij}(t+1)=\\Delta w_{ij}(t)+\\eta {\\frac {\\partial C}{\\partial w_{ij}}}}\n  \n\n其中，\n  \n    \n      \n        η\n      \n    \n    {\\displaystyle \\eta }\n  \n为学习率，\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n为代价函数。这一函数的选择与学习的类型（例如监督学习、无监督学习、增强学习）以及激活函数相关。例如，为了在一个多分类问题上进行监督学习，通常的选择是使用ReLU作为激活函数，而使用交叉熵作为代价函数。Softmax函数定义为\n  \n    \n      \n        \n          p\n          \n            j\n          \n        \n        =\n        \n          \n            \n              exp\n              ⁡\n              (\n              \n                x\n                \n                  j\n                \n              \n              )\n            \n            \n              \n                ∑\n                \n                  k\n                \n              \n              exp\n              ⁡\n              (\n              \n                x\n                \n                  k\n                \n              \n              )\n            \n          \n        \n      \n    \n    {\\displaystyle p_{j}={\\frac {\\exp(x_{j})}{\\sum _{k}\\exp(x_{k})}}}\n  \n，其中\n  \n    \n      \n        \n          p\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle p_{j}}\n  \n代表类别\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n的概率，而\n  \n    \n      \n        \n          x\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle x_{j}}\n  \n和\n  \n    \n      \n        \n          x\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle x_{k}}\n  \n分别代表对单元\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n和\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n的输入。交叉熵定义为\n  \n    \n      \n        C\n        =\n        −\n        \n          ∑\n          \n            j\n          \n        \n        \n          d\n          \n            j\n          \n        \n        log\n        ⁡\n        (\n        \n          p\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle C=-\\sum _{j}d_{j}\\log(p_{j})}\n  \n，其中\n  \n    \n      \n        \n          d\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle d_{j}}\n  \n代表输出单元\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n的目标概率，\n  \n    \n      \n        \n          p\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle p_{j}}\n  \n代表应用了激活函数后对单元\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n的概率输出。\n\n深度神经网络的问题\n与其他神经网络模型类似，如果仅仅是简单地训练，深度神经网络可能会存在很多问题。常见的两类问题是过拟合和过长的运算时间。\n深度神经网络很容易产生过拟合现象，因为增加的抽象层使得模型能够对训练数据中较为罕见的依赖关系进行建模。对此，权重递减（\n  \n    \n      \n        \n          ℓ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\ell _{2}}\n  \n正规化）或者稀疏（\n  \n    \n      \n        \n          ℓ\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle \\ell _{1}}\n  \n-正规化）等方法可以利用在训练过程中以减小过拟合现象。另一种较晚用于深度神经网络训练的正规化方法是丢弃法（\"dropout\" regularization），即在训练中随机丢弃一部分隐层单元来避免对较为罕见的依赖进行建模。目前比較廣泛使用的是批归一化(Batch Normalization,BN) , 其本質上是在訓練過程加入噪音 , 從而讓模型得到更好的魯棒性 , 其特性令超深神經網路可以更好的訓練。\n反向传播算法和梯度下降法由于其实现简单，与其他方法相比能够收敛到更好的局部最优值而成为神经网络训练的通行方法。但是，这些方法的计算代价很高，尤其是在训练深度神经网络时，因为深度神经网络的规模（即层数和每层的节点数）、学习率、初始权重等众多参数都需要考虑。扫描所有参数由于时间代价的原因并不可行，因而小批量训练（mini-batching），即将多个训练样本组合进行训练而不是每次只使用一个样本进行训练，被用于加速模型训练。而最显著地速度提升来自GPU，因为矩阵和向量计算非常适合使用GPU实现。但使用大规模集群进行深度神经网络训练仍然存在困难，因而深度神经网络在训练并行化方面仍有提升的空间。\n\n深度置信网络\n深度置信网络（deep belief networks，DBN）是一种包含多层隐单元的概率生成模型，可被视为多层简单学习模型组合而成的複合模型。\n深度置信网络可以作为深度神经网络的预训练部分，并为网络提供初始权重，再使用反向传播或者其它判定算法作为调优的手段。这在训练数据较为缺乏时很有价值，因为不恰当的初始化权重会显著影响最终模型的性能，而预训练获得的权重在权值空间中比随机权重更接近最优的权重。这不仅提升了模型的性能，也加快了调优阶段的收敛速度。\n深度置信网络中的每一层都是典型的受限玻尔兹曼机（restricted Boltzmann machine，RBM），可以使用高效的无监督逐层训练方法进行训练。受限玻尔兹曼机是一种无向的基于能量的生成模型，包含一个输入层和一个隐层。图中对的边仅在输入层和隐层之间存在，而输入层节点内部和隐层节点内部则不存在边。单层RBM的训练方法最初由杰弗里·辛顿在训练“专家乘积”中提出，被称为对比分歧（contrast divergence, CD）。对比分歧提供了一种对最大似然的近似，被理想地用于学习受限玻尔兹曼机的权重。当单层RBM被训练完毕后，另一层RBM可被堆叠在已经训练完成的RBM上，形成一个多层模型。每次堆叠时，原有的多层网络输入层被初始化为训练样本，权重为先前训练得到的权重，该网络的输出作为新增RBM的输入，新的RBM重复先前的单层训练过程，整个过程可以持续进行，直到达到某个期望中的终止条件。\n尽管对比分歧对最大似然的近似十分粗略（对比分歧并不在任何函数的梯度方向上），但经验结果证实该方法是训练深度结构的一种有效的方法。\n\n卷积神经网络\n卷积神经网络（convolutional neural networks，CNN）由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和池化层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和语音识别方面能够给出更优的结果。这一模型也可以使用反向传播算法进行训练。相比较其他深度、前馈神经网络，卷积神经网络需要估计的参数更少，使之成为一种颇具吸引力的深度学习结构。\n\n卷积深度置信网络\n卷积深度置信网络（convolutional deep belief networks，CDBN）是深度学习领域较新的分支。在结构上，卷积深度置信网络与卷积神经网络在结构上相似。因此，与卷积神经网络类似，卷积深度置信网络也具备利用图像二维结构的能力，与此同时，卷积深度信念网络也拥有深度置信网络的预训练优势。卷积深度置信网络提供了一种能被用于信号和图像处理任务的通用结构，也能够使用类似深度置信网络的训练方法进行训练。\n\n结果\n语音识别\n下表中的结果展示了深度学习在通行的TIMIT数据集上的结果。TIMIT包含630人的语音数据，这些人持八种常见的美式英语口音，每人阅读10句话。这一数据在深度学习发展之初常被用于验证深度学习结构。TIMIT数据集较小，使得研究者可以在其上实验不同的模型配置。\n\n图像分类\n图像分类领域中一个公认的评判数据集是MNIST数据集。MNIST由手写阿拉伯数字组成，包含60,000个训练样本和10,000个测试样本。与TIMIT类似，它的数据规模较小，因而能够很容易地在不同的模型配置下测试。Yann LeCun的网站给出了多种方法得到的实验结果。截至2012年，最好的判别结果由Ciresan等人在当年给出，这一结果的错误率达到了0.23%。\n\n深度学习与神经科学\n计算机领域中的深度学习与20世纪90年代由认知神经科学研究者提出的大脑发育理论（尤其是皮层发育理论）密切相关。对这一理论最容易理解的是杰弗里·艾尔曼于1996年出版的专著《对天赋的再思考》（Rethinking Innateness）（参见斯拉格和约翰逊以及奎兹和赛杰诺维斯基的表述）。由于这些理论给出了实际的神经计算模型，因而它们是纯计算驱动的深度学习模型的技术先驱。这些理论指出，大脑中的神经元组成了不同的层次，这些层次相互连接，形成一个过滤体系。在这些层次中，每层神经元在其所处的环境中获取一部分信息，经过处理后向更深的层级传递。这与后来的单纯与计算相关的深度神经网络模型相似。这一过程的结果是一个与环境相协调的自组织的堆栈式的转换器。正如1995年在《纽约时报》上刊登的那样，“……婴儿的大脑似乎受到所谓‘营养因素’的影响而进行着自我组织……大脑的不同区域依次相连，不同层次的脑组织依照一定的先后顺序发育成熟，直至整个大脑发育成熟。”\n深度结构在人类认知演化和发展中的重要性也在认知神经学家的关注之中。发育时间的改变被认为是人类和其他灵长类动物之间智力发展差异的一个方面。在灵长类中，人类的大脑在出生后的很长时间都具备可塑性，但其他灵长类动物的大脑则在出生时就几乎完全定型。因而，人类在大脑发育最具可塑性的阶段能够接触到更加复杂的外部场景，这可能帮助人类的大脑进行调节以适应快速变化的环境，而不是像其他动物的大脑那样更多地受到遗传结构的限制。这样的发育时间差异也在大脑皮层的发育时间和大脑早期自组织中从刺激环境中获取信息的改变得到体现。当然，伴随着这一可塑性的是更长的儿童期，在此期间人需要依靠抚养者和社会群体的支持和训练。因而这一理论也揭示了人类演化中文化和意识共同进化的现象。\n\n公众视野中的深度学习\n深度学习常常被看作是通向真正人工智能的重要一步，因而许多机构对深度学习的实际应用抱有浓厚的兴趣。2013年12月，Facebook宣布雇用楊立昆为其新建的人工智能实验室的主管，这一实验室将在加州、伦敦和纽约设立分支机构，帮助Facebook研究利用深度学习算法进行类似自动标记照片中用户姓名这样的任务。\n2013年3月，杰弗里·辛顿和他的两位研究生亚历克斯·克里泽夫斯基和伊尔亚·苏茨克维谷歌公司雇用，以提升现有的机器学习产品并协助处理谷歌日益增长的数据。谷歌同时并购了辛顿创办的公司DNNresearch。\n2016年3月，以深度學習開發的圍棋程式AlphaGo首度在比賽中擊敗人類頂尖选手，形成廣泛的討論。\n\n批评\n对深度学习的主要批评是许多方法缺乏理论支撑。大多数深度结构仅仅是梯度下降的某些变式。尽管梯度下降法已经被充分地研究，但理论涉及的其他算法，例如对比分歧算法，并没有获得充分的研究，其收敛性等问题仍不明确。深度学习方法常常被视为黑盒，大多数的结论确认都由经验而非理论来确定。\n也有学者认为，深度学习应当被视为通向真正人工智能的一条途径，而不是一种包罗万象的解决方案。尽管深度学习的能力很强，但和真正的人工智能相比，仍然缺乏诸多重要的能力。理论心理学家加里·马库斯指出：\n\n就现实而言，深度学习只是建造智能机器这一更大挑战中的一部分。这些技术缺乏表达因果关系的手段……缺乏进行逻辑推理的方法，而且远没有具备集成抽象知识，例如物品属性、代表和典型用途的信息。最为强大的人工智能系统，例如IBM的人工智能系统沃森，仅仅把深度学习作为一个包含从贝叶斯推理和演绎推理等技术的复杂技术集合中的组成部分。\n\n深度学习库\nPyTorch\nTorch\nTensorFlow\nTheano\nPaddlePaddle\nDeeplearning4j\nCaffe\nroNNie\nKeras\nMXNet\n深度学习软件比较\n\n参见\n杰弗里·辛顿\n深度学习框架比较\n\n参考资料\n外部链接\n来自蒙特利尔大学的深度学习信息 [1] （页面存档备份，存于互联网档案馆）\n杰弗里·辛顿的主页 [2] （页面存档备份，存于互联网档案馆）\n深度学习视频教程 [3] （页面存档备份，存于互联网档案馆）\n燕乐存的主页 [4] （页面存档备份，存于互联网档案馆）\n麻省理工大学生物和计算学习中心 (CBCL) [5] （页面存档备份，存于互联网档案馆）\n斯坦福大学提供的无监督特征学习和深度学习教程 [6] （页面存档备份，存于互联网档案馆）\n谷歌DistBelief框架 [7] （页面存档备份，存于互联网档案馆）\nTheano深度学习工具包（使用Python） [8] （页面存档备份，存于互联网档案馆）\nDeeplearning4j开源深度学习工具包（使用Java） [9] （页面存档备份，存于互联网档案馆）\nNIPS 2013会议（介绍深度学习相关资料） [10] （页面存档备份，存于互联网档案馆）"}
{"title": "Adobe Firefly", "text": "《Adobe Firefly》是一種生成機器學習模型，作為Adobe Creative Cloud的一部分。目前正在進行公開測試階段。\nAdobe Firefly是基於Adobe的Sensei平台開發的。Firefly 利用來自知识共享、维基共享资源和Flickr Commons的圖像進行訓練，並結合Adobe Stock和公共領域內的3億張圖像和影片。它透過圖像數據集生成各種設計，並通過用戶反饋調整其設計。\nFirefly for Enterprise於2023年6月22日發布。\n\n發展歷史\nAdobe Firefly 首次在2022年9月的Adobe MAX會議上宣布，並於2023年3月作為公開測試版發布。目前，所有Adobe Creative Cloud訂閱用戶均可使用。Firefly 建立在 Adobe Sensei 之上，該平台也被用於Adobe Photoshop中的物體選取和Adobe Photoshop Lightroom中的圖像自動增強等功能。Firefly 的功能擴展到了Adobe Illustrator、Adobe Premiere Pro和Express，特別是在生成照片、影片和音頻方面，以增強或改變媒體的特定部分。\n\n合作夥伴及應用\nFirefly 一些模型由英伟达Picasso運行。Google原計劃在其AI圖像生成器 Bard（現為 Gemini）中使用 Firefly，但最終選擇了他們自己的Imagen模型。美泰兒、IBM和电通也與Adobe合作，展示了生成照片變體的能力。\n\n重要時間點\n2022年9月：在 Adobe MAX 會議上首次宣布\n2023年3月：作為公開測試版發布\n2023年6月：Firefly for Enterprise 發布\n\n\n== 參考資料 =="}
{"title": "神经网络", "text": "神经网络（neural network）是在动物、人类或计算机系统中形成神经系统结构的神经元互联群或神经元模拟，可能指：\n\n神经回路（neural circuit），是由生物的神经元、细胞、触点等组成的神经网络。\n动物神经网（nerve net），是一种径向对称的生物神经系统。\n人工神经网络（artificial neural network），是一种应用类似于大脑神经突触联接的结构进行信息处理的数学模型。在工程与学术界也常直接简称为“神经网络”或“类神经网络”。\n卷积神经网络（convolutional neural network），一种深度神经网络，常用于视觉图像分析。"}
{"title": "人工神经网络", "text": "人工神经网络（英語：artificial neural network，ANNs）又称类神经网络，简称神经网络（neural network，NNs），在机器学习和认知科学领域，是一种模仿生物神经网络（动物的中樞神經系統，特别是大脑）的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统，通俗地讲就是具备学习功能。现代神经网络是一种非线性统计性数据建模(概率模型)工具，神经网络通常是通过一个基于数学统计学类型的学习方法得以优化，所以也是数学统计学方法的一种实际应用，通过统计学的标准数学方法我们能够得到大量的可以用函数来表达的局部结构空间，另一方面在人工智能学的人工感知领域，我们通过数学统计学的应用可以来做人工感知方面的决定问题（也就是说通过统计学的方法，人工神经网络能够类似人一样具有简单的决定能力和简单的判断能力），这种方法比起正式的逻辑学推理演算更具有优势。\n和其他机器学习方法一样，神经网络已经被用于解决各种各样的问题，例如机器视觉和语音识别。这些问题都是很难被传统基于规则的编程所解决的。\n\n背景\n对人类中枢神经系统的观察启发了人工神经网络这个概念。在人工神经网络中，节点（node）是构成人工神经网络的数字化元素，是网络中任何的连接点；人工神经元（neuron）属于一种节点，特指人工神经网络中基本的计算或处理单元，连接在一起形成一个类似生物神经网络的网状结构。\n人工神经网络目前没有一个统一的正式定义。不过，具有下列特点的统计模型可以被称作是“神经化”的：\n\n具有一组可以被调节的权重（被学习算法调节的数值参数）\n可以估计输入数据的非线性函数关系\n这些可调节的权重可以被看做神经元之间的连接强度。\n人工神经网络与生物神经网络的相似之处在于，它可以集体地、并行地计算函数的各个部分，而不需要描述每一个单元的特定任务。神经网络这个词一般指统计学、认知心理学和人工智能领域使用的模型，而控制中央神经系统的神经网络属于计算神经科学。\n在神经网络的现代软件实现中，由生物学启发的方法已经有了很重大的延伸，現在主流的是基于统计学和信号处理的更加实用的方法。在一些软件系统中，神经网络或者神经网络的一部分（例如人工神经元）是大型系统中的一个部分。这些系统结合了适应性的和非适应性的元素。虽然这种系统使用的这种更加普遍的方法更适宜解决现实中的问题，但是这和传统的连接主义人工智能已经没有什么关联了。不过它们还有一些共同点：非线性、分布式、并行化，局部性计算以及适应性。从历史的角度讲，神经网络模型的应用标志着二十世纪八十年代后期从高度符号化的人工智能（以用条件规则表达知识的专家系统为代表）向低符号化的机器学习（以用动力系统的参数表达知识为代表）的转变。\n\n历史\n沃伦·麦卡洛克和沃尔特·皮茨（1943）基于数学和一种称为阈值逻辑的算法创造了一种神经网络的计算模型。这种模型使得神经网络的研究分裂为两种不同研究思路。一种主要关注大脑中的生物学过程，另一种主要关注神经网络在人工智能裡的应用。\n\n赫布型学习\n二十世纪40年代后期，心理学家唐纳德·赫布根据神经可塑性的机制创造了一种对学习的假说，现在称作赫布型学习。赫布型学习被认为是一种典型的非监督式学习规则，它后来的变种是长期增强作用的早期模型。从1948年开始，研究人员将这种计算模型的思想应用到B型图灵机上。\n法利和韦斯利·A·克拉克(Wesley Allison Clark )（1954）首次使用计算机，当时称作计算器，在MIT模拟了一个赫布网络。纳撒尼尔·罗切斯特（1956）等人模拟了一台 IBM 704计算机上的抽象神经网络的行为。\n弗兰克·罗森布拉特创造了感知机。这是一种模式识别算法，用简单的加减法实现了两层的计算机学习网络。罗森布拉特也用数学符号描述了基本感知机里没有的回路，例如异或回路。这种回路一直无法被神经网络处理，直到保罗·韦伯斯(1975)创造了反向传播算法。\n在马文·明斯基和西摩爾·派普特（1969）发表了一项关于机器学习的研究以后，神经网络的研究停滞不前。他们发现了神经网络的两个关键问题。第一是基本感知机无法处理异或回路。第二个重要的问题是电脑没有足够的能力来处理大型神经网络所需要的很长的计算时间。直到计算机具有更强的计算能力之前，神经网络的研究进展缓慢。\n\n反向传播算法与复兴\n后来出现的一个关键的进展是保罗·韦伯斯发明的反向传播算法（Werbos 1975）。这个算法有效地解决了异或的问题，还有更普遍的训练多层神经网络的问题。\n在二十世纪80年代中期，分布式并行处理（当时称作联结主义）流行起来。戴维·鲁姆哈特和詹姆斯·麦克里兰德的教材对于联结主义在计算机模拟神经活动中的应用提供了全面的论述。\n神经网络传统上被认为是大脑中的神经活动的简化模型，虽然这个模型和大脑的生理结构之间的关联存在争议。人们不清楚人工神经网络能多大程度地反映大脑的功能。\n支持向量机和其他更简单的方法（例如线性分类器）在机器学习领域的流行度逐渐超过了神经网络，但是在2000年代后期出现的深度学习重新激发了人们对神经网络的兴趣。\n\n2006年之后的进展\n人们用CMOS创造了用于生物物理模拟和神经形态计算的计算装置。最新的研究显示了用于大型主成分分析和卷积神经网络的纳米装置具有良好的前景。如果成功的话，这会创造出一种新的神经计算装置，因为它依赖于学习而不是编程，并且它从根本上就是模拟的而不是数字化的，虽然它的第一个实例可能是数字化的CMOS装置。\n在2009到2012年之间，于尔根·施密德胡伯在瑞士研究小组(Dalle Molle Institute for Artificial Intelligence)的研发的循环神经网络和深前馈神经网络赢得了8项关于模式识别和机器学习的国际比赛。例如，艾力克斯·格雷夫斯的双向、多维的LSTM赢得了2009年ICDAR的3项关于连笔字识别的比赛，而且之前并不知道关于将要学习的3种语言的信息。\nIDSIA的丹·奇尔桑 (Dan Ciresan)和同事根据这个方法编写的基于GPU的实现赢得了多项模式识别的比赛，包括IJCNN 2011交通标志识别比赛等等。他们的神经网络也是第一个在重要的基准测试中（例如IJCNN 2012交通标志识别和NYU的楊立昆的MNIST手写数字问题）能达到或超过人类水平的人工模式识别器。\n类似1980年福島邦彥(Kunihiko Fukushima )发明的neocognitron和视觉标准结构（由David H. Hubel和Torsten Wiesel在初级视皮层中发现的那些简单而又复杂的细胞启发）那样有深度的、高度非线性的神经结构可以被多伦多大学杰弗里·辛顿实验室的非监督式学习方法所训练。2012年，神經網路出現了快速的發展，主要原因在於計算技術的提高，使得很多複雜的運算變得成本低廉。以AlexNet為標誌，大量的深度網路開始出現。\n2014年出现了残差神经网络，该网络极大解放了神经网络的深度限制，出现了深度学习的概念。\n\n构成\n典型的人工神经网络具有以下三个部分：\n\n结构（Architecture）结构指定了网络中的变量和它们的拓扑关系。例如，神经网络中的变量可以是神经元连接的权重（weights）和神经元的激励值（activities of the neurons）。\n激励函数（Activation Rule）大部分神经网络模型具有一个短时间尺度的动力学规则，来定义神经元如何根据其他神经元的活动来改变自己的激励值。一般激励函数依赖于网络中的权重（即该网络的参数）。\n学习规则（Learning Rule）学习规则指定了网络中的权重如何随着时间推进而调整。这一般被看做是一种长时间尺度的动力学规则。一般情况下，学习规则依赖于神经元的激励值。它也可能依赖于监督者提供的目标值和当前权重的值。例如，用于手写识别的一个神经网络，有一组输入神经元。输入神经元会被输入图像的数据所激發。在激励值被加权并通过一个函数（由网络的设计者确定）后，这些神经元的激励值被传递到其他神经元。这个过程不断重复，直到输出神经元被激發。最后，输出神经元的激励值决定了识别出来的是哪个字母。\n\n神经元\n神经元示意图：\n\na1~an为输入向量的各个分量\nw1~wn为神经元各个突触的权重值(weight)\nb为偏置(bias)\nf为传递函数，通常为非线性函数。一般有traingd(),tansig(),hardlim()。以下默认为hardlim()\nt为神经元输出\n数学表示\n\n  \n    \n      \n        t\n        =\n        f\n        (\n        \n          \n            \n              \n                W\n                ′\n              \n              →\n            \n          \n        \n        \n          \n            \n              A\n              →\n            \n          \n        \n        +\n        b\n        )\n      \n    \n    {\\displaystyle t=f({\\vec {W'}}{\\vec {A}}+b)}\n  \n\n  \n    \n      \n        \n          \n            \n              W\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {W}}}\n  \n为权向量，\n  \n    \n      \n        \n          \n            \n              \n                W\n                ′\n              \n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {W'}}}\n  \n为\n  \n    \n      \n        \n          \n            \n              W\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {W}}}\n  \n的转置\n\n  \n    \n      \n        \n          \n            \n              A\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {A}}}\n  \n为输入向量\n\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n为偏置\n\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n为传递函数\n可见，一个神经元的功能是求得输入向量与权向量的内积后，经一个非线性传递函数得到一个标量结果。\n单个神经元的作用：把一个n维向量空间用一个超平面分割成两部分（称之为判断边界），给定一个输入向量，神经元可以判断出这个向量位于超平面的哪一边。\n该超平面的方程：\n  \n    \n      \n        \n          \n            \n              \n                W\n                ′\n              \n              →\n            \n          \n        \n        \n          \n            \n              p\n              →\n            \n          \n        \n        +\n        b\n        =\n        0\n      \n    \n    {\\displaystyle {\\vec {W'}}{\\vec {p}}+b=0}\n  \n \n\n  \n    \n      \n        \n          \n            \n              W\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {W}}}\n  \n权向量\n\n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n偏置\n\n  \n    \n      \n        \n          \n            \n              p\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {p}}}\n  \n超平面上的向量\n\n神经元网络\n单层神经元网络\n是最基本的神经元网络形式，由有限个神经元构成，所有神经元的输入向量都是同一个向量。由于每一个神经元都会产生一个标量结果，所以单层神经元的输出是一个向量，向量的维数等于神经元的数目。\n示意图：\n\n多层神经元网络\n人工神经网络的实用性\n人工神经网络是一个能够学习，能够总结归纳的系统，也就是说它能够通过已知数据的实验运用来学习和归纳总结。人工神经网络通过对局部情况的对照比较（而这些比较是基于不同情况下的自动学习和要实际解决问题的复杂性所决定的），它能够推理产生一个可以自动识别的系统。与之不同的基于符号系统下的学习方法，它们也具有推理功能，只是它们是建立在逻辑演算法的基础上，也就是说它们之所以能够推理，基础是需要有一个推理演算法则的集合。\n\n人工神经元网络模型\n通常来说，一个人工神经元网络是由一个多层神经元结构组成，每一层神经元拥有输入（它的输入是前一层神经元的输出）和输出，每一层（我们用符号记做）Layer(i)是由Ni(Ni代表在第i层上的N)个网络神经元组成，每个Ni上的网络神经元把对应在Ni-1上的神经元输出做为它的输入，我们把神经元和与之对应的神经元之间的连线用生物学的名称，叫做突触（英語：Synapse），在数学模型中每个突触有一个加权数值，我们称做权重，那么要计算第i层上的某个神经元所得到的势能等于每一个权重乘以第i-1层上对应的神经元的输出，然后全体求和得到了第i层上的某个神经元所得到的势能，然后势能数值通过该神经元上的激活函数（activation function，常是∑函数（英語：Sigmoid function）以控制輸出大小，因為其可微分且連續，方便差量规则（英語：Delta rule）處理。），求出该神经元的输出，注意的是该输出是一个非线性的数值，也就是说通过激励函数求的数值根据极限值来判断是否要激活该神经元，换句话说我们对一个神经元网络的输出是否线性不感兴趣。\n\n基本結構\n一种常见的多层结构的前馈网络（Multilayer Feedforward Network）由三部分組成，\n\n輸入層（Input layer），眾多神經元（Neuron）接受大量非線形輸入訊息。輸入的訊息稱為輸入向量。\n輸出層（Output layer），訊息在神經元鏈接中傳輸、分析、權衡，形成輸出結果。輸出的訊息稱為輸出向量。\n隱藏層（Hidden layer），簡稱「隱層」，是輸入層和輸出層之間眾多神經元和鏈接組成的各個層面。隱層可以有一层或多層。隱層的節點（神經元）數目不定，但數目越多神經網絡的非線性越顯著，從而神經網絡的強健性（控制系統在一定結構、大小等的參數攝動下，維持某些性能的特性）更顯著。習慣上會選輸入節點1.2至1.5倍的節點。\n这种网络一般称为感知器（对单隐藏层）或多层感知器（对多隐藏层），神经网络的类型已经演变出很多种，这种分层的结构也并不是对所有的神经网络都适用。\n\n學習過程\n通過訓練樣本的校正，對各個層的權重進行校正（learning）而建立模型的過程，稱為自動學習過程（training algorithm）。具体的学习方法则因网络结构和模型不同而不同，常用反向传播算法（Backpropagation/倒傳遞/逆傳播，以output利用一次微分Delta rule來修正weight）來驗證。\n\n種類\n人工神經網络分類為以下兩種：\n1.依學習策略（Algorithm）分類主要有：\n\n监督式学习网络（Supervised Learning Network）為主\n无监督式学习网络（Unsupervised Learning Network）\n混合式学习网络（Hybrid Learning Network）\n联想式学习网络（Associate Learning Network）\n最适化学习网络（Optimization Application Network）\n2.依網络架構（Connectionism）分類主要有：\n\n前馈神经网络（Feed Forward Network）\n循环神经网络（Recurrent Network）\n强化式架構（Reinforcement Network）\n\n理论性质\n计算能力\n多层感知器（Multilayer Perceptron，縮寫MLP）是一个通用的函数逼近器，由Cybenko定理证明。然而，证明不依赖特定的神经元数量或权重。Hava Siegelmann和Eduardo D. Sontag的工作证明了，一个具有有理数权重值的特定递归结构（与全精度实数权重值相对应）由有限个神经元和标准的线性关系构成的神经网络相当于一个通用图灵机。他们进一步表明，使用无理数权重值会产生一个超图灵机。\n\n容量\n人工神经网络模型有一个属性，称为“容量”，这大致相当于他们记住（而非正确分类）输入数据的能力。它与网络的参数、和结构有关。谷歌在研究中使用打乱标签的方法，来测试模型是否能记住所有的输出。虽然很明显，这样模型在测试集上的表现几乎是随机猜测，但是模型能够记住所有训练集的输入数据，即记住他们被打乱后的标签。而记住有限的样本的信息（Expressivity），需要的模型的参数（权重）数量存在下限。\n\n收敛性\n模型并不总是收敛到唯一解，因为它取决于一些因素。首先，函数可能存在许多局部极小值，这取决于成本函数和模型。其次，在远离局部最小值时，优化方法可能无法保证收敛。第三，对大量的数据或参数，一些方法变得不切实际。在一般情况下，我们发现，理论保证的收敛不能成为实际应用的一个可靠的指南。\n\n综合统计\n在目标是创建一个普遍系统的应用程序中，过度训练的问题出现了。这出现在回旋或过度具体的系统中当网络的容量大大超过所需的自由参数。为了避免这个问题，有两个方向：第一个是使用交叉验证和类似的技术来检查过度训练的存在和选择最佳参数如最小化泛化误差。二是使用某种形式的正规化。这是一个在概率化（贝叶斯）框架里出现的概念，其中的正则化可以通过为简单模型选择一个较大的先验概率模型进行；而且在统计学习理论中，其目的是最大限度地减少了两个数量：“风险”和“结构风险”，相当于误差在训练集和由于过度拟合造成的预测误差。\n\n参见\n機器學習\n深度學習\n邏輯斯諦迴歸\n線性迴歸\n感知机\n多层感知器\nER随机图\n人工智能\n\n参考文献\n外部連結\n神經網絡介紹 （页面存档备份，存于互联网档案馆）\nPerformance comparison of neural network algorithms tested on UCI data sets （页面存档备份，存于互联网档案馆）\nA close view to Artificial Neural Networks Algorithms （页面存档备份，存于互联网档案馆）\n开放目录项目中的“Neural Networks”\nA Brief Introduction to Neural Networks (D. Kriesel) - Illustrated, bilingual manuscript about artificial neural networks; Topics so far: Perceptrons, Backpropagation, Radial Basis Functions, Recurrent Neural Networks, Self Organizing Maps, Hopfield Networks.\nNeural Networks in Materials Science （页面存档备份，存于互联网档案馆）\nA practical tutorial on Neural Networks （页面存档备份，存于互联网档案馆）\nApplications of neural networks\nXOR實例 （页面存档备份，存于互联网档案馆）"}
{"title": "动物神经网", "text": "动物神经网简称神经网（nerve net），是一些具有辐射对称性的基群真后生动物身体中均匀分散的神经组织分布架构，例如刺胞动物（水母、水螅、海葵等）、有栉动物（栉水母）和棘皮动物（海星）。具有神经网的动物大概在六亿到五亿年前的埃迪卡拉纪和寒武纪早期出现，是生物圈最早发展出来的神经系统。\n\n演化\n真正的神经组织出现于多孔动物与刺胞动物和栉水母的最后共同祖先的分化之后, 研究多孔动物门的外群和现存的拥有神经网的动物可以帮助人们更好的理解神经网。\n多孔动物门(海绵)是在动物界中的现存门, 属于此门的物种没有神经系统。 虽然多孔动物并不具备可以进行神经肌肉传递的突触和肌原纤维, 但是他们分化出了神经系统的原型并且有着几种对于刺胞动物神经系统形成至关重要的同源基因。海绵细胞可以通过钙信号和其他方法来进行细胞信号传送。海绵幼虫分化出了感觉细胞, 这些细胞会对包括光,重力,和水流等等的刺激做出反应，这些都提高了它们的适应度。 除了感觉细胞会在发育过程中分化外，成年的海绵还可以进行收缩运动。\n神经系统的出现与电压门控型钠离子通道的演化过程息息相关，钠离子通道让细胞可以通过动作电位的传播来进行长距离的信号传送，而电压门控型钠离子通道能进行未调制过的细胞间信号传导。钠离子通道的起源至今还不明确，但是有假说认为钠离子通道从钙离子通道中分化出来的过程可能发生于神经系统出现的时候或者是在多细胞生物出现之前。多孔动物有钙离子却没有钠离子通道可能是因为刺胞动物和栉水母在与多孔动物分化后才演化出了钠离子通道，也有可能是因为多孔动物在演化过程中失去了编码钠离子通道的基因。\n神经网存在于刺胞动物门(例如钵水母纲，立方水母，和海葵)，栉水母和棘皮动物门的生物中。刺胞动物和栉水母都有着具有径向对称性的身体，统称为肠腔动物。肠腔动物分化于5亿7千万年前，早于寒武纪大爆发，他们是最早拥有着可以在发育时分化和通过突触传导来进行信号传送的神经系统的两门动物。绝大多数与神经网相关的神经组织进化研究都是用刺胞动物进行的。肠腔动物的神经系统允许他们进行感觉，收缩，运动和狩猎/进食行为。肠腔动物和两侧对称动物分享着共同的神经生理机制，因此，肠腔动物提供了可以用于追寻神经发生的起源的模型系统。这是因为神经发生最先出现于肠腔动物和两侧对称动物的共同祖先真后生动物中。 第二次神经发生出现于肠腔动物和两侧对称动物的分化之后。虽然拥有神经网的生物并没有真正的大脑，但是他们还是具备着进行复杂的移动和行为的能力。神经网的存在让生物具备了对环境做出反应的能力。\n\n结构\n神经网由相互连接的神经元组成，可与身体各部分相联系。它是一种松散的细胞网络，在某些生物体内可以聚集形成神经节，但不能形成大脑。在研究神经网方面，水螅是一类理想的可以进行研究和测试的刺胞动物。它们成为受欢迎的模式生物的原因包括：它们的神经网简单而方便观察，有很高的再生率，而且在实验中易于操作。\n有两类神经细胞存在于水螅的神经网中：神经节和感觉细胞。神经节细胞通常被发现在上皮细胞的底端附近，而感觉细胞通常在顶端方向从基底端的肌肉延伸。神经节的功能一般是为不同的神经结构之间提供中介连接，而感觉细胞的作用则是检测不同的刺激，例如光、声音、触摸或温度。\n神经网内有许多神经元集群，它们都有分布在一个固定的区域中。在水螅中，表皮感觉细胞的细胞体通常位于其附属肢体（口部的突起）的顶端，神经突的细胞体则通常位于其附属肢体的侧部，神经节细胞则位于附属肢体的基底区域（在触角之间和头部下方）。神经网包含可以调节神经活动的中间神经元，这种活动发生于感觉刺激和运动输出之间。\n\n种类\n弥散型，如水母。\n中心和周围型，如海星。\n\n能力\n可以通过使用神经网内的感觉神经元为动物提供感知物体的能力。\n\n运作\n当身体部分受刺激，这改变可从神经网传布，引起身体其他部分作出反应。\n\n\n== 参考文献 =="}
{"title": "卷积神经网络", "text": "卷积神经网络（英語：convolutional neural network，縮寫：CNN）是一种前馈神经网络，它的人工神经元可以响应一部分覆盖范围内的周围单元，对于大型图像处理有出色表现。\n卷积神经网络由一个或多个卷积层和顶端的全连通层（对应经典的神经网络）组成，同时也包括关联权重和池化层（pooling layer）。这一结构使得卷积神经网络能够利用输入数据的二维结构。与其他深度学习结构相比，卷积神经网络在图像和语音识别方面能够给出更好的结果。这一模型也可以使用反向传播算法进行训练。相比较其他深度、前馈神经网络，卷积神经网络需要考量的参数更少，使之成为一种颇具吸引力的深度学习结构。\n卷积神经网络的灵感来自于动物视觉皮层组织的神经连接方式。单个神经元只对有限区域内的刺激作出反应，不同神经元的感知区域相互重叠从而覆盖整个视野。\n\n定义\n卷积神经网络是人工神经网络的一种特殊类型，在其至少一层中使用称为卷积的数学运算代替通用矩阵乘法。它们专门设计用于处理像素数据，并用于图像识别和处理。\n卷积神经网络（CNN）技术规范\n数学定义\n给定输入X∈RH×W×C，卷积层通过滤波器W∈Rk×k×C×D执行如下操作：\nYi,j,d​=∑m=0k−1​∑n=0k−1​∑c=1C​Wm,n,c,d​⋅Xi+m,j+n,c​+bd​\n\n概览\n发展\nCNN是根据生物的视觉处理过程来进行设计的。\n\n发展历程补充\n大脑中视觉皮层接收视觉信号的过程\nDavid Hubel 和 Torsten Wiesel 在20世纪50年代到20世纪60年代的研究发现，猫和猴子的视觉皮层中包含着能分别对某一小块视觉区域进行回应的神经元。当眼睛不动的时候，在一定区域内的视觉刺激能使单个神经元兴奋，那这个区域就称为这个神经元的感受野。相邻的细胞具有相似且重叠的感受野。为了形成一张完整的视觉图像，整个视觉皮层上的神经元的感受野的大小和位置呈现系统性的变化。左脑和右脑分别对应其对侧的视野。\n他们在其1968年的一篇论文中确定了大脑中有两种不同的基本视觉细胞：\n\n简单细胞\n复杂细胞\nHubel和Wiesel还提出了这两种细胞用于模式识别任务的级联模型。\n\n结构\n卷积神经网络由输入层、隐藏层和输出层组成。\n\n卷積層\n卷積層可以产生一組平行的特徵圖（feature map），它通過在輸入圖像上滑動不同的卷積核並執行一定的運算而組成。此外，在每一個滑動的位置上，卷積核與輸入圖像之間會執行一個元素對應乘積並求和的運算以將感受野（receptive field）內的信息投影到特徵圖中的一個元素。這一滑動的過程可稱爲步幅 Z_s，步幅 Z_s 是控制輸出特徵圖尺寸的一個因素。卷積核的尺寸要比輸入圖像小得多，且重疊或平行地作用於輸入圖像中，一張特徵圖中的所有元素都是通過一個卷積核計算得出的，也即一張特徵圖共享了相同的權重和偏置項。\n\n線性整流層\n線性整流層（Rectified Linear Units layer, ReLU layer）使用線性整流（Rectified Linear Units, ReLU）\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        max\n        (\n        0\n        ,\n        x\n        )\n      \n    \n    {\\displaystyle f(x)=\\max(0,x)}\n  \n作为這一層神經的激勵函數（Activation function）。它可以增强判定函数和整个神经网络的非线性特性，而本身并不会改变卷积层。\n事实上，其他的一些函数也可以用于增强网络的非线性特性，如双曲正切函数 \n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        tanh\n        ⁡\n        (\n        x\n        )\n      \n    \n    {\\displaystyle f(x)=\\tanh(x)}\n  \n, \n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        \n          |\n        \n        tanh\n        ⁡\n        (\n        x\n        )\n        \n          |\n        \n      \n    \n    {\\displaystyle f(x)=|\\tanh(x)|}\n  \n，或者Sigmoid函数\n  \n    \n      \n        f\n        (\n        x\n        )\n        =\n        (\n        1\n        +\n        \n          e\n          \n            −\n            x\n          \n        \n        \n          )\n          \n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle f(x)=(1+e^{-x})^{-1}}\n  \n。相比其它函数来说，ReLU函数更受青睐，这是因为它可以将神经网络的训练速度提升数倍，而并不会对模型的泛化准确度造成显著影响。\n\n池化層\n池化（Pooling）是卷积神经网络中另一个重要的概念，它实际上是一种非线性形式的降采样。有多种不同形式的非线性池化函数，而其中“最大池化（Max pooling）”是最为常见的。它是将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。\n直觉上，这种机制能够有效地原因在于，一个特征的精确位置远不及它相对于其他特征的粗略位置重要。池化层会不断地减小数据的空间大小，因此参数的数量和计算量也会下降，这在一定程度上也控制了过拟合。通常来说，CNN的网络结构中的卷积层之间都会周期性地插入池化层。池化操作提供了另一种形式的平移不变性。因为卷积核是一种特征发现器，我们通过卷积层可以很容易地发现图像中的各种边缘。但是卷积层发现的特征往往过于精确，我们即使高速连拍拍摄一个物体，照片中的物体的边缘像素位置也不大可能完全一致，通过池化层我们可以降低卷积层对边缘的敏感性。\n池化层每次在一个池化窗口（depth slice）上计算输出，然后根据步幅移动池化窗口。下图是目前最常用的池化层，步幅为2，池化窗口为\n  \n    \n      \n        2\n        ×\n        2\n      \n    \n    {\\displaystyle 2\\times 2}\n  \n的二维最大池化层。每隔2个元素从图像划分出\n  \n    \n      \n        2\n        ×\n        2\n      \n    \n    {\\displaystyle 2\\times 2}\n  \n的区块，然后对每个区块中的4个数取最大值。这将会减少75%的数据量。\n\n  \n    \n      \n        \n          f\n          \n            X\n            ,\n            Y\n          \n        \n        (\n        S\n        )\n        =\n        \n          max\n          \n            a\n            ,\n            b\n            =\n            0\n          \n          \n            1\n          \n        \n        \n          S\n          \n            2\n            X\n            +\n            a\n            ,\n            2\n            Y\n            +\n            b\n          \n        \n        .\n      \n    \n    {\\displaystyle f_{X,Y}(S)=\\max _{a,b=0}^{1}S_{2X+a,2Y+b}.}\n  \n\n除了最大池化之外，池化层也可以使用其他池化函数，例如“平均池化”甚至“L2-范数池化”等。过去，平均池化的使用曾经较为广泛，但是最近由于最大池化在实践中的表现更好，平均池化已经不太常用。\n由于池化层过快地减少了数据的大小，目前文献中的趋势是使用较小的池化滤镜，甚至不再使用池化层。\nRoI池化(Region of Interest)是最大池化的变体，其中输出大小是固定的，输入矩形是一个参数。\n池化层是基于 Fast-RCNN 架构的卷积神经网络的一个重要组成部分。\n\n完全连接层\n最后，在经过几个卷积和最大池化层之后，神经网络中的高级推理通过完全连接层来完成。就和常规的非卷积人工神经网络中一样，完全连接层中的神经元与前一层中的所有激活都有联系。因此，它们的激活可以作为仿射变换来计算，也就是先乘以一个矩阵然后加上一个偏差(bias)偏移量(向量加上一个固定的或者学习来的偏差量)。\n\n应用\n影像辨識\n卷积神经网络通常在影像辨識系统中使用。\n\n視訊分析\n相比影像辨識问题，視訊分析要难许多。CNN也常被用于这类问题。\n\n自然语言处理\n卷积神经网络也常被用于自然语言处理。 CNN的模型被证明可以有效的处理各种自然语言处理的问题，如语义分析、搜索结果提取、句子建模 、分类、预测、和其他传统的NLP任务\n等。\n\n药物发现\n卷积神经网络已在药物发现中使用。卷积神经网络被用来预测的分子与蛋白质之间的相互作用，以此来寻找靶向位点，寻找出更可能安全和有效的潜在治疗方法。\n\n围棋\n卷积神经网络在计算机围棋领域也被使用。2016年3月，AlphaGo对战李世乭的比赛，展示了深度学习在围棋领域的重大突破。\n\n微调（fine-tuning）\n卷积神经网络（例如Alexnet、VGG网络）在网络的最后通常为softmax分类器。微调一般用来调整softmax分类器的分类数。例如原网络可以分类出2种图像，需要增加1个新的分类从而使网络可以分类出3种图像。微调（fine-tuning）可以留用之前训练的大多数参数，从而达到快速训练收敛的效果。例如保留各个卷积层，只重构卷积层后的全连接层与softmax层即可。\n\n經典模型\nLeNet\nAlexNet\nVGG\nGoogLeNet\nResNet\nDenseNet\n\n可用包\nroNNie: 是一個簡易入門級框架,使用Tensorflow 計算層.可於python下載 pip3 ronnie\nCaffe: Caffe包含了CNN使用最广泛的库。它由伯克利视觉和学习中心（BVLC）研发，拥有比一般实现更好的结构和更快的速度。同时支持CPU和GPU计算，底层由C++实现，并封装了Python和MATLAB的接口。\nTorch7（www.torch.ch）\nOverFeat\nCuda-convnet\nMatConvnet\nTheano：用Python实现的神经网络包\nTensorFlow\nPaddlepaddle(www.paddlepaddle.org （页面存档备份，存于互联网档案馆）)\nKeras\nPyTorch\n\n\n== 参考 =="}
{"title": "循环神经网络", "text": "循环神经网络（Recurrent neural network：RNN）是神經網絡的一種。\n数学形式化定义\nht​=σ(Wh​xt​+Uh​ht−1​+bh​)\n其中Wh, Uh​为权重矩阵，σ通常为tanh函数\n单纯的RNN因为无法处理随着递归，权重指数级爆炸或梯度消失问题，难以捕捉长期时间关联；而结合不同的LSTM可以很好解决这个问题。\n定理：当最大奇异值ρ(∇ht​)>1时梯度爆炸，ρ(∇ht​)<1时梯度消失\n时间循环神经网络可以描述动态时间行为，因为和前馈神经网络（feedforward neural network）接受较特定结构的输入不同，RNN将状态在自身网络中循环传递，因此可以接受更广泛的时间序列结构输入。手写识别是最早成功利用RNN的研究结果。\n\n历史\n循环神经网络是基于大卫·鲁梅尔哈特1986年的工作。1982年，约翰·霍普菲尔德发现了Hopfield神经网络——一种特殊的RNN。1993年，一个神经历史压缩器系统解决了一个“非常深度学习”的任务，这个任务在RNN展开之后有1000多个后续层。\n\nLSTM\nHochreiter和Schmidhuber于1997年提出了长短期记忆(LSTM)网络，并在多个应用领域创造了精确度记录。\n大约在2007年，LSTM开始革新语音识别领域，在某些语音应用中胜过传统模型。2009年，一个由 CTC 训练的LSTM网络赢得了多项连笔手写识别竞赛，成为第一个赢得模式识别竞赛的RNN。2014年，百度在不使用任何传统语音处理方法的情况下，使用经过CTC训练的RNNs打破了Switchboard Hub5'00 语音识别基准。\nLSTM还改进了大词汇量语音识别和文本到语音合成并在谷歌安卓系统中使用。据报道，2015年，谷歌语音识别通过接受过CTC训练的LSTM(谷歌语音搜索使用的)实现了49%的引用量的大幅提升。\nLSTM打破了改进机器翻译、语言建模和多语言处理的记录。 LSTM 结合卷积神经网络改进了图像自动标注 。\n\n循环神经网络\n编码器\n循环神经网络将输入序列\n  \n    \n      \n        \n          \n            \n              x\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {x}}}\n  \n编码为一个固定长度的隐藏状态\n  \n    \n      \n        \n          \n            \n              h\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {h}}}\n  \n，这里有（用自然语言处理作为例子）：\nc=∑t=1T​αt​ht\n其中αt​为注意力权重\n\n  \n    \n      \n        \n          \n            \n              x\n              →\n            \n          \n        \n        =\n        (\n        \n          x\n          \n            t\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          x\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\vec {x}}=(x_{t},...,x_{1})}\n  \n 是输入序列，比如编码为数字的一系列词语，整个序列就是完整的句子。\n\n  \n    \n      \n        \n          \n            \n              \n                h\n                \n                  t\n                \n              \n              →\n            \n          \n        \n        =\n        f\n        (\n        \n          x\n          \n            t\n          \n        \n        ,\n        \n          \n            \n              \n                h\n                \n                  t\n                  −\n                  1\n                \n              \n              →\n            \n          \n        \n        )\n      \n    \n    {\\displaystyle {\\vec {h_{t}}}=f(x_{t},{\\vec {h_{t-1}}})}\n  \n是随时间更新的隐藏状态。当新的词语输入到方程中，之前的状态\n  \n    \n      \n        \n          \n            \n              \n                h\n                \n                  t\n                  −\n                  1\n                \n              \n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {h_{t-1}}}}\n  \n就转换为和当前输入\n  \n    \n      \n        \n          x\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle x_{t}}\n  \n相关的\n  \n    \n      \n        \n          \n            \n              \n                h\n                \n                  t\n                \n              \n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {h_{t}}}}\n  \n，距离当前时间越长，越早输入的序列，在更新后的状态中所占权重越小，从而表现出时间相关性。\n其中，计算隐藏状态的方程\n  \n    \n      \n        f\n        (\n        x\n        ,\n        h\n        )\n      \n    \n    {\\displaystyle f(x,h)}\n  \n是一个非线性方程，可以是简单的Logistic方程（tanh），也可以是复杂的LSTM单元（Long Short-Term Memory）。  而有了隐藏状态序列，就可以对下一个出现的词语进行预测：\n\n  \n    \n      \n        p\n        (\n        \n          y\n          \n            t\n          \n        \n        )\n        =\n        p\n        (\n        \n          y\n          \n            t\n          \n        \n        \n        \n          |\n        \n        \n        \n          y\n          \n            t\n            −\n            1\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          y\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle p(y_{t})=p(y_{t}\\,|\\,y_{t-1},...,y_{1})}\n  \n，其中\n  \n    \n      \n        \n          y\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle y_{t}}\n  \n是第t个位置上的输出，它的概率基于之前输出的所有词语。\n以上概率可以通过隐藏状态来计算：\n  \n    \n      \n        p\n        (\n        \n          y\n          \n            t\n          \n        \n        )\n        =\n        g\n        (\n        \n          y\n          \n            t\n            −\n            1\n          \n        \n        ,\n        \n          \n            \n              \n                h\n                \n                  t\n                \n              \n              →\n            \n          \n        \n        ,\n        \n          \n            \n              c\n              →\n            \n          \n        \n        )\n      \n    \n    {\\displaystyle p(y_{t})=g(y_{t-1},{\\vec {h_{t}}},{\\vec {c}})}\n  \n，\n  \n    \n      \n        \n          \n            \n              c\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {c}}}\n  \n是所有隐藏状态的编码，总含了所有隐藏状态，比如可以是简单的最终隐藏状态\n  \n    \n      \n        \n          \n            \n              \n                h\n                \n                  t\n                \n              \n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {h_{t}}}}\n  \n，也可以是非线性方程的输出\n  \n    \n      \n        f\n        (\n        \n          h\n          \n            t\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          h\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle f(h_{t},...,h_{1})}\n  \n。因为隐藏状态t就编码了第t个输入前全部的输入信息，\n  \n    \n      \n        \n          y\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle y_{t}}\n  \n也迭代式地隐含了之前的全部输出信息，所以这个概率计算方法是合理的。\n这里的非线性方程\n  \n    \n      \n        g\n        (\n        y\n        ,\n        h\n        ,\n        c\n        )\n      \n    \n    {\\displaystyle g(y,h,c)}\n  \n可以是一个复杂的前馈神经网络，也可以是简单的非线性方程（但有可能因此无法适应复杂的条件而得不到任何有用结果）。给出的概率可以用监督学习的方法优化内部参数来给出翻译，也可以训练后用来给可能的备选词语，用计算其第j个备选词\n  \n    \n      \n        \n          y\n          \n            t\n            ,\n            j\n          \n        \n      \n    \n    {\\displaystyle y_{t,j}}\n  \n出现在下一位置的概率，给它们排序。排序后用于其它翻译系统，可以提升翻译质量。\n\n解码器\n更复杂的情况下循环神经网络还可以结合编码器作为解码器（Decoder），用于将编码后（Encoded）的信息解码为人类可识别的信息。也就是上述例子中的\n  \n    \n      \n        \n          y\n          \n            t\n          \n        \n        =\n        f\n        (\n        \n          y\n          \n            t\n            −\n            1\n          \n        \n        ,\n        \n          h\n          \n            t\n          \n        \n        ,\n        c\n        )\n      \n    \n    {\\displaystyle y_{t}=f(y_{t-1},h_{t},c)}\n  \n过程，当中非线性模型\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n就是作为输出的循环神经网络。只是在解码过程中，隐藏状态因为是解码器的参数，所以为了发挥时间序列的特性，需要对\n  \n    \n      \n        \n          h\n          \n            t\n          \n          ′\n        \n      \n    \n    {\\displaystyle h_{t}'}\n  \n继续进行迭代：\n\n  \n    \n      \n        \n          h\n          \n            t\n          \n          ′\n        \n        =\n        g\n        (\n        \n          h\n          \n            t\n            −\n            1\n          \n        \n        ,\n        \n          y\n          \n            t\n            −\n            1\n          \n        \n        ,\n        c\n        )\n      \n    \n    {\\displaystyle h_{t}'=g(h_{t-1},y_{t-1},c)}\n  \n，\n  \n    \n      \n        \n          \n            \n              c\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {c}}}\n  \n是解码器传递给编码器的参数，是解码器中状态的summary。\n  \n    \n      \n        \n          h\n          \n            t\n          \n          ′\n        \n      \n    \n    {\\displaystyle h_{t}'}\n  \n是解码器的隐藏状态。\n  \n    \n      \n        \n          y\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle y_{t}}\n  \n是第t个输出。\n当输入仍为\n  \n    \n      \n        \n          \n            \n              x\n              →\n            \n          \n        \n        =\n        (\n        \n          x\n          \n            t\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          x\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\vec {x}}=(x_{t},...,x_{1})}\n  \n，输出是\n  \n    \n      \n        \n          \n            \n              y\n              →\n            \n          \n        \n        =\n        (\n        \n          y\n          \n            t\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          y\n          \n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\vec {y}}=(y_{t},...,y_{1})}\n  \n，最大化条件概率\n  \n    \n      \n        P\n        (\n        \n          \n            \n              y\n              →\n            \n          \n        \n        \n        \n          |\n        \n        \n        \n          \n            \n              x\n              →\n            \n          \n        \n        )\n      \n    \n    {\\displaystyle P({\\vec {y}}\\,|\\,{\\vec {x}})}\n  \n后就是最好的翻译结果。\n\n双向读取\n用两个循环神经网络双向读取一个序列可以使人工智能获得“注意力”。简单的做法是将一个句子分别从两个方向编码为两个隐藏状态，然后将两个\n  \n    \n      \n        \n          \n            \n              h\n              →\n            \n          \n        \n      \n    \n    {\\displaystyle {\\vec {h}}}\n  \n拼接在一起作为隐藏状态。 这种方法能提高模型表现的原因之一可能是因为不同方向的读取在输入和输出之间创造了更多短期依赖关系，从而被RNN中的LSTM单元（及其变体）捕捉，例如在实验中发现颠倒输入序列的顺序（但不改变输出的顺序）可以意外达到提高表现的效果。\n\n架构\nRNN 有很多不同的变种\n\n完全循环\n基本的 RNN 是由人工神经元组织成的连续的层的网络。给定层中的每个节点都通过有向(单向)连接连接到下一个连续层中的每个其他节点。每个节点(神经元)都有一个时变的实值激活。每个连接(突触)都有一个可修改的实值权重。节点要么是输入节点(从网络外部接收数据)，要么是输出节点(产生结果)，要么是隐藏节点(在从输入到输出的过程中修改数据)。\n对于离散时间设置中的监督学习，实值输入向量序列到达输入节点，一次一个向量。在任何给定的时间步长，每个非输入单元将其当前激活(结果)计算为与其连接的所有单元的激活的加权和的非线性函数。可以在特定的时间步长为某些输出单元提供主管给定的目标激活。例如，如果输入序列是对应于口语数字的语音信号，则在序列末尾的最终目标输出可以是对该数字进行分类的标签。\n在强化学习环境中，没有教师提供目标信号。相反，适应度函数或奖励函数偶尔用于评估RNN的性能，它通过影响输出单元来影响其输入流，输出单元和一个可以影响环境的执行器相连。这可以被用来玩一个游戏，在这个游戏中，进度是用赢得的点数来衡量的。\n每个序列产生一个误差，作为所有目标信号与网络计算的相应激活的偏差之和。对于大量序列的训练集，总误差是所有单个序列误差的总和。\n\nElman 网络和 Jordan 网络\nElman网络是一个三层网络(在图中水平排列为x、y和z)，添加了一组上下文单元(在图中为u)。中间(隐藏)层连接到这些权重为1的上下文单元。在每个时间步，输入被向前反馈，并且学习规则被应用。固定的反向连接在上下文单元中保存隐藏单元的先前值的副本(因为它们在应用学习规则之前在连接上传播)。因此，网络可以保持某种状态，允许它执行诸如序列预测之类的任务，这些任务超出了标准多层感知器的能力。\nJordan网络类似于Elman网络。上下文单元是从输出层而不是隐藏层馈送的。Jordan网络中的上下文单元也称为状态层。他们与自己有着经常性的联系。\nElman和Jordan网络也被称为“简单循环网络”。\n\nElman 网络\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  h\n                  \n                    t\n                  \n                \n              \n              \n                \n                =\n                \n                  σ\n                  \n                    h\n                  \n                \n                (\n                \n                  W\n                  \n                    h\n                  \n                \n                \n                  x\n                  \n                    t\n                  \n                \n                +\n                \n                  U\n                  \n                    h\n                  \n                \n                \n                  h\n                  \n                    t\n                    −\n                    1\n                  \n                \n                +\n                \n                  b\n                  \n                    h\n                  \n                \n                )\n              \n            \n            \n              \n                \n                  y\n                  \n                    t\n                  \n                \n              \n              \n                \n                =\n                \n                  σ\n                  \n                    y\n                  \n                \n                (\n                \n                  W\n                  \n                    y\n                  \n                \n                \n                  h\n                  \n                    t\n                  \n                \n                +\n                \n                  b\n                  \n                    y\n                  \n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}h_{t}&=\\sigma _{h}(W_{h}x_{t}+U_{h}h_{t-1}+b_{h})\\\\y_{t}&=\\sigma _{y}(W_{y}h_{t}+b_{y})\\end{aligned}}}\n  \n\nJordan 网络\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  h\n                  \n                    t\n                  \n                \n              \n              \n                \n                =\n                \n                  σ\n                  \n                    h\n                  \n                \n                (\n                \n                  W\n                  \n                    h\n                  \n                \n                \n                  x\n                  \n                    t\n                  \n                \n                +\n                \n                  U\n                  \n                    h\n                  \n                \n                \n                  y\n                  \n                    t\n                    −\n                    1\n                  \n                \n                +\n                \n                  b\n                  \n                    h\n                  \n                \n                )\n              \n            \n            \n              \n                \n                  y\n                  \n                    t\n                  \n                \n              \n              \n                \n                =\n                \n                  σ\n                  \n                    y\n                  \n                \n                (\n                \n                  W\n                  \n                    y\n                  \n                \n                \n                  h\n                  \n                    t\n                  \n                \n                +\n                \n                  b\n                  \n                    y\n                  \n                \n                )\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}h_{t}&=\\sigma _{h}(W_{h}x_{t}+U_{h}y_{t-1}+b_{h})\\\\y_{t}&=\\sigma _{y}(W_{y}h_{t}+b_{y})\\end{aligned}}}\n  \n\n变量和函数\n\n  \n    \n      \n        \n          x\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle x_{t}}\n  \n: 输入向量\n\n  \n    \n      \n        \n          h\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle h_{t}}\n  \n: 隐藏层向量\n\n  \n    \n      \n        \n          y\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle y_{t}}\n  \n: 输出向量\n\n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n, \n  \n    \n      \n        U\n      \n    \n    {\\displaystyle U}\n  \n 和 \n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n: 参数矩阵和参数向量\n\n  \n    \n      \n        \n          σ\n          \n            h\n          \n        \n      \n    \n    {\\displaystyle \\sigma _{h}}\n  \n 和 \n  \n    \n      \n        \n          σ\n          \n            y\n          \n        \n      \n    \n    {\\displaystyle \\sigma _{y}}\n  \n: 激活函数\n\n双向循环神经网络\n双向循环神经网络（Bi-directional RNN，BRNN）基于元素的前向和后向的上下文，使用有限序列来预测或标记序列的每个元素。该方法是通过连接两个 RNN 的输出来完成的：一个从左到右处理序列，另一个从右到左处理序列。BRNN的输出是对目标信号的预测。该技术已被证明在与 LSTM RNN 结合使用时特别有用。\n\n参考\n外部連結\nA Critical Review of Recurrent Neural Networks for Sequence Learning （页面存档备份，存于互联网档案馆）"}
{"title": "Android", "text": "Android（[ˈænˌdrɔɪd]），是一個基於Linux核心与其他开源软件的開放原始碼的行動作業系統，由Google成立的開放手機聯盟持續領導與開發。中文常用非官方音译為「安卓系統」，也有报道引述曾注册过“安致”可能作为其中文商标。\n该操作系统的核心为Android开源项目（英語：Android Open Source Project），简称“AOSP”, 是根据Apache许可证授权的免费开源软件。然而，大多数设备使用谷歌开发的专有Android版本，预装谷歌移动服务等专有软件；虽然AOSP是免费的，但“Android”名称和徽标是谷歌的商标，谷歌可以限制未经认证的设备不得使用Android品牌和谷歌的专有版本。\nAndroid Inc.於2003年10月由安迪·鲁賓、利奇·米納爾、尼克·席爾斯、克里斯·懷特在加州帕羅奧圖創建。Android最初由安迪·鲁賓等人開發製作，最初開發這個系統的早期方向是創建一個數位相機的先進作業系統，但是後來發現相機市場規模不足實現其目標，轉而開發智慧型手機系統，於是Android成為一款面向智慧型手機的作業系統。於2005年7月11日Android Inc.被美國科技企業Google收購。\n2007年11月，Google與84家硬體製造商、軟體開發商及電信營運商成立開放手機聯盟來共同研發Android，隨後，Google以Apache免費開放原始碼許可證的授權方式，發佈了Android的原始碼，開放原始碼加速了Android普及，讓生產商推出搭載Android的智慧型手機，Android後來更逐漸拓展到平板電腦及其他領域上。\n2010年末數據顯示，僅正式推出兩年的Android作業系統在市場佔有率上已經超越稱霸逾十年的諾基亞Symbian系統，成為全球第一大智慧型手機作業系統。在2014年Google I/O開發者大會上Google宣佈過去30天裡有10億台活躍的Android設備。\n2014年第二季度，Android在全球智能手机出货市场的份额达到84.7%，创下了新纪录。到2016年第三季度，这一份额已增长至87.5%，而主要竞争对手iOS的市场份额则为12.1%。2015年9月，Google宣布Android每月有14亿活跃用户。到2017年5月，这一数字增至20亿活跃用户。2017年3月，Android全球網路流量和設備超越Microsoft Windows，正式成為全球第一大作業系統。截至2023年2月，根據StatCounter統計，除了美國、英國、加拿大、巴哈马、冰岛、挪威、瑞典、丹麥、瑞士、科索沃、日本、台灣和澳大利亞外，在其他所有國家和地區Android都是最被廣泛使用的智慧型手機作業系統。\n\n歷史\n成立\n2003年10月，有「Android之父」之稱的安迪·鲁賓、利奇·米纳尔、尼克·席爾斯、克里斯·懷特在美國加利福尼亞州帕羅奧圖共同成立了Android科技公司（英文：Android Inc.），鲁賓把Android項目描述為「有極大的潛能以開發更智能的行動設備，以更了解其用户的位置及偏好。」該公司早期的方向是為数码相机開發先進的作業系統，此亦是2004年4月該公司向投資者介紹的基礎。儘管Android科技公司的創始人和員工過去都具有各自的科技成就，但是Android科技公司的經營只顯露出它在智慧型手機軟體的方面，該公司隨後認為相機市場不足以實現其目標，並且在5個月之後努力把Android轉移到一款可跟Symbian及微軟Windows Mobile互相媲美的手機作業系統。\n在Android科技公司成立初期，鲁賓在吸引投資者方面遇到困難，他也為公司花光所有錢，使公司面臨著被驅逐的景況。就在此時，鲁賓的一位密友，史蒂夫·帕爾曼（Steve Perlman）給他一個裡面裝有1萬美元現金的信封，此後不久，此筆未披露的金額被視為種子資金。然而帕爾曼拒絕鲁賓所給他的股份，因他並非是以投資的方式給鲁賓這筆錢，他表示：「我這樣做是因為我相信這件事，並且我想幫安迪。」\n\nGoogle的收購及發展\n2005年7月11日，Google以高於$5,000萬美元的價錢收購了Android科技公司，使其成為Google旗下的一部分。Android的關鍵人物包括安迪·鲁賓、利奇·米納爾和克里斯·懷特，以及所有Android科技公司的員工都一併加入Google，作為收購的一部分。當時並沒有人知道Google為何會作出這項收購，引來許多的猜測，後來證實Google正是借助該次收購正式進入行動領域。根据前Google CEO施密特的说法，收購Android目的是抗衡微軟，試圖阻止微軟在移動市場複製桌面市場的成功。在Google，由鲁賓領導的團隊開發了一個基於Linux核心驅動的行動作業系統的平台，該開發項目便是Android作業系統。Google向手機製造商及手機網絡供應商推出該平台，承諾提供一個靈活可靠並可升級的系統，為Android提供一個廣闊的市場。Google組織了一系列硬件及軟件的合作夥伴，並向運營商示意指公司開放到各種程度的合作。\n2006年9月，Google提交了多項行動領域的專利申請。但並沒有人知道，Google將會推出的是名為Android的智慧型手機作業系統。更多的猜測是，Google會推出自有品牌智慧型手機系列。\n2006年9月，數碼雜誌《Information Week》報導了一項Evalueserve的研究報告，指Google已在行動電話領域上提交了多份專利申請。\n2006年12月，《華爾街日報》和英國廣播公司（BBC）報導了Google有機會進入流動領域的傳聞，Google有可能推廣行動領域下的各種Google服務，並且將推出一款名為Google電話的自有品牌智慧型手機。另有傳聞指出，按照Google的作風，將有可能呈現出新的智慧型手機製造商和運營商模式。傳聞指其早期原型跟BlackBerry手機非常相似，沒有觸控螢幕和物理QWERTY鍵盤，但這其實也是針對微軟而做的，因為當時的Windows Mobile手機有很多都是這樣的設計。然而2007年蘋果公司推出iPhone，這令Android創始人安迪·魯賓對原型機大為不滿，意味著Android系統的設計「不得不回到草稿重新來過」。Google後來修改了Android系統的規範文檔，指出「支援觸控螢幕」，雖然「產品的設計是以離散物理按鈕作為假設，因此觸控螢幕不能完全取代物理按鈕」。\n\n2007年11月5日，在Google的領導下，成立了開放手機聯盟（Open Handset Alliance），那是包括Google在內的科技公司聯盟，其他成員包括HTC、摩托羅拉、Samsung等設備製造商，無線運營商則包括Sprint及T-Mobile，晶片製造商高通及德州儀器，目標是為行動裝置開發「首個真正開放和全面的行動設備平台」。隨後，其他廠商加入，包括Broadcom、Intel、LG、Marvell等。聯盟開放手持裝置聯盟的建立目的是為了創建一個更加開放自由的行動電話環境。而在開放手持裝置聯盟創建的同一日，聯盟對外展示了他們的第一個產品：一部搭載了以Linux 2.6為核心基礎的Android作業系統的智慧型手機。該年內，開放手機聯盟正面對著另外兩個其他的開源碼的競爭對手，包括Symbian基金會和LiMo基金會，LiMo基金會開發了一個基於Linux的行動作業系統LiMo。\n2008年12月9日，新一批成員加入開放手持裝置聯盟，包括ARM、華為、索尼等公司。\n自2008年以來，Android已有許多更新以逐步改進其作業系統，並增加了新功能及修復了以前版本的錯誤。每個主要版本的名稱都以甜品或含糖的小食並按字母順序來命名，最初的幾個Android版本按此順序稱為「紙杯蛋糕（Cupcake）」、「甜甜圈（Donut）」、「閃電泡芙（Eclair）」和「霜凍優格（Froyo）」。\n為了跟iPhone 3G能互相媲美，諾基亞和黑莓手機於2008年均宣布有關觸控螢幕的智能手機的資訊，Android的焦點最終也轉向觸控螢幕。第一款運行Android系統的商用智能手機是HTC Dream，亦名為T-Mobile G1，該智能手機於2008年9月23日發布。\n同時，一個負責持續發展Android作業系統的開源代碼專案成立了AOSP（Android Open Source Project）。除了開放手持裝置聯盟之外，Android還擁有全球各地開發人員組成的開源社群來專門負責開發Android應用程式和第三方Android作業系統來延長和擴展Android的功能和性能。\n隨著2013年Android發布新版本奇巧巧克力，Google解釋「由於這些設備使我們的生活如此甜蜜，每個Android版本都以甜品來命名」，雖然Google的發言人在接受CNN訪談時指：「這有點像內部團隊的事情，我們更願意做多一點—我該怎樣說呢—我會說在這個問題上有點難以捉摸的。」\n2010年，Google推出了Nexus系列的裝置，他們與不同的合作設備製造商一起生產新設備並推出新的Android版本。該系列被形容為「透過引入新軟件迭代和硬件標準使其在Android的歷史中發揮了關鍵作用，並成為不會因“歷代的更新”導致軟件膨脹而聞名」。在2013年5月的Google開發者大會上，他們宣佈了Samsung Galaxy S4的特別版，特別版在於它搭載了原生Android，並承諾能快速接收新的系統更新。裝置將成為「Google Play Edition」的開始，其他設備也會隨之而來，包括HTC One (M7)以及Moto G。2015年，Google Play Edition版步入了历史。\n從2008至2013年，雨果·巴拉擔任Android產品發言人，參與Google年度開發人員會議的Google開發者大會。他於2013年8月離開Google，並隨即加入中國手機製造商小米。在他離任不足六個月前，Google時任CEO賴利·佩吉在一篇博客文章中宣佈，鲁賓從Android部門轉移到Google的新項目，而桑德爾·皮蔡將會成為Android的新主管。皮蔡本人最終轉換了職位，隨著Google重組大型聯合的Alphabet集團，他在2015年8月成為了Google的新任CEO，讓浩史·洛克海默成為Android的新任負責人。\n2014年6月，Google發布了Android One，那是一組「硬件參考模型」，這將容許（設備製造商）以低成本輕鬆打造高品質手機。同年9月，Google宣布推出首款在印度發布的Android One手機。然而科技網站《Recode》在2015年6月報導該項目「令人失望」，引用指「消費者和製造夥伴不情願」及「搜索公司不奏效因從未破解硬件」。Google計劃於2015年8月重推Android One，一周之後，該公司宣布非洲成為該計劃的下一個地點。2017年1月，《資訊（The Information）》報導稱Google正在將其低成本的Android One計劃擴展至美國，儘管《邊緣（The Verge）》指該公司可能不會生產實體的設備。\n2016年10月，Google發布智能手機Pixel，作為Google推出的第一款手機，並且在更廣泛推出之前，專門展示某些軟件功能，例如Google助理。Pixel手機取代了Nexus系列。\n2019年8月23日，Google宣布從Android Q開始不再以甜品命名，且直接稱Android Q為Android 10。\n2021年9月27日起，Android2.3.7及以下的Android版本無法登入Gmail、YouTube、Google地圖等相關App，也無法創立或登入Google帳號。\n\n系統特點\n界面\nAndroid的預設用戶界面主要基於直接操作，透過觸控鬆散地對應現實動作以作出輸入，例如滑動、點擊、捏動和反向擠壓，隨著虛擬鍵盤，以操控屏幕上的物件。遊戲控制器及物理鍵盤都能透過藍牙或USB得到支援。在回應用家的輸入方面，設計旨在提供立即流暢的觸摸界面，經常使用設備的振動功能向用戶提供觸覺反饋。內部硬件，例如是加速規、陀螺儀、距離傳感器都能被某些應用程式來回應用戶的操作，例如根據裝置的方向來把屏幕由縱向調整為橫向，或容許用戶透過旋轉裝置，在賽車遊戲中駕駛車輛。\n當Android裝置啟動就會進入主畫面，那是裝置的主要導航及信息「樞紐」，類似於個人電腦的桌面。Android的主畫面通常由應用程序圖標及小工具（widget）組成，應用程序圖標啟動相關的應用程序，而小工具則會實時顯示，並會自動更新內容，例如天氣預報、用戶的電子郵件，或是直接在主畫面上看新聞摘要。主畫面可以由若干頁面組成，用戶可以在這些頁面之間來回滑動。Google Play上提供的第三方應用程式，而其他的應用程式商店可以廣泛使用重新定義的主畫面主題包，甚至模仿其他作業系統的外觀，例如Windows Phone。大多數製造商會定制他們Android設備的外觀和功能，以從競爭對手中脫穎而出。\n屏幕頂部是狀態欄，顯示有關裝置及其連接的資訊。用戶可把狀態欄「拉下」，以顯示應用程式顯示的重要信息，或屏幕更新的通知。通知是「當用戶的應用程序在非使用時所提供簡短、及時和相關的訊息。」當點擊了，用戶會被引導到該app內與該通知相關的屏幕。從Android Jelly Bean開始，可擴展通知「允許用戶透過點擊通知上的圖標，以便它擴展和顯示從通知中得知的更多信息以及有可能的應用操作。」\n「所有應用程序」的屏幕將會所有已安裝的應用程式，用戶可以將應用程序從列表拖曳到主畫面上。「最近」的屏幕讓用戶在最近使用過的應用程序之間進行切換。\n\n應用程式\n應用程式（簡稱apps）是擴展裝置功能的軟件，都是利用Android軟件開發工具包（SDK）編寫的，通常是Java編程語言。Java可以與C語言或C++結合使用，並且可以選擇非默認的執行時函式庫共用，以允許獲得更好的C++支援。雖然Google的Go是有一組有限的應用程式介面（API），然而它也支持編程語言。2017年5月，Google宣布支援Kotlin程式語言。\nSDK包含一套全面的開發工具，包括除錯器、函數庫、基於虛擬機器鏡像的仿真器、文檔，示例代碼和教程。最初，Google支援的整合開發環境（IDE）是使用Android開發工具（ADT）插件的Eclipse；在2014年12月，Google基於IntelliJ IDEA而發布Android Studio，作為Android應用程序開發的主要IDE。其他可用的開發工具，包括應用程序的本地開發套件（NDK），或是用於C或C++中的擴展，MIT應用開發者，那是讓新手程序員的視覺環境，以及各種跨平台流動應用程序框架。2014年1月，Google推出了一個基於Apache Cordova的框架，把Google Chrome、HTML5及網絡應用程式移植到Android，包裝於本機應用程序的外殼中。\nAndroid擁有越來越多第三方應用程序的選擇，用戶可以透過下載和安裝應用程序的APK（Android應用程序包），或利用應用程式商店來下載，允許用戶在那裡進行安裝、更新和移除。Google Play是安裝在Android裝置上的主要應用程式商店，那些程式都符合Google的兼容性要求，並獲得Google行動服務軟件許可。Google Play商店允許用戶瀏覽、下載及更新Google和第三方開發者發布的應用程序。\n由於Android系統的開放性質，使它吸引許多第三方應用程式市場的競爭，及由於違反了Google Play商店的政策或是其他原因而不允許發布的應用程式替代品，第三方應用程式商店的例子包括是亞馬遜應用商店、GetJar及SlideMe。另一個替代市場F-Droid，旨在提供僅在自由和開源許可下分發的應用程式。\n\n内存管理\n由於Android設備通常採用電池供電，因此Android旨在管理流程以將耗電降至最低。當應用程式未使用時，系統會暫停其操作，雖然可以在關閉期間立即使用，但它並不會使用電池電源或CPU資源。當内存不足時，系統將會自動隱藏地開始關閉長時間內處於非活躍狀態下的進程。Lifehacker在2011年的報告指出，第三方任務殺手應用程序是弊大於利。\n\n硬件支援\nAndroid的主要硬體平台為ARM架構（包括ARMv7及ARMv8-A ），在更高階版本的Android中也正式支援x86及x86-64的架構。非官方的Android-x86的項目在得到官方正式支援之前為x86架構提供支援。ARMv5TE和MIPS32/64架構於過去得到支援，但在後來的Android版本中遭到刪除。自2012年以來，隨著擁有英特爾處理器的Android裝置開始出現，包括手機及平板電腦。在得到對64位元平台的支援同時，Android最初是在64位元x86上運行，後來就在ARM64。自從Android 5.0 “Lollipop”以來，除32位元變體（32-bit variants）外，還支持所有64位元變體（64-bit variants）的平台。\n運作Android 7.1的裝置對RAM最低要求的範圍從最佳硬體的2GB降到最常見屏幕的1GB；最低規格的32位元智慧型手機最小需要512MB。Android 4.4的建議是至少需要512MB的RAM，而對於「低RAM」設備，340MB是必需的最低容量，不包括專用內存的各種硬體組件，例如基帶處理器。Android 4.4 需要32位元的ARMv7, MIPS或x86的架構處理器（後兩者是非官方連接埠），以及與OpenGL ES 2.0兼容的圖形處理器（GPU）一同使用。Android支援OpenGL ES 1.1、2.0、3.0、3.1及截至現時為止最新的主要版本3.2及自Android 7.0的Vulkan (API)（和版本1.1適用於某些裝置）。某些應用程式可能會明確要求使用某個版本的OpenGL ES，並且運行此類應用程序需要合適的GPU硬體。\nAndroid裝置包括了許多可選的硬體部件，包括靜止或視頻錄像機、GPS、方向傳感器、專用遊戲控制器、加速規、陀螺儀、氣壓計、磁強計、接近傳感器、壓力傳感器、溫度計和觸控螢幕。某些硬體組件不是必需的，但在某些類別的設備（如智能手機）中成為了標準組件，若存在其他要求，則適用。最初需要一些其他硬體，但那些要求都經已放寬或完全取消。例如，由於Android最初是作為手機作業系統而開發的，因此必須麥克風等那些硬體，而隨著時間的推移，這些手機功能變成可選的項目。Android曾經需要一台自動對焦的相機，這款相機已經放寬到成為固定焦距相機，若是現存的話，當Android開始在數位視訊轉換盒（俗稱機頂盒）上使用時，相機就能完全被丟棄了。\nAndroid除了在智慧型手機和平板電腦上運作外，還可以在一些附有鍵盤和滑鼠的普通PC硬體上運作。除了可在商用硬體上使用外，Android也有類似於PC硬體友好的版本，可以從Android-x86的項目中免費提供，包括個人訂制的Android 4.4版本。使用作為Android SDK一部分的仿真器，或第三方的仿真器，Android也可以在x86架構上非本機地執行。中國的一些公司基於Android，正在構建PC與行動裝置的作業系統，是「Google Android與Microsoft Windows之間的直接競爭。」中國工程學院指出，隨著中國禁止在政府電腦上使用Windows 8，數十家公司正在定制Android系統。\n\n軟體開發\nAndroid是由Google開發的，直至準備發布前最新的修改及更新，在這一點上原始碼可供Android開源項目（AOSP）使用，這是一個由Google領導的開源計劃。AOSP代碼可於無需的修改選定設備中找到，主要是Google Nexus及Google Pixel系列的裝置。反過來說，那些開源碼是由代工生產定制和調整以在他們的硬件上執行。此外，Android的源代碼並不包含某些硬件組件所需專有的驅動程式，因此大多數的Android裝置（包括Google自己的裝置）最終都會附帶著自由及開放源碼軟件及專有軟件的組合，伴隨著用於進入Google服務所需的軟件，都會落入後者的一類。\n\n更新時間表\nGoogle每年都會宣布對Android進行重大的增量升級。程式更新可以透過空中編程以無線傳輸於裝置上安裝。最新的主要版本是在2024年10月發布的Android 15。\nAndroid與其主要的競爭對手蘋果公司的iOS相比，Android的更新通常會明顯的延遲以讓各種設備安裝。除了Google的Nexus和Pixel品牌的裝置外，更新通常會在新版本發布的幾個月後到達，或者根本沒有。這部分是由於Android裝置中硬件各不相同，每次升級必須專門定制，那是個耗費時間和資源的過程。製造商經常會優先考慮他們最新的設備並遺下舊設備。在收到製造商的更新後，無線運營商可以讓裝置額外延遲推出，以便於升級發送給用戶之前，商戶能透過進一步根據自己品牌的需求而定制及在他們的網絡上進行廣泛的測試。由於一個製造合作夥伴沒有為驅動程式提供必要的更新，故此會有一些情況下無法進行升級。\n隨著新版本的作業系統，Android設備中硬件的廣泛變化會導致軟件升級有嚴重的延誤，而修補程式通常需時幾個月才能到達消費者手中，有時甚至根本沒有。製造商和運營商缺乏售後支援服務受到消費者群及科技媒體的廣泛批評。一些評論員指出了一點，指這個行業有一個金融刺激而不會為他們的裝置升級，由於缺乏為現有裝置更新，故推動購買新產品，這種態度被形容為「侮辱」。《衛報》抱怨指更新的分發方法很複雜只是因為製造商和運營商都是這樣設計。2011年，Google與眾多業內人士合作宣布推出「Android更新聯盟」，承諾在每台裝置發布後18個月內提供及時更新，然而，自宣布以來，關於那個聯盟並沒有另外一個官方的說法。\n2012年，Google開始將作業系統的某些方面（特別是其核心應用程式方面）脫鉤，這樣他們就可以通過Google Play商店獨立地為作業系統作更新。其中一個組件—Google Play服務，是個閉源的、系統級的程序，可為Google服務提供應用程式介面，為執行Android Froyo或更高版本的裝置上自動安裝更新。通過這些特性，Google可以透過Play服務添加新的系統功能及更新應用程式而毋需將升級分發到作業系統本身，因此，Android Jelly Bean包含相對較少面向用戶的變化，對平台改進及細微變化更為側重。\n2016年5月，彭博報導稱Google正在努力讓Android保持最新狀態，包括加快安全更新率、推出技術的解決方案、減少對手機測試的要求，並對電話製造商進行排名，試圖利用「羞辱」他們來讓行為變得更好。正如《彭博》所說：「隨著智能手機變得越來越強大，複雜和可攻擊，讓最新的軟件能與硬件密切合作變得越來越重要。」Android的領導人浩史·洛克海默承認指「這不是一個理想的情況」，他進一步評論指缺乏更新是「Android上安全性最薄弱的環節」。無線運營商在報告中被描述指那是「最具挑戰性的討論」，因為運營商的網絡測試審批時間較慢，儘管有一些運營商包括威訊無線及Sprint，已經縮短了他們各自的審批時間。HTC的時任執行官賈森·麥肯齊（Jason Mackenzie）於2015年稱每月的安全性更新是「不切實際」，而Google試圖說服運營商從完整的測試程序中排除安全補丁。為了進一步說服，Google分享了與其Android合作夥伴更新設備的頂級手機製造商的一份清單，並正在考慮將名單向公眾發布。手機製造商Nextbit的聯合創始人及前Android開發人員Mike Chan說，「解決這個問題的最佳方法是對作業系統進行大規模的重組架構」或Google可以投資培訓製造商和運營商「成為優秀的Android人民」。\n2017年5月，隨著Android Oreo發布，Google推出了Project Treble，旨在使製造商能夠更輕鬆，更快捷，及更低成本地將裝置更新到Android的最新版本。Project Treble通過新的「供應商界面」將供應商實施與Android OS框架分開（由硬體製造商所寫供設備專用的較低級別軟件）。在Android 7.0及更早版本中，並不存在正式的供應商界面，因此設備製造商必須更新大部分Android代碼，以將較新版本的作業系統移至設備中。借助Project Treble，新的穩定供應商界面可以進入Android特定部分的硬件，使設備製造商能夠簡單地通過更新Android作業系統框架來為裝置提供新的Android版本，而「毋須矽製造商的任何額外工作。」\n2017年9月，Google的Project Treble團隊透露，作為改善Android設備安全生命週期努力的一部分，Google已經設法讓Linux基金會同意延長Linux長期支援（LTS）的內核分支的生命週期至少兩年。从 Linux 4.4 版本内核开始，未来版本的 LTS 内核将至少拥有 6 年的生命支持周期。。\n\nLinux核心\nAndroid的內核是根據Linux核心的長期支援的分支，具有典型的Linux排程和功能。截至2018年，Android的目標是Linux內核的4.4、4.9或是4.14版本。實際的內核取決於單個設備。\nLinux內核的Android的變種具進一步改進了由Google實施在典型的Linux內核開發週期之外實現的架構變化，比如包含類似組件的裝置樹（device trees）、ashmem、ION，以及不同的內存不足（OOM）的處理。除此之外，Google為了能讓Linux在行動裝置上良好的運行，對其進行了修改和擴充。Android去除了Linux中的本地X Window System，也不支持標準的GNU庫，這使得Linux平台上的應用程式移植到Android平台上變得困難。Google也有某些功能貢獻回到Linux內核，特別是一種稱為「喚醒鎖（wakelocks）」的電源管理功能，它最初被主線內核開發人員拒絕，部分原因是因為他們認為Google並沒有表現出維護他們自己代碼的任何意圖。2008年，Patrick Brady於Google I/O上演說題為「Anatomy & Physiology of an Android」，並提出Android HAL的架構圖。HAL以*.so副檔名的形式存在，可以把Android框架跟Linux內核隔開，這種中介層的方式使得Android能在行動裝置上獲得更高的執行效率。這種獨特的系統結構受到Linux內核開發者葛雷格·克羅哈曼及其他核心維護者稱賞。Google還在Android的核心中正式加入了自己開發製作的一個名為喚醒鎖（wakelocks）的功能，該功能用於管理流動裝置的電池性能，但是該功能並沒有被加入到Linux核心的主線開放和維護中，因為Linux核心維護者認為Google沒有向他們展示這個功能的意圖和代碼。Google於2010年4月宣布他們將會聘請兩名員工跟Linux內核社團合作，但目前Linux內核對於穩定分支維護者的葛雷格·克羅哈曼，他於2010年12月說他擔心Google不再試圖讓他們的代碼更改包含在主流Linux中。Google的工程師帕特里克·布雷迪（Patrick Brady）曾在該公司的開發者大會中表示過「Android不是Linux」，而他在周刊《Computerworld》補充指「讓我替你簡化一下，要是沒有Linux，這裡就沒有Android」。《Ars Technica》寫道：「儘管Android是建立在Linux內核之上的，但該平台與傳統的Linux堆棧桌面幾乎沒有共同之處。」\n2010年2月3日，由於Google在Android核心開發方面和Linux社群方面開發的不同步，Linux內核開發者葛雷格·克羅哈曼把Android的驅動程序從Linux內核「狀態樹」（staging tree）上除去。2010年4月，Google宣布將派遣2名開發人員加入Linux核心社群，以便重返Linux核心。2010年9月，Linux核心開發者Rafael J. Wysocki添加了一個修復程序，使得Android的“wakelocks”可以輕鬆地與主線Linux核心合併。\n2011年8月，Linux內核最早作者的林納斯·托瓦茲說：「Android和Linux最終都會重新回到一個共同的內核，但它可能不會持續4-5年」。2011年12月，葛雷格·克羅哈曼（Greg Kroah-Hartman）宣布啟動Android的主流項目，其目的是要將一些Android驅動程式、修補程式及功能重新放進Linux內核中，從Linux 3.3開始。經過從前多次的嘗試合併後，Linux在3.5內核中，包括自動休眠和喚醒鎖功能功能。其界面是相同的，但是上游的Linux實現了容許兩種不同的中止模式：記憶體（Android使用的傳統中止模式）及磁碟（已知桌面上的冬眠）。Google維護著一個公共代碼存儲庫，包含著他們對Android的Rebasing到最新穩定的Linux版本的實驗工作。\nAndroid裝置的快閃記憶體被分成幾個分區，例如/system用於作業系統本身，而/data是用於用戶數據和應用程式的安裝。跟Linux桌面發行版相比，Android設備的擁有人都沒有給予超級用戶的進入作業系統的權限，以及例如/ system是唯讀記憶體的敏感分區。然而，檔案系統階層標準是可以透過利用Android中的安全漏洞來獲取，那是開源社區經常使用它來增強其設備的功能，惡意的一方還可以透過安裝電腦病毒及惡意軟件來惡意獲取系統資料。\n根據Linux基金會的說法，Android是個Linux發行版，該基金會由Google的開源部門主管克里斯·迪博納及幾位記者組成，其他人例如Google的工程師帕特里克·布拉迪（Patrick Brady）等，布拉迪表示在傳統類Unix系統的Linux發行意義上，Android並不是Linux；Android不包括GNU C函數庫（它利用 Bionic作為替代C數據庫），以及Linux發行版中常見的一些其他組件。\n隨著2017年Android Oreo的推出，Google基於安全考慮，開始要求新附帶系統單晶片的設備具有Linux內核版本4.4或更高版本，現有的裝置升級到Android Oreo，以及與舊的系統單晶片一起推出的新產品，均不受此規則所限。\n\n軟件堆棧\n在Linux內核之上，有一些由C所寫的中介軟體、函數庫和應用程式介面，以及運行包含Java兼容庫的應用框架上應用程式。Linux內核的開發則繼續獨立於Android的其他源代碼項目。\n截至5.0版本，Android利用Dalvik虛擬機器作為程式虛擬機器，它與實時的跟蹤編譯（JIT）來執行Dalvik「DEX-代碼」（Dalvik的可執行程式），這通常是由Java位元組碼一同翻譯而來。繼基於跟踪的JIT的原則，除了解讀大多數應用程序代碼外，Dalvik執行編譯及每當應用程序啟動時，選擇本機執行的頻繁執行代碼段（痕跡）。Android 4.4引入Android Runtime（ART）作為新的運作環境，在安裝應用程式時，它會使用提前編譯（AOT）來把應用程序字節碼完全編譯為機器語言。在Android 4.4中，ART是一項實驗性功能，默認情況下不啟用；它成為Android 5.0的下一個主要版本中唯一的運作選項。2015年12月，Google宣布Android的下一個版本將會切換到基於OpenJDK項目的Java實行方式。\nAndroid的C標準函式庫及Bionic都是由Google專門為Android而開發的軟件，作為BSD標準C程式庫代碼的推導。Bionic本身已跟特定於Linux內核的幾個主要特點而設計。使用Bionic而不是GNU C函數庫（glibc）或uClibc的主要好處是：它運行時間的足跡較小，以及對低頻CPU進行優化。與此同時，Bionic根據BSD許可條款而獲得許可，當中Google找到更適合Android的整體許可模式。\n針對不同的許可模式，Google於2012年底將Android中的藍牙堆棧從GPL許可的BlueZ轉移到Apache許可的BlueDroid。\nAndroid默認情況下並沒有本機X Window系統，也不支援整套標準GNU庫。這使現有Linux應用程式或程式庫都難以移植到Android，直至Android的Android原生开发套件的r5版本完全以C或C++編寫的應用程序以獲得支援由C所編寫的程式庫也可以透過注入一個小墊片及使用Java本地介面（JNI）以在應用程式中使用。\n自Android Marshmallow發布以來，一系列指令實用程序的「玩具盒」取代了之前Android版本中類似「Busybox」系列（當Android於默認情況下不提供命令列介面時，它主要供應予應用程序使用）。\nAndroid也有另一個作業系統，名為「Trusty作業系統」，作為「Trusty」當中的一部分，軟件組件在行動裝置中支援著一個可信執行環境（TEE）。「Trusty和Trusty API是\n可調整的......」Trusty OS的應用程式可以由C或C++所編寫（C++的支援是有限的），他們可以進入一個小型的C程式庫......所有Trusty應用程式都是單線程的；多線程的用戶空間目前並不支援......第三方應用程式的開發並非支援當前版本，而作業系統和處理器上使用軟件，為「受保護的內容執行DRM框架」。TEE還有許多其他用途，例如行動支付、銀行業的保安、全磁碟加密、多重身份驗證，裝置重設保護、重播保護的持久性存儲、無線顯示受保護的內容（強制轉換）、安全的PIN和指紋處理，甚至是惡意軟件檢測。\n\n開源社區\nAndroid的原始碼是由Google在開源許可下發布，其開放的性質鼓勵著一個龐大的開發者社區及發燒友利用開源碼作為社區驅動項目的基礎，它可為舊設備提供更新、為高級用戶增加新功能，或最初隨附其他作業系統的裝置引入Android系統。這些社區開發的版本通常比較透過官方製造商／運營商的渠道更快為裝置帶來新功能和更新的，亦具有相當質量的水平；為不能再接收官方更新的舊裝置提供持續性支援；或把Android帶到正式發布使用其他作業系統的裝置上，例如TouchPad。社區發布經常出現Root前並包含由原始供應商並未提供的修改，例如讓裝置內處理器超頻或是調高／低電壓的能力。CyanogenMod是社區中使用最廣泛的韌體，惟現已停產並由LineageOS繼任。\n從歷史上看，裝置製造商及行動運營商通常都不支持第三方韌體的開發。製造商對使用非官方軟件的裝置功能不正常，以及由此產生的支援費用表示擔憂。此外，如CyanogenMod般經修改的韌體有時也會提供例如Tethering等功能，否則運營商將收取額外費用。因此，許多裝置中常見的技術障礙，包括鎖定啟動程式及限制訪問root的權限都是常見於許多設備中。然而，隨著社區開發的軟件越來越受歡迎，美國國會圖書館館長在發表聲明之後，允許行動裝置進行越獄，製造商和運營商經已對第三方開發軟件的立場軟化，包括HTC、摩托羅拉、三星及索尼，他們提供支持和鼓勵發展。因此，隨著時間的推移，由於越來越多的裝置隨附著已解鎖或可解鎖的啟動程式，繞過硬件限制的規避而安裝非官方韌體的需要降低了，這類似於Nexus系列手機，雖然他們通常要求用戶放棄為裝置進行保修。然而，儘管製造商已經接受，但美國的一些運營商仍然要求手機被鎖定，此讓開發人員和客戶感到沮喪。\n\n安全和隱私\n公共機構的監督範圍\n2013年9月，美國及英國的情報機構—美國國家安全局（NSA）及英國政府通訊總部（GCHQ）分別披露作為更廣泛大規模監控披露（2013年至今）的一部分，他們可以進入iPhone、黑莓手機及Android裝置中，存取用戶的數據。據報導，他們幾乎能夠閱讀所有智能手機上的資訊，包括短訊、位置、電郵及備忘錄。2014年1月，進一步的報告顯示情報機構擁有攔截個人資訊傳輸的能力，他們透過社交網絡及其他流行的應用程式如《憤怒鳥》，以用於廣告和其他商業原因而收集用戶的個人資訊。根據《衛報》的報導，GCHQ有不同應用程式和廣告網絡的Wiki風格指南，以及可以從每個數據中抽取不同的資訊。在該周後期，芬蘭的憤怒鳥開發者Rovio娛樂宣布，鑑於這些啟示，他們正重新考慮與其廣告平台的關係，並呼籲更廣泛的同業也應這樣做。\n這些文件顯示情報機構進一步努力攔截從Android和其他智能手機中Google地圖的搜索及查詢，以收集大量的位置信息。儘管《衛報》指出「技術部門是如何收集和使用信息，特別是對於美國以外的人，他們所享有的隱私保護比美國人少，這些最新的披露也可能會引起公眾越來越多的關注」，然而NSA及GCHQ堅持認為他們的活動都符合所有相關的國內和國際法律。\n維基解密公佈了2013-2016年代號為Vault 7的洩露文件，當中詳細說明了中央情報局（CIA）進行電子監視和網絡戰的能力，包括損害大多數智能手機的作業系統（包括Android）的能力。\n\n常見的安全威脅\n由於Android作業系統的自由和普及性，一些惡意程式和電腦病毒也隨之出現。2010年8月，卡巴斯基病毒實驗室報告指發現到Android系統上首個木馬程式，並將其命名為「Trojan-SMS.AndroidOS.FakePlayer.a」，這是一個通過短訊方式感染智慧型手機的木馬程式，並且已經感染了一定數量的Android設備。除了透過短訊的感染方式，這些Android木馬程式還可以偽裝成一些主流的應用程式，並且還可以隱藏於一些正規的應用程式之中。\n來自防毒公司趨勢科技的研究，他們列出最常見Android韌體的類型為踐踏優質服務，在未經用戶同意或甚至是用戶不知情下從受感染的手機發送短訊至具附加費的電話號碼。其他惡意軟件於裝置上顯示不需要或侵入性廣告，或將用戶的個人信息發送至未經授權的第三方。據報導，Android上的安全威脅正在呈幾何級數式地增長；然而，Google的工程師辯論著安保公司出於商業原因而誇大Android系統上的惡意軟件和病毒威脅，並指責安保行業玩弄恐懼而向用戶推銷病毒防護軟件。Google堅持危險的惡意軟件其實是非常罕見的，而芬安全曾進行的一項調查顯示，只有0.5％的Android惡意軟件是來自Google Play商店。\n儘管Google通過定期的檢查撤除這些存在於Google Play商店上的惡意程式和病毒，但是這並不能完全阻止其他病毒通過第三方網路的方式產生並且傳播。2015年8月，Google宣布Google Nexus系列中的裝置將會開始每月收到安全性修補程式。Google還寫道：「Nexus裝置將會在至少兩年內繼續獲得重大更新，而安全性修補程式從裝置透過Google Store購買起的18個月內，或從初始可用性起計算三年以上的安全補丁。」接下來的10月，劍橋大學的研究人員得出結論，由於缺乏更新和支援，87.7％使用中的Android手機有已知但未修補安全漏洞。2015年8月，《Ars Technica》的榮恩·阿馬德奧（Ron Amadeo）也寫道：「Android原先設計最重要的是被廣泛採用。Google從頭開始，由0%的市場佔有率，所以它很高興放棄控制權並讓每個人於採納的桌上佔一席位......現在，儘管Android擁有全球智能手機市場約75-80％的市場佔有率—使它不僅是世上最流行的行動作業系統，亦可說是現時最流行的作業系統。因此，安全性已成為了一個大問題。當Android生態系統沒有設備要更新，指令鏈的設計回歸，但Android仍然沿用軟件更新，它只是起不了作用。」隨著Google每月更新時間表的消息出來後，包括三星和LG在內的一些製造商承諾每月發布安全性更新。但是正如傑瑞·希爾登布蘭德（Jerry Hildenbrand）於2016年2月的《Android中央》所指，「相反，我們在幾種極少數機型的特定版本中得到了一些更新，還有一堆破碎了的承諾」。\n2017年3月，在Google的安保博客的帖子上，Android的安保主管阿德里安·路德維希（Adrian Ludwig）及梅爾·米勒（Mel Miller）寫道：「在2016年，來自200多家製造商，有超過735,000,000個裝置獲得平台的安全性更新」，並且「我們的運營商及硬件合作夥伴幫忙為這些更新擴展了部署，在2016年最後一個季度為全球排名首50位的超過一半裝置發布更新」。他們還寫道：「截至2016年底，大約有一半使用中的裝置在過去的一年並沒有接收到平台的安全性更新」，並指他們的工作將繼續專注於精簡安全性更新程序，以便製造商進行部署。此外，對於《TechCrunch》的評論中，路德維希表示，安全更新的等待時間已從「6至9星期縮減至數天」，截至2016年底，在北美約有78％的旗艦裝置都獲得最新的安全性更新。\n修補核心作業系統中發現的錯誤通常都不會送達到老舊及低價裝置的用戶手上。然而，Android的開源特性容許安保承包商採用現有設備，並把它們改編用於高度安全性的用途上，例如：三星跟通用動力合作，透過他們的開放核心實驗室的收購，以在「Knox」的項目上重建「果凍豆」（Android 4.4）。\nAndroid的智能手機能夠報告Wi-Fi接入點的位置（在電話用戶四處行動時遇到），構建包含數億個此類進入點物理位置的數據庫。這些數據庫構成了用於智能手機中電子地圖的定位，讓他們使用應用程式如Foursquare、Google定位、Facebook定位，並能提供基於該位置的廣告。第三方的監控軟件，例如TaintDroid，那是由學術研究資助的項目，在某些情況下，可以檢測到用戶的個人資訊何時從應用程式發送至遠端伺服器。\n目前Android作業系統上已經擁有不同公司的殺毒軟件來防止裝置中毒，例如Avast、F-Secure、Kaspersky、Trend Micro、Symantec、金山毒霸等防護軟體也已經發布了Android版本。\n某些病毒，目前經過Cross-Compile的測試，證實它們在Linux上無法正常運作。\n2018年11月，知名Android軟體Magisk的開發者topjohnwu在XDA上發帖稱，現在很多Android手機存在系統漏洞，該漏洞可使第三方應用程序在不被用戶授權的情況下監視其它程序的運行，其中可能涉及到個人隱私的泄露問題，值得關注。\n\n技術性保安功能\nAndroid系統具有沙盒機制。沙盒於系統中是一個分離的區域，該區域無法獲取系統的其他資源，除非在安裝應用程式時，用戶明確地授予其獲取資源的權限。然而，這一限制對於出廠時預先安裝的應用程式則可能無法實現。例如預先安裝的相機應用程式，在沒有完全禁用相機的情況下，無法關閉麥克風的權限。這個情況在Android的版本7和8當中也有效。所有的應用程式都可先被簡單地解壓縮到沙盒中進行檢查，並且將應用程序所需的權限提交給系統，再將其所需權限以列表的形式展現出來供用戶查看。例如一個第三方的瀏覽器需要「連接網絡」的權限，或者一些軟體需要撥打電話，或發送短訊等。用戶可以根據所需權限來考慮自己是否需要安裝，應用程式只能在用戶同意之後才能進行安裝。\n2012年1月，美國國家安全局發布了SE Android（原本名為Security Enhanced Android，後來改名為SE for Android或Security Enhancements for Android）的開放源碼專案及程式碼，使Android系統支援強制存取控制（Mandatory Access Control）以增加系統安全性。\n自2012年2月起，Google使用其惡意軟體掃描器Google Bouncer監察和掃描在Google Play商店上的應用程式。2012年11月，Google於Android Jelly Bean推出「驗證應用程式」的功能，作為作業系統的一部分，掃描來自Google Play和第三方來源的所有應用程式，以防止惡意行為。「驗證應用程式」最初只在安裝期間進行，然而它在2014年的更新後不斷地掃描應用程式，並在2017年透過「設定」中的選項，讓用戶可見到該功能。\n在安裝「驗證應用程式」前，Google Play商店會顯示一系列應用程序所需的要求，查閱這些權限後，用戶可以選擇接受或拒絕，但必須要在接受的情況下才能安裝應用程式。\n在Android Jelly Bean中，其原生應用程式管理機制App Ops首次被引入，但並未開放讓一般用戶使用，直至Android Marshmallow，系統啟用其原生應用程式的權限控制（並非App Ops），它容許用戶在程式安裝後仍能對特定類別的權限使用進行開關，若應用程式的某組權限使用被關閉並準備進入相應權限的方式時，系統會詢問用戶是否容許。\n在Android Marshmallow之前，其權限系統是以「一刀切」的方式進行，應用程式開發商會申請一些非必需的進入權限，或是申請把用戶的私隱資訊作暗中收集、使用、發送至開發商的伺服器；高端用户可以透過取得root權限增加控制程式或修改程式的安裝文件，以仔細限制程式的使用權限，或當中涉及數據的運用，然而程式對權限只能在安裝時選擇「全部同意／全部拒絕」的選項經常為人詬病。\n在Marshmallow中，應用程式不再在安裝時自動授予其所有指定權限，它會以「選擇加入系統」來代替。當應用程式請求授予某一權限時，系統會就是否授予該權限詢問用戶。應用程式會記著所授權限，授權設定亦可由用戶隨時更改。但是，預先安裝的應用程式不能總是以此方法卸載。在某些情況下，用戶可能無法拒絕預先安裝的應用程式的某些權限，甚至無法禁用它們。就如Google Play的應用程式，無法卸載或禁用。任何強制停止的嘗試的結果只會導致應用程式自動重啟。新權限僅供利用軟體開發套件（SDK）為Marshmallow開發的應用程序使用，舊的應用程式將繼續使用以前沿用沒有中間或妥協的方式。對於這些應用程式，其權限仍然可以被撤銷，但這可能會妨礙它們正常運作，並會因此顯示警告。\n2013年8月，Google發布了Android設備管理器，那是一項於同年12月發布的Android應用程序，它容許用戶利用他們的Android裝置作遠程跟踪、定位及抹除的服務，該應用程式於2017年5月重新命名為「尋找我的手機」。在2016年12月，Google推出可信聯繫人的應用程式，讓用戶在緊急情況下要求取得親人的位置追踪。\n\n許可證\nAndroid作業系統的原始碼是開源碼：那是由Google開發的，在發布新版Android的同時公開發布源代碼，一切程式碼為公開免費的。Google發布了大部分的源代碼（根據開放手機聯盟所開發的非Copyleft的Apache授權條款2.0下，允許修改和再分配，剩下的Linux内核部分則延續GPL第2版的許可），當中包括網絡和電話解決方案堆棧。該許可證並不授予「Android」的商標權利，所以設備製造商和無線運營商必須根據個人合同向Google獲得許可。Google也會與硬件製造商合作生產旗艦設備（Nexus系列的一部分），它以包含新版本的Android為特色，然後在該裝置發布後公開其源代碼。Google也不斷發問卷和開放修改清單、更新情況及程式碼來讓任何人看到並且提出意見和評論，以便按照用戶的需求改進Android作業系統。Android版本中唯一沒有立即發布其源代碼的是僅限於平板電腦3.0使用的「蜂窩（Honeycomb）」版本，其原因是根據安迪·魯賓於Android的官方博客文章指，是因為該版本是爲了摩托羅拉Xoom而倉促開發，他們並不希望第三方試圖把適用於智能手機的Android版本套用在平板電腦上以創造「非常糟糕的用戶體驗」。\n只有基礎的Android作業系統（包括一些應用程式）才是開源軟件，任何廠商都不須經過Google和開放手持設備聯盟的授權隨意使用Android作業系統；大多數Android裝置都附帶著大量的專有軟件，例如是Google流動服務，當中包括Google Play商店、Google搜尋，以及Google Play服務 — 那是一個提供與Google提供的服務應用程式介面集成的軟件層。這些應用程式必須由裝置製造商從Google得到許可，並且只能在符合其兼容性指引及其他要求的配備裝置上，任何廠商都不能在未授權的情況下在其產品上使用Google的標誌和應用程序。除非生產商能證明其生產的裝置符合Google兼容性定義文件（CDD），才能在智慧型手機上預載屬於Google的應用程式。所有符合Google生產規定的智能手機廠商才可以在其產品上印有「With Google」的標誌。由製造商生產的定制，認證的Android發行版（例如是TouchWiz及HTC Sense），也可以使用他們自己的專有軟件，以及新增並不包括在Android作業系統中的stock應用程式，以替換Android中某些stock應用程式。對於設備中的某些硬件組件，這裡可能還需要二進制點的驅動程式的使用。\n\n對製造商的影響力\nGoogle僅將其流動服務軟件以及Android的商標授權予符合Android兼容性計劃中指定的Google的兼容性標準，因此這使作業系統本身有著重大變化的Android分支（不包括任何Google的非免費組件）跟其所需的應用程式保持不兼容，並且必須隨附替代軟件，以替代Google Play商店中的市場。此類Android分支的例子有亞馬遜的Fire OS（那是用於為亞馬遜服務的Kindle Fire系列平板電腦）、諾基亞X軟件平台（諾基亞X家族的分支，主要用於為諾基亞及微軟服務），以及由於在某些地區一般都無法使用Google服務（例如中國大陸），故排除了Google應用程式的其他分支。2014年，Google也開始要求所有授權使用Google流動服務軟件的Android裝置的啟動畫面上顯示一個突出的「由Android提供支援」的標誌。Google還強制執行了在裝置上設置Google流動服務及優惠捆綁計劃，包括強制捆綁整個Google主要應用程式套件，和Google搜索的捷徑，以及Google Play商店的應用程式必須以預設配置或在主畫面的預設配置附近。\n從前在Android的早期版本中使用AOSP代碼的一些股票應用程式及元件，例如搜尋、音樂，行事曆及位置API都被Google遺棄，以支持透過Play商店分發的非免費替代品（Google搜尋、Google Play音樂及Google行事曆）和Google Play服務，它們不再是開源的。此外，某些應用程序的開源變體還排除非自由版本中存在的功能，例如相機中的全景相片（Photosphere），和在預設主畫面上的Google即時資訊（由「Google Now Launcher」的專有版本專用，其代碼嵌入於主要Google應用程式的代碼中）。這些措施可能旨在阻止分叉並鼓勵符合Google商業許可的要求，作為大多數作業系統的核心功能（以及第三方軟件）依賴於Google獨家授權的專有組件，並且它需要大量的開發資源來開發一套替代套件和API來複製或把它們替換。不使用Google組件的應用程式也會處於功能劣勢，因為他們只能使用作業系統本身包含的API。\n2018年3月，據報導Google開始阻止「未經認證」的Android裝置使用Google流動服務軟件，並顯示一條警告指，「設備製造商已預載了未經Google認證的Google應用程式及服務」。自定義ROM的用戶能夠將他們的裝置ID以他們的Google帳戶註冊來刪除此障礙。\n包括大多數Android OEM的開放手機聯盟的成員，被禁止簽訂生產運行Android分支的設備的合同；2012年，宏碁被Google強行中斷生產運行由阿里巴巴集團開發的AliOS的設備，威脅其若不停止則要將其從聯盟中移除，因為Google認為該平台是Android的不兼容版本。阿里巴巴集團為這些指控進行辯護，爭辯指其作業系統是Android的獨特平台（主要使用HTML5應用程式），但是它整合了Android平台的部分內容，容許向後兼容第三方Android軟件。事實上，這些裝置確實附帶了一個提供Android應用程式的應用商店；然而，它們大多數都是盜版軟件。\n\n系統架構\n中介软件\n作業系統與應用程式的溝通橋樑，並用分為兩層：函式層和虛擬機器。\nBionic是Android改良libc的版本。Android包含了Chrome流覽器引擎。Surface flinger是就2D或3D的內容顯示到螢幕上。Android使用工具鏈為Google自制的Bionic Libc。\nAndroid採用OpenCORE作為基礎多媒體框架。OpenCORE可分7大塊：PVPlayer、PVAuthor、Codec、PacketVideo Multimedia Framework（PVMF）、Operating System Compatibility Library（OSCL）、Common、OpenMAX。\nAndroid使用Skia為核心圖形引擎，搭配OpenGL/ES。Skia與Linux Cairo功能相當，但相較於Linux Cairo，Skia功能還只是陽春型的。2005年Skia公司被Google收購，2007年初，Skia GL源碼被公開，目前Skia也是Google Chrome的圖形引擎。\nAndroid的多媒體資料庫採用SQLite資料庫系統。資料庫又分為共用資料庫及私用資料庫。使用者可透過ContentProvider類別取得共用資料庫。\nAndroid的中間層多以Java實作，4.4版之前使用特殊的Dalvik虛擬機器。Dalvik虛擬機器是一種“暫存器型態”的Java虛擬機器，變數皆存放於暫存器中，虛擬機器的指令相對減少。5.0版起改用Android Runtime（ART）。\nDalvik虛擬機器可以有多個實例，每個Android應用程式都用一個自屬的Dalvik虛擬機器來執行，讓系統在執行程式時可達到最佳化。Dalvik虛擬機器並非執行Java字節碼，而是執行一種稱為.dex格式的檔案。\n\n硬體抽象層（HAL）\nAndroid的硬體抽象層是能以封閉源碼形式提供硬體驅動模組。HAL的目的是為了把Android framework與Linux kernel隔開，讓Android不至過度依賴Linux kernel，以達成“內核獨立”（kernel independent）的概念，也讓Android framework的開發能在不考量驅動程式實作的前提下進行發展，以達到壟斷GPU市場的目的。\nHAL stub是一种代理人的概念，stub是以*.so档的形式存在。Stub向HAL“提供”操作函数，并由Android runtime向HAL取得stub的操作，再回调这些操作函数。HAL里包含了许多的stub（代理人）。Runtime只要说明“类型”，即module ID，就可以取得操作函数。\n\n程式語言\nAndroid是執行於Linux kernel之上，但並不是GNU/Linux。因為在一般GNU/Linux裏支持的功能，Android大都沒有支援，包括Cairo、X11、Alsa、FFmpeg、GTK、Pango及Glibc等都被移除掉了。Android又以bionic取代Glibc、以Skia取代Cairo、再以OpenCORE取代FFmpeg等等。Android為了達到商業應用，必須移除被GNU GPL授權證所約束的部份，Android並沒有用戶層驅動（user space driver）這種東西。所有的驅動還是在內核空間中，並以HAL隔開版權問題。bionic/libc/kernel/ 並非標準的內核頭文件（kernel header files）。Android的內核頭文件是利用工具由Linux內核的頭文件所產生的，這樣做是為了保留常數、資料結構與巨集。\nAndroid的核心基於Linux，除了核心之外，則是中介層、資料庫元和用C/C++編寫的API以及應用程式框架。Android的應用程序通常以Java資料庫元為基礎編寫，運行程序時，應用程式的代碼會被即時轉變為Dalvik dex-code（Dalvik Executable），然後Android作業系統通過使用即時編譯的Dalvik虛擬機來將其運行。\n目前Android的Linux kernel控制包括安全、記憶體管理、進程管理、網路堆疊、驅動程式模型等。下載Android源碼之前，先要安裝其構建工具Repo來初始化源碼。Repo是Android用來輔助Git工作的一個工具。\n\n應用程序\nGoogle Play\nGoogle透過前身為Android Market的網上商店平臺Google Play，提供應用程式和遊戲供用戶下載，是Android的官方应用商店。截至2013年7月，Google Play官方認證應用程式數量突破100萬，超過蘋果App Store成為全球最大應用商店。中文App名稱為「Play 商店」\n2009年2月，Google推出Android Market线上應用程式商店，用户可在该平台网页寻找、购买、下载及评级使用智慧型手機应用程序及其他内容。第三方軟體開發商和自由開發者則可以通過Android Market發布其開發的應用程序。在2011年12月，Android Market上的應用程序下載量超過100億次。同時，全球已有1億3千萬部Android設備在Android Market即現在的Google Play上下載過軟體。\n只有通過Google許可並且認證的廠家才能在其產品設備上安裝Google服務框架和Google Play。同時受到部分地區和國家的政策影響，Google根據部分地區和國家的政策對Google Play上的內容進行了過濾，因此各地區和國家看到的內容不一樣。此外，受到部分地區和國家的電信運營商的影響，Google Play在部分地區和國家可能不可使用。\nGoogle Play內的付費程序在許多國家與地區內提供，如美國、英國、瑞典、德國、斯裡蘭卡、泰國、越南、香港、臺灣等。由於受到谷歌退出中国大陆事件影響，目前Google Play的服務還沒有擴展到中國大陸地區，但大陸用戶仍可通過國際信用卡和相關的免費軟體來完成購買。需要注意的是，通過這種方法購買的軟體可能不會得到當地承認的發票。\n除了Google的Google Play之外，還有其他公司的應用程式市場，如亞馬遜公司的Amazon Appstore，三星公司的三星應用商店，Fetch，AppBrian，與中國國內的酷安、豌豆莢等。\n此外，Google Play還提供在Android系統後台對安裝的應用程序進行驗證的服務，以最大程度防範惡意軟件的侵害。\n2014年11月，Google已表示將支持中國開發者開發Google Play應用。\n\n程序開發\n在早期的Android應用程序開發中，通常通過在Android SDK（Android軟體開發包）中使用Java作為編程語言來開發應用程序。開發者亦可以通過在Android NDK（Android Native開發包）中使用C語言或者C++語言來作為編程語言開發應用程序。同時Google還推出了適合初學者編程使用的Simple語言，該語言類似微軟公司的Visual Basic語言。此外，Google還推出了Google App Inventor開發工具，該開發工具可以快速地構建應用程式，方便新手開發者。\n\n移植到Chrome OS\n2016年5月20日，Google在Google I/O上表示，將會把 Google Play商店和Android App帶到Chrome OS中，使Chrome OS可以執行Android APP增加推行Chromebook和Chromebox的動力，解決該平台應用程式不足的問題；此外Chromebook在美國市場出貨量已經超越蘋果Mac。\nGoogle把Android應用程式整合進Chrome OS有市場傳言Google的目的是想將兩者合併，但Android、Chrome OS 與Google Play部門的資深副總裁Hiroshi Lockheimer在專訪中駁斥外界傳言，稱並不會將兩者合併，Chrome OS更像是一台電腦，以桌面、檔案管理、鼠標和鍵盤為基礎，再搭配App，而Android則是以觸控App為核心，兩者的市場模式不同並不會嘗試合併。\n\n在中國大陸的情況\n在中國大陸生產並售賣，或在境外生產、由當地代理商入口、在中國大陸售賣的裝有Android作業系統的智慧型手機（俗稱行貨），部分会把境外版常附帶的部分Google應用程式（包括Google服務框架）刪除，替換為中國大陸功能相同或相似的應用，即使這些裝置已獲得Google相容性認證及使用授權（CTS及GMS）。而部分手机（如搭载MIUI的小米手机）会在搭载Google服务框架的同时提供禁用的选项，以达到省电的需要。因此，中國大陸用戶往往需要自行重新安裝Google程式（部分品牌還需要將手機root之後重新刷入Google服務框架）才能使用Google相關的應用服務。能使用Google服務的標誌是可以在系統設置中的法律信息選項中找到“Google法律信息”選項。如果沒有，則此機已刪除Google服務框架。但通過非正式管道流入中國大陸販售市場的Android裝置（俗稱水貨），則基本不受此影響（但部分裝置的Android系統內則被一些非正規供貨商額外預裝了某些應用程式，可能會精簡Google服務框架等組件）。而在中國大陸生產，並在境外銷售的裝有Android作業系統的智慧型手機，亦不受此影響，但少數裝有Android作業系統的智慧型手機（例如華為近期推出的機型，由於美國制裁不能預裝Google服務），仍然需要自行重新安裝程式才能使用Google相關的應用服務。\n\n市場\nAndroid於2007年亮相時獲得的反應冷淡，雖然Google曾與備受尊敬的科技公司合作組建開放手機聯盟，分析師們對此留下深刻印象，但當時仍不清楚手機製造商是否願意用Android取代現有的作業系統。對於開源碼的想法，基於Linux開發平台引起了人們的興趣，但面對著來自智能手機市場的老牌企業（如諾基亞和微軟），以及正在開發中的Linux行動作業系統作為其競爭對手。這些老牌廠商持著懷疑的態度，諾基亞被引述說：「我們不認為這是一種威脅」，而微軟Windows Mobile團隊成員指「我不明白他們將會產生的影響」。\n從那時起，Android已經發展成為使用最廣泛的智能手機作業系統，及成為「最快的可用流動體驗之一」。評審強調了作業系統的開源性質是其定義優勢之一，它容許例如諾基亞（諾基亞X家族）、亞馬遜（Kindle Fire）、巴諾書店（Nook）、Ouya、百度及其他複刻軟件和發布他們運行自己的Android定製版本的硬體。結果是，科技網站《科技藝術》把其描述為：對於沒有自己的行動平臺的公司來說，「幾乎是推出新硬體的預設作業系統」。這種開放性和靈活性也出現在最終用戶的層面：Android容許裝置作廣泛的客製化，他們的擁有者及應用程式可以從非Google的應用程式商店和第三方網站中獲得。這些被引用為Android手機較其他手機的主要優勢之一。\n儘管Android很受歡迎，包括其激活率是iOS的三倍，有報告指Google仍未能利用他們的其他產品及網絡服務成功地將Android變成分析師所預期的賺錢機器。《The Verge》建議指由於廣泛的客製化及非Google應用程式及服務的激增，使Google正在失去對Android的控制權，亞馬遜的Kindle Fire系列使用的是Fire OS，這是一款經過大量修改的Android分支版本，它不包含或支援任何Google的專有組件，並要求用戶從Google Play商店的競爭對手亞馬遜應用商店中取得軟件。2014年，為了提高Android品牌的知名度，Google開始要求具有其專屬組件的裝置在啟動屏幕上顯示Android的標誌。\nAndroid遇到「碎片化」的情況，那是在各種Android裝置出現的情況，無論是硬件變化還是其運行軟件上的差異而言，讓開發整個生態系統中一致的應用程序任務較其競爭平台上硬件和軟件變化較少的iOS更難，例如，根據2013年7月的開源訊號，這裡有11,868個Android的裝置型號，眾多不同的屏幕尺寸，同時使用8種Android作業系統，而絕大多數的iOS用戶已升級到作業系統的最新版本。如AppleInsider的評論家斷言硬件和軟件的碎片化，推動著Android透過大量的低端、低價的產品使用舊版的Android使用率不斷上升。他們維持這一點，迫使Android開發人員編寫「最平庸的消費者群體」以取得盡可能多的用戶，然而他們在裝置上僅利用較少比例的最新硬件或軟件功能，這樣他們的動機似乎太少。然而，開發Android及iOS應用程式的OpenSignal得出的結論是，儘管碎片化的情況可能會使軟件開發更加棘手，然而Android在全球更廣泛的影響力增加了潛在的回報。\n\n市場份額\n2009年的第二季，市場研究公司Canalys估計，Android佔全球智能手機作業系統市場的2.8％。根據本土市場研究公司ComScore的數據顯示，2009年11月時，Android在美國的智慧型手機作業系統市場的佔有率為5.2%，在2010年2月時，這個數字變成了9.0%，而在2010年第三季度末時，Android已經佔據了美國市場的21.4%的份額。到了2010年5月，Android擁有全球智能手機市場的10％，超越了Windows Mobile，而在美國，Android佔有28％的份額，超越了iOS。在2010年第四季，其全球份額已經增長佔市場的33％，成為最暢銷的智能手機平台，超越了Symbian。根據comScore的數據，Android在美國於2011年4月成為最暢銷的平台，以31.2％的智能手機份額超越BlackBerry OS。\n對於第三方市場的流行，部份Android用戶不願意付費購買應用程式，轉而直接下載已被駭客破解的軟體。2010年8月，有遊戲開發者針對其作品進行的調查指出，在下載盜版方面，亞洲玩家佔97%，歐洲玩家佔70%，而北美玩家佔47%。\n截止至2011年6月，Google表示每天透過Google伺服器以激活的Android裝置多達到了55萬部，並且以每週4.4%的速度增長。2011年8月1日，Canalys的數據顯示，Android已佔據美國48%的智能手機市場的份額。\n2011年7月，Google表示每天有550,000個Android裝置被激活，高於5月份的每天有400,000個，在當時為止已超過1億個裝置被激活，每週增長4.4％。2012年9月，每天激活130萬個裝置，在當時為止已激活5億台裝置。截至2011年第三季，高德納估計超過一半（52.5％）的智能手機銷量是屬於Android的。\n2011年10月13日，Google表示全球市場上有1.9億部Android裝置透過Google認證，而在2011年11月16日，全球市場上已有2億部Android裝置透過Google認證。然而，配備Android作業系統的平板電腦在所有Android裝置中佔的比例卻只有1.8%，只有380萬Android蜂巢平板被售出，遠遠低於蘋果公司iPad的銷量。\nAndroid的市場會因地區而有差異。2012年5月，根據市場調查公司的數據顯示，Android於全球智能手機作業系統中的份額已經過半，達到了60%，即全球有一半的智能手機正在使用Android。2012年7月，美國使用Android「13歲以上的流動用戶」高達52％，在中國則上升至90％。2012年6月，Google在2012 Google I/O大會上表示全球市場上有4億部Android設備被啟動，每日啟動約100萬部。另一方面Android系統的平板電腦的市佔率為45.8%，相較之下iOS的市佔率為52.8%。截至2012年第三季，根據研究公司IDC的數據，Android佔據了75％的全球智能手機市場，總共有7.5億個裝置被激活，而在2013年4月，Android每天有150萬次激活。截至2013年5月 (2013-05)，Android在中國的市佔率為71.5%，超越其競爭對手蘋果公司的50%，在全世界的市佔率接近70%。；同時，Google Play商店中已有480億個應用程式經已被安裝；在Google I/O上，桑德爾·皮蔡宣布9億台Android裝置已被激活。2013年9月，已有10億個Android裝置被激活。2013年，Android系統的平板電腦市佔率高達61.9%，超過iOS的36%。\n在大多數市場中，包括美國，Android裝置佔智能手機銷量的一半以上，「只有在日本，蘋果公司才能名列前茅」（根據2013年9月至11月的數字）。在2013年底，自2010年的四年內已銷售超過15億部Android智能手機，使Android成為最暢銷的手機和平板電腦作業系統。預計到2014年底，Android智能手機將有30億個的銷售量（包括前幾年）。據Gartner研究公司稱，自2012年以來，Android的裝置每年都超越所有競爭者。在2013年，它超過了Windows的比率為2.8比1，或說是5.73億。截至2015年 (2015-Missing required parameter 1=month!)，Android擁有所有作業系統中最大的現有用戶群；自2013年以來，銷售並使用它的裝置也超過使用Windows、iOS及Mac OS X合併起來的數字。\n根據StatCounter，只是僅跟踪瀏覽網頁的用途，Android是自2013年8月以來最受歡迎的行動作業系統。Android在印度和其他幾個國家是最受歡迎的網頁瀏覽作業系統（除日本和朝鮮外，幾乎整個亞洲）。根據StatCounter，Android是在所有非洲國家中最多使用的行動裝置系統，它並表示「在一些國家中，手機使用率已經超越桌面，包括印度，南非和沙特阿拉伯」，幾乎所有非洲國家已經是這樣做了（包括埃及在內的7個國家除外），例如埃塞俄比亞和肯尼亞，其中包括平板電腦的行動使用率為90.46％（僅限Android佔所有用途的75.81％）。\n雖然西方世界中的Android手機通常包括Google專有的附加組件（如Google Play）到其他開源作業系統，然而在新興市場的事實並非如此；「ABI Research聲稱，在2014年第二季中，全球共有6,500萬個裝置使用開源的Android，高於第一季的5,400萬台」。\n根據2015年1月Gartner的報告指，「Android在2014年有超過了10億個裝置，並將於2015年繼續以雙位數字的速度增長，較去年同期增加了26％。」這是作業系統在一年內達到超過十億最終用戶的首次；在2014年達到接近11.6億的最終用戶，Android的出貨量超越iOS及OS X加起來的四倍，亦高於Microsoft Windows的三倍以上。Gartner預計整個手機市場將「在2016年達到20億個裝置」，當中包括了Android。法哈德·文奧描述統計數據，並於《紐約時報》中寫道：「今天所售出的每兩台電腦中，就有一台正在運行Android。 「它」已成為了世上主導的電腦平臺。」據高級分析軟件Statistica估計，2015年以Android作為智能手機安裝基礎的數量為18億個，這是預算全球智能手機總數的76％。根據2012年、2013年、2014年的銷售數字，Android擁有所有流動作業系統中最高的安裝量，並自2013年以來，成為了整體銷售最暢銷的作業系統，接近所有PC的安裝數字。\n2015年9月，Google宣布Android每月活躍用戶數量為1.4億，這在2017年5月每月活躍用戶上升變成2億。\n在2014年第二季，Android在全球智能手機出貨市場的份額為84.7％，創下了新紀錄。截至2016年第三季，全球市場份額已增長至87.5％，拋離其主要競爭對手的iOS只有12.1％的市場份額。\n截至2016年5月 (2016-05)，Google Play商店中的應用程式已下載超過65億次。截至2017年2月 (2017-02)，Google Play商店已發布了超過270萬個Android應用程式，作業系統的成功使技術公司之間興起所謂的「智能手機專利戰」的一部分，並使其成為專利訴訟的目標。根據StatCounter於2017年4月的報告，Android超越了Microsoft Windows，成為最受歡迎的總互聯網使用的作業系統。從那時起它一直保持著多元化。\n\n平台使用率\n平板電腦各作業系統比例\n用户使用系統版本比例\n此Android版本的細目表只根據截至2019年5月7日的七天內進入Google Play商店的裝置資料，因此，這些統計數據並不包括沒有進入Google Play商店的各種Android分支的裝置，例如是亞馬遜的Kindle Fire。\n\n截至2019年5月 (2019-05)，有80%的裝置已有OpenGL ES 3.0或更高的配置。\n\n專利糾紛\n盜版應用\n一般來說，付費的Android應用程式很容易被盜版。在2012年5月的《Eurogamer》的訪問中，《足球經理系列》的開發者表示，在他們的遊戲「掌上足球經理」上，盜版玩家與合法玩家的比例為9：1。然而，並非所有開發者都同意盜版率是一個問題；例如，在2012年7月，遊戲《上弦騎士》的開發者表示，他們的遊戲盜版率僅為12％，大部分盜版來自中國大陆，那裡的人們無法從Google Play購買應用程式。\n在2010年，Google發布了一款用於驗證在應用程式內使用授權購買的工具，但開發人員抱怨說對破解軟件而言，這是還不足夠及微不足道的。Google回應指該工具，特別是其初始版本，旨在作為開發人員根據他們的需求進行修改和構建的示例框架，而並非完整的盜版解決方案。Android的Jelly Bean引入了加密付費應用程式的功能，因此它們只能在購買它們的裝置上使用。\n\n專利爭議\n《PC世界》雜誌網站2011年9月22日報道，Android捲入1000多件專利訴訟中。\n2011年8月，Google斥資125億美元收購摩托羅拉移動（Motorola Mobility）及其擁有的約2.45萬份專利組合。\nAndroid的Gameloft應用程式打開後，必須透過安裝必備檔案來使用。\n\n與甲骨文公司的Java糾紛\n關於甲骨文公司就Android所使用的開發語言平臺Java為最引人關注的權利糾紛事件。\n2010年8月，甲骨文公司就開始對Google無授權使用Java語言實現侵犯了公司的專利在美國加州北區地方法院提起控訴，要求高達90億美元的賠償，其中牽涉了原供職於Sun公司的Java開發人員在轉職Google開發Android的Java實現使用了原公司的實現，API介面的實現是否具有專利版權性，Android的Java實現是否對甲骨文公司的Java移動平臺系列產品做成衝擊而形成不正當壟斷等問題。\n2012年5月的訴訟結果為陪審團支持Google的訴求，認為API只是系統或操作的方法，不受版權保護。2012年10月甲骨文公司上訴，2014年5月，美國聯邦巡迴上訴法院認為API屬於“電腦程序”仍受版權保護，判決Android侵犯了甲骨文公司Java的版權，但並不排除Google對其擁有合理使用性的權利。2014年10月Google向美國最高法院申請調卷令，請求最高院介入。2015年6月29日調卷令被拒絕，發往舊金山聯邦法院進行審理。\n2016年5月，舊金山聯邦法院陪審團認定Android實現Java的API命名結構屬於合理使用，不構成侵權，最終判Google勝訴。\n2016年8月22日，Google在Android 7.0 Nougat中將專利的JDK替換成開源方案的OpenJDK，以徹底解決Java的專利問題。\n2021年4月5日，美國聯邦最高法院以6票對2票的表決結果，裁定Google使用Java程式語言開發Android行動作業系統，屬「合理使用」，不構成侵權。\n該裁定認為Google在開發Android系統中，複製、使用部分Java API程式碼作為應用程式接口的行為，屬於憲法保障「創造性進步」原則的合理範圍。大法官史蒂芬·布雷耶指出，若將甲骨文所欲執行的主張進行明確立法將損害公眾利益，如同把電腦程式碼變成「限制未來應用程式實現創造力的枷鎖」。不過，對於API程式碼是否享有版權保護，最高法院並未作出明確回答。\n針對裁決，Google表示，這是「創新、相互操作性、電腦科學」一次共同的重大勝利，「更重要的是，API程式碼幾乎沒有創造力，只是開發人員用以調用、或是呼叫使用程式語言支持其他指令的一種速記，因此，對於侵權行為的主張是不合理的」。甲骨文則再次重申Google偷走Java程式碼的指控，並表示本次Google的勝利，「完全是基於Google在整個市場、經濟支配中的優勢地位」。\n\n分支平台\nWear OS\nWear OS是專為智慧型手表等可穿戴式設備所設計的一個Android系統分支。\n\nAndroid TV\nAndroid TV是專為家用電視所設計的一個Android系統分支。\n\nAndroid Auto\nAndroid Auto是專為汽車所設計的一個Android系統分支。\n\nAndroid Automotive\n是Android作業系統的變體，也是一款專為車輛儀錶板中的使用而量身定製系統分支。\n\nAndroid Go\nAndroid Go是針對低階裝置量身訂作的Android系統分支。\n\n品牌标识\n命名由來\nAndroid一詞最早出現於法國作家維利耶·德·利爾－阿達姆·利爾亞當（Auguste Villiers de l'Isle-Adam）在1886年發表的科幻小說《未來夏娃（L'Ève future）》中。他把外表像人的機器人取名為Android。\n\n標誌\nAndroid是一個全身綠色的機器人，半圓形的頭部，有兩支天線和空白的點作為眼睛。它的頭部與身體之間有空白的區域，相似於一枚有平底的雞蛋，兩側各有兩個圓角矩形，作為它的雙臂。Android的標誌是由Ascender公司設計，顏色採用了PMS 376C和RGB中十六進制的#A4C639來繪製，這是Android作業系統的品牌象徵。當中的文字使用了Ascender公司專門製作的稱之為“Google Droid”的字型。有時候，它會以純文字的標誌展示。\n\n吉祥物\nAndroid的吉祥物为绿色的Android机器人，设计者为Irina Blok。纽约时报的Pagan Kennedy在2013年发布了一篇关于Android机器人的文章。文中提到了Irina在设计Android机器人之初研究了许多科幻类玩具和太空电影。文章还指出Irina的最终灵感来自于厕所标志。厕所标志线条简洁，全世界的人都认识。Android机器人完美地继承了这些特性。\n\n參見\nAndroid歷史版本\nGoogle Play\n甲骨文诉谷歌Java侵权案\nLIMEIME\nGoogle Fuchsia\nTermux\nMagisk\n\n注釋\n參考文獻\n外部鏈接\n\n官方网站 （英文）\nAndroid开源計劃（页面存档备份，存于互联网档案馆）（英文）\nAndroid Developers（页面存档备份，存于互联网档案馆）（英文）\nAndroid-x86（页面存档备份，存于互联网档案馆）（英文）\nGoogle Projects for Android - Google Code（中文）\nYouTube上的Sergey Brin introduces the Android platform"}
{"title": "BIRCH", "text": "BIRCH（英文全称：balanced iterative reducing and clustering using hierarchies，中文：利用层次方法的平衡迭代规约和聚类）是一个非监督式分层聚类算法，于1996年由 Tian Zhang 提出。算法的优势在于能够利用有限的内存资源完成对大数据集的高质量的聚类。该算法通过构建聚类特征树（Clustering Feature Tree，简称CF Tree），在接下来的聚类过程中，直接对聚类特征进行聚类，而无需对原始数据集进行聚类。因此在多数情况下只需要扫描一次数据库即可进行聚类，IO成本与数据集尺寸呈线性关系。\n\n聚类特征树\n算法利用构建聚类特征树进行计算，树上的节点称作聚类特征（\n  \n     \n      \n        C\n        F\n      \n    \n    {\\displaystyle CF}\n  \n）。\n聚类特征为一个三维向量\n  \n    \n      \n        (\n        n\n        ,\n        L\n        S\n        ,\n        S\n        S\n        )\n      \n    \n    {\\displaystyle (n,LS,SS)}\n  \n，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n表示子类中节点的数目，\n  \n    \n      \n        L\n        S\n      \n    \n    {\\displaystyle LS}\n  \n表示\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个点的线性和，\n  \n    \n      \n        S\n        S\n      \n    \n    {\\displaystyle SS}\n  \n表示\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n个点的平方和。\n\n\n== 参考资料 =="}
{"title": "自然语言处理", "text": "自然語言處理（英語：Natural Language Processing，缩写作 NLP）是人工智慧和語言學領域的交叉學科，研究计算机处理、理解与生成人类语言的技術。此領域探討如何處理及運用自然語言；自然語言處理包括多方面和步骤，基本有认知、理解、生成等部分。\n自然語言認知和理解是讓電腦把输入的語言变成结构化符号与语义关系，然后根据目的再處理。自然語言生成系統则是把計算機數據轉化為自然語言。\n自然语言处理要研制表示语言能力和语言应用的模型, 建立计算框架来实现并完善语言模型，并根据语言模型设计各种实用系统及探讨这些系统的评测技术。\n\n歷史\n自然語言處理大體是從1950年代開始，雖然更早期也有作為。1950年，艾伦·图灵發表論文「計算機器與智能」，提出現在所謂的「圖靈測試」作為判斷智能的條件。\n1954年的乔治城-IBM实验涉及全部自動翻譯超過60句俄文成為英文。研究人員聲稱三到五年之內即可解決機器翻譯的問題。不過實際進展遠低於預期，1966年的ALPAC報告發現十年研究未達預期目標，機器翻譯的研究經費遭到大幅削減。一直到1980年代末期，統計機器翻譯系統發展出來，機器翻譯的研究才得以更上一層樓。\n1960年代發展特別成功的NLP系統包括SHRDLU——一個詞彙設限、運作於受限如「積木世界」的一種自然語言系統，以及1964-1966年约瑟夫·维森鲍姆模擬「個人中心治療」而設計的ELIZA——幾乎未運用人類思想和感情的訊息，有時候卻能呈現令人訝異地類似人之間的互動。「病人」提出的問題超出ELIZA 極小的知識範圍之時，可能會得到空泛的回答。例如問題是「我的頭痛」，回答是「為什麼說你頭痛？」\n1970年代，程式設計師開始設計「概念本體論」（conceptual ontologies）的程式，將現實世界的資訊，架構成電腦能夠理解的資料。實例有MARGIE、SAM、PAM、TaleSpin、QUALM、Politics以及Plot Unit。許多聊天機器人在這一時期寫成，包括PARRY 、Racter 以及Jabberwacky 。\n一直到1980年代，多數自然語言處理系統是以一套複雜、人工訂定的規則為基礎。不過從1980年代末期開始，語言處理引進了機器學習的演算法，NLP產生革新。成因有兩個：運算能力穩定增加（參見摩爾定律）；以及喬姆斯基語言學理論漸漸喪失主導（例如轉換-生成文法）。該理論的架構不傾向於語料庫——機器學習處理語言所用方法的基礎。有些最早期使用的機器學習演算法，例如決策樹，是硬性的、「如果-則」規則組成的系統，類似當時既有的人工訂定的規則。不過詞性標記將隱馬爾可夫模型引入NLP，並且研究日益聚焦於軟性的、以機率做決定的統計模型，基礎是將輸入資料裡每一個特性賦予代表其份量的數值。許多語音識別現今依賴的快取語言模型即是一種統計模型的例子。這種模型通常足以處理非預期的輸入數據，尤其是輸入有錯誤（真實世界的數據總免不了），並且在整合到包含多個子任務的較大系統時，結果比較可靠。\n許多早期的成功屬於機器翻譯領域，尤其歸功IBM的研究，漸次發展出更複雜的統計模型。這些系統得以利用加拿大和歐盟現有的語料庫，因為其法律規定政府的會議必須翻譯成所有的官方語言。不過，其他大部分系統必須特別打造自己的語料庫，一直到現在這都是限制其成功的一個主要因素，於是大量的研究致力於從有限的數據更有效地學習。\n近來的研究更加聚焦於非監督式學習和半監督學習的演算法。這種演算法，能夠從沒有人工註解理想答案的資料裡學習。大體而言，這種學習比監督學習困難，並且在同量的數據下，通常產生的結果較不準確。不過沒有註解的數據量極巨（包含了全球資訊網），彌補了較不準確的缺點。\n2011年以来，深度學習技巧紛紛出爐在自然語言處理方面獲得最尖端的成果，例如語言模型、語法分析等等。2017年Transformer模型诞生；2018年BERT模型推出，提出了预训练的方法。\n2022年底，随着ChatGPT等大型语言模型的推出，自然语言处理的重点从自然语言理解转向了自然语言生成。\n\n历史发展（按技术范式划分）\n1. 规则驱动时期（1950s-1980s）\n1950年：艾伦·图灵提出「图灵测试」，奠定NLP理论基础。\n1954年：乔治城-IBM实验首次实现俄英机器翻译，但过度乐观的预期导致1966年ALPAC报告后经费削减。 （修改说明：补充技术挫折背景）\n1960s代表性系统：\nSHRDLU（受限积木世界对话）\nELIZA（模拟心理治疗的聊天机器人），其模式匹配应答机制暴露早期NLP的局限性。\n\n2. 统计方法兴起（1980s-2010s）\n关键转折：摩尔定律提升算力 + 乔姆斯基理论式微 → 机器学习成为主流。\n技术突破：隐马尔可夫模型（词性标注）、统计机器翻译（IBM主导）。 （修改说明：明确技术关联性）\n\n3. 深度学习时代（2011年至今）\n2017年：Transformer架构诞生[8]，解决长距离依赖问题。 （修改说明：补充架构意义）\n2018年：BERT提出预训练范式[9]，推动迁移学习在NLP的应用。\n\n用途\n在許多情況下，學者們需要通過許多不同的數據庫來確定新的研究方向，以識別研究差距並確定迄今為止尚未研究的領域。檢查所有電子數據庫很麻煩，而且經常會遺漏重要的部分。通過使用網絡抓取和自然語言處理來縮短識別研究差距所需的時間。在Google學術搜索上索引的出版物的標題, 自然语言处理標記化(Tokenization)從最高頻率到最低頻率對搭配進行排序。因此，自然语言处理標記化(Tokenization)確定了標題中未提及的關鍵字集，並將最初的想法確定為研究空白。\n\n任務和限制\n理論上，NLP是一種很吸引人的人機交互方式。早期的语言处理系统如SHRDLU，当它们处于一个有限的“积木世界”，运用有限的词汇表会话时，工作得相当好。这使得研究员们对此系统相当乐观，然而，当把这个系统拓展到充满了现实世界的含糊与不确定性的环境中时，他们很快丧失了信心。\n由於理解（understanding）自然語言，需要關於外在世界的廣泛知識以及運用操作這些知識的能力，自然語言認知，同時也被視為一個人工智慧完備（AI-complete）的問題。同時，在自然語言處理中，“理解”的定義也變成一個主要的問題。\n\n實際問題\n一些NLP面臨的問題實例：\n\n句子“我們把香蕉給猴子，因為（牠們）餓了”和“我們把香蕉給猴子，因為（它們）熟透了”有同樣的結構。但是代詞“它們”在第一句中指的是“猴子”，在第二句中指的是“香蕉”。如果不了解猴子和香蕉的屬性，無法區分。（简体中文和英文的它/it沒有區分，但在正體中文裡「牠」和「它」是有區別的，只是代詞在中文裡常常被省略，因此需區別屬性並且標示出來）\n不少的中文相關笑話即是利用類似結構的中文造句而成，此類笑話通常帶有“中文博大精深”之類的詞彙，敘述多以老外參加考試為背景。例子如下：\n\n自然語言處理研究的難點\n單詞的邊界界定\n在口語中，詞與詞之間通常是連貫的，而界定字詞邊界通常使用的辦法是取用能讓給定的上下文最為通順且在文法上無誤的一種最佳組合。在書寫上，漢語也沒有詞與詞之間的邊界。\n\n詞義的消歧\n許多字詞不單只有一個意思，因而我們必須選出使句意最為通順的解釋。\n\n句法的模糊性\n自然語言的文法通常是模稜兩可的，針對一個句子通常可能會剖析（Parse）出多棵分析树（Parse Tree），而我們必須要仰賴語意及前後文的資訊才能在其中選擇一棵最為適合的剖析樹。\n\n有瑕疵的或不規範的輸入\n例如語音處理時遇到外國口音或地方口音，或者在文本的處理中處理拼寫，語法或者光學字元識別（OCR）的錯誤。\n\n语言行为与计划\n句子常常并不只是字面上的意思；例如，“你能把盐递过来吗”，一个好的回答应当是動手把盐递过去；在大多数上下文环境中，“能”将是糟糕的回答，虽说回答“不”或者“太远了我拿不到”也是可以接受的。再者，如果一门课程去年没开设，对于提问“这门课程去年有多少学生没通过？”回答“去年没开这门课”要比回答“没人没通过”好。\n\n当前自然语言处理研究的发展趋势\n第一，传统的基于句法-语义规则的理性主义方法过于复杂，随着语料库建设和语料库语言学的崛起，大规模真实文本的机器学习处理成为自然语言处理的主要选择。\n第二，统计数学方法越来越受到重视，自然语言处理中越来越多地使用机器自动学习的方法来获取语言知识。\n第三，浅层处理与深层处理并重，统计与规则方法并重，形成混合式的系统。\n第四，自然语言处理中越来越重视词汇的作用，出现了强烈的“词汇主义”的倾向。词汇知识库的建造成为了普遍关注的问题。\n\n統計自然語言處理\n統計自然語言處理運用了推測學、機率、統計的方法來解決上述，尤其是針對容易高度模糊的長串句子，當套用實際文法進行分析產生出成千上萬筆可能性時所引發之難題。處理這些高度模糊句子所採用消歧的方法通常運用到語料庫（Corpus）以及馬可夫模型（Markov models）。統計自然語言處理的技術主要由同樣自人工智慧下與學習行為相關的子領域：機器學習及資料採掘所演進而成。\n\n主要範疇\n文本朗讀（Text to speech）\n語音合成（Speech synthesis）\n語音識別（Speech recognition）\n斷詞／分詞（Text segmentation/Word tokenization）\n中文自动分词（Chinese word segmentation）\n語法分析／剖析（Syntactic analysis/Parsing）\n漢語自動句法分析\n詞彙標示框架（Lexical Markup Framework）\nn元语法（n-gram）\n詞嵌入（Word2vec）\n词性标注（Part-of-speech tagging）\n文檔分類（Document classification）\n自然語言生成（Natural language generation）\n文本分类（Text categorization）\n信息检索（Information retrieval）\n信息抽取（Information extraction）\n文字校對（Text-proofing）\n問答系統（Question answering）\n給一句人類語言的问句，決定其答案。 典型問題有特定答案（像是加拿大的首都叫什麼？），但也考慮些開放式問句（像是人生的意義是是甚麼？）\n聊天機器人（ChatBot）\n对话系统（Dialogue system）\n機器翻譯（Machine translation）\n將某種人類語言自動翻譯至另一種語言\n自動摘要（Automatic summarization）\n產生一段文字的大意，通常用於提供已知領域的文章摘要，例如產生報紙上某篇文章之摘要\n文字蘊涵（Textual entailment）\n命名实体识别（Named entity recognition, NER）\n主题模型（Topic Model）\n文本情感分析（Sentiment analysis）\n語意分析（Semantic analysis）\n潛在語義學（Latent Semantic Analysis）\n詞袋模型（Bag-of-words model）\n標籤雲（Tag Cloud）\n自然语言理解（Natural Language Understanding）\n形态分析\n\n参见\n参考文献\n延伸閱讀\n外部連結\n\n人類語言技術當前發展情況概覽\n哥倫比亞大學自然語言處理研究組 （页面存档备份，存于互联网档案馆）\n卡内基梅隆大学語言技術研究院 （页面存档备份，存于互联网档案馆）\n斯坦福大學自然語言處理研究小組 （页面存档备份，存于互联网档案馆）\n中文自然語言處理開放平臺 （页面存档备份，存于互联网档案馆）\nACL（美國電腦語言學協會）提供的相關雜誌以及研討會的論文\nGATE: a Java Library for Text Engineering （页面存档备份，存于互联网档案馆）\nLTP:语言技术平台（简体中文）\nPython編程語言的自然語言處理工具包教程 （页面存档备份，存于互联网档案馆）\nfastNLP （页面存档备份，存于互联网档案馆）"}
{"title": "计算机视觉", "text": "计算机视觉（Computer vision）是一门研究如何使机器“看”的科学，更进一步的说，就是指用摄像机和计算机代替人眼对目标进行识别、跟踪和测量等机器视觉，并进一步做图像处理，用计算机处理成为更适合人眼观察或传送给仪器检测的图像。\n作为一門科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取「信息」的人工智能系统。这里所指的信息指香农定义的，可以用来帮助做一个“决定”的信息。因为感知可以看作是从感官信号中提取信息，所以计算机视觉也可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学。\n作为一个工程学科，计算机视觉寻求基于相关理论与模型来建立计算机视觉系统。这类系统的组成部分包括：\n\n过程控制（例如工业机器人和无人驾驶汽车）\n事件监测（例如图像监测）\n信息组织（例如图像数据库和图像序列的索引建立）\n物体与环境建模（例如工业检查，医学图像分析和拓扑建模）\n交互（如“人机互动的输入设备”）\n计算机视觉同样可以被看作是生物视觉的一个补充。在生物视觉领域中，人类和各种动物的视觉都得到了研究，从而建立了这些视觉系统感知信息过程中所使用的物理模型。另一方面，在计算机视觉中，靠软件和硬件实现的人工智能系统得到了研究与描述。生物视觉与计算机视觉进行的学科间交流为彼此都带来了巨大价值。\n计算机视觉包含如下一些分支：画面重建，事件监测，目标跟踪，目标识别，机器学习，索引建立，图像恢复等。\n计算机视觉是一门通过算法解析图像或多维数据，模拟人类视觉感知的科学。其核心任务是实现目标的识别、跟踪、测量及场景理解，并生成可供决策的信息（Shannon, 1948）。作为交叉学科，它融合了人工智能、信号处理、物理学和神经科学等领域的方法论。\n\n计算机视觉的发展现状\n计算机视觉领域的突出特点是其多样性与不完善性。\n这一领域的先驱可追溯到更早的时候，但是直到20世纪70年代后期，当计算机的性能提高到足以处理诸如图像这样的大规模数据時，计算机视觉才得到了正式的关注和发展。然而这些发展往往起源于其他不同领域的需要，因而何謂“计算机视觉問題”始终没有得到正式定义，很自然地，“计算机视觉问题”应当被如何解决也没有成型的公式。\n儘管如此，人们已開始掌握部分解决具体计算机视觉任务的方法，可惜这些方法通常都僅適用於一群狹隘的目標（如：臉孔、指紋、文字等），因而无法被廣泛地应用於不同場合。\n对这些方法的应用通常作为某些解决复杂问题的大规模系统的一个组成部分（例如医学图像的处理，工业制造中的质量控制与测量）。在计算机视觉的大多数实际应用当中，计算机被预设为解决特定的任务，然而基于机器学习的方法正日渐普及，一旦機器學習的研究進一步發展，未來「泛用型」的電腦視覺應用或許可以成真。\n人工智能所研究的一个主要问题是：如何让系统具备「计划」和「决策能力」？从而使之完成特定的技术动作（例如：移动一个机器人通过某种特定环境）。这一问题便與计算机视觉問題息息相關。在这里，计算机视觉系统作为一个感知器，为决策提供信息。另外一些研究方向包括模式识别和机器学习（這也隶属于人工智能領域，但与计算机视觉有着重要联系），也由此，计算机视觉時常被看作人工智能與计算机科学的一个分支。\n物理是与计算机视觉有着重要联系的另一领域。\n计算机视觉关注的目标在于充分理解电磁波——主要是可见光与红外线部分——遇到物体表面被反射所形成的图像，而这一过程便是基于光学物理和固態物理，一些尖端的图像传感器甚至会应用到量子力学理论，来解析影像所表示的真實世界。同时，物理学中的很多测量难题也可以通过计算机视觉得到解决，例如流体运动。也由此，计算机视觉同样可以被看作是物理学的拓展。\n另一个具有重要意义的领域是神经生物学，尤其是其中生物视觉系统的部分。\n在整个20世纪中，人類對各种动物的眼睛、神经元、以及与视觉刺激相关的脑部组织都進行了广泛研究，这些研究得出了一些有关“天然的”视觉系统如何運作的描述（尽管仍略嫌粗略），这也形成了计算机视觉中的一个子领域——人们试图建立人工系统，使之在不同的复杂程度上模拟生物的视觉運作。同时计算机视觉领域中，一些基于机器学习的方法也有參考部分生物機制。\n计算机视觉的另一个相关领域是信号处理。很多有关单元变量信号的处理方法，尤其对是时变信号的处理，都可以很自然的被扩展为计算机视觉中对二元变量信号或者多元变量信号的处理方法。但由于图像数据的特有属性，很多计算机视觉中发展起来的方法，在单元信号的处理方法中却找不到对应版本。这类方法的一个主要特征，便是他们的非线性以及图像信息的多维性，以上二點作为计算机视觉的一部分，在信号处理学中形成了一个特殊的研究方向。\n除了上面提到的領域，很多研究课题同样可被当作纯粹的数学问题。例如，计算机视觉中的很多问题，其理论基础便是统计学，最优化理论以及几何学。\n如何使既有方法通过各种软硬件实现，或说如何对这些方法加以修改，而使之获得合理的执行速度而又不损失足够精度，是现今计算机视觉领域的主要课题。\n\n相邻领域的异同\n计算机视觉，图像处理，图像分析，机器人视觉和机器视觉是彼此紧密关联的学科。如果你翻开带有上面这些名字的教材，你会发现在技术和应用领域上他们都有着相当大部分的重叠。这表明这些学科的基础理论大致是相同的，甚至让人怀疑他们是同一学科被冠以不同的名称。\n然而，各研究机构，学术期刊，会议及公司往往把自己特别的归为其中某一个领域，于是各种各样的用来区分这些学科的特征便被提了出来。下面将给出一种区分方法，尽管并不能说这一区分方法完全准确。\n计算机视觉的研究对象主要是映射到单幅或多幅图像上的三维场景，例如三维场景的重建。计算机视觉的研究很大程度上针对图像的内容。\n图像处理与图像分析的研究对象主要是二维图像，实现图像的转化，尤其针对像素级的操作，例如提高图像对比度，边缘提取，去噪声和几何变换如图像旋转。这一特征表明无论是图像处理还是图像分析其研究内容都和图像的具体内容无关。\n机器视觉主要是指工业领域的视觉研究，例如自主机器人的视觉，用于检测和测量的视觉。这表明在这一领域通过软件硬件，图像感知与控制理论往往与图像处理得到紧密结合来实现高效的机器人控制或各种实时操作。\n模式识别使用各种方法从信号中提取信息，主要运用统计学的理论。此领域的一个主要方向便是从图像数据中提取信息。\n还有一个领域被称为成像技术。这一领域最初的研究内容主要是制作图像，但有时也涉及到图像分析和处理。例如，医学成像就包含大量的医学领域的图像分析。\n对于所有这些领域，一个可能的过程是你在计算机视觉的实验室工作，工作中从事着图象处理，最终解决了机器视觉领域的问题，然后把自己的成果发表在了模式识别的会议上。\n与人工智能的关系：计算机视觉为AI系统提供环境感知能力，尤其在自动驾驶和机器人规划中。模式识别与机器学习是其关键技术支撑。\n与物理学的关联：光的反射模型和传感器物理特性（如CCD量子效率）直接影响成像质量。\n\n计算机视觉的经典问题\n几乎在每个计算机视觉技术的具体应用都要解决一系列相同的问题。这些经典的问题包括：\n\n识别\n一个计算机视觉，图像处理和机器视觉所共有的经典问题便是判定一组图像数据中是否包含某个特定的物体，图像特征或运动状态。这一问题通常可以通过机器自动解决，但是到目前为止，还没有某个单一的方法能够广泛的对各种情况进行判定：在任意环境中识别任意物体。现有技术能够也只能够很好地解决特定目标的识别，比如简单几何图形识别，人脸识别，印刷或手写文件识别或者车辆识别。而且这些识别需要在特定的环境中，具有指定的光照，背景和目标姿态要求。\n广义的识别在不同的场合又演化成了几个略有差异的概念：\n\n识别（狭义的）：对一个或多个经过预先定义或学习的物体或物类进行辨识，通常在辨识过程中还要提供他们的二维位置或三维姿态。\n鉴别：识别辨认单一物体本身。例如：某一人脸的识别，某一指纹的识别。\n监测：从图像中发现特定的情况内容。例如：医学中对细胞或组织不正常技能的发现，交通监视仪器对过往车辆的发现。监测往往是通过简单的图象处理发现图像中的特殊区域，为后继更复杂的操作提供起点。\n识别的几个具体应用方向：\n\n基于内容的图像提取：在巨大的图像集合中寻找包含指定内容的所有图片。被指定的内容可以是多种形式，比如一个红色的大致是圆形的图案，或者一辆自行车。在这里对后一种内容的寻找显然要比前一种更复杂，因为前一种描述的是一个低级直观的视觉特征，而后者则涉及一个抽象概念（也可以说是高级的视觉特征），即‘自行车’，显然的一点就是自行车的外观并不是固定的。\n姿态评估：对某一物体相对于摄像机的位置或者方向的评估。例如：对机器臂姿态和位置的评估。\n光学字符识别对图像中的印刷或手写文字进行识别鉴别，通常的输出是将之转化成易于编辑的文档形式。\n\n运动\n基于序列图像的对物体运动的监测包含多种类型，诸如：\n\n自体运动：监测摄像机的三维刚性运动。\n图像跟踪：跟踪运动的物体。\n\n场景重建\n给定一个场景的二或多幅图像或者一段录像，场景重建寻求为该场景建立一个三维模型。最简单的情况便是生成一组三维空间中的点。更复杂的情况下会建立起完整的三维表面模型。\n\n图像恢复\n图像恢复的目标在于移除图像中的噪声，例如仪器噪声、動態模糊等。\n\n计算机视觉系统\n计算机视觉系统的结构形式很大程度上依赖于其具体应用方向。有些是独立工作的，用于解决具体的测量或检测问题；也有些作为某个大型复杂系统的组成部分出现，比如和机械控制系统，数据库系统，人机接口设备协同工作。计算机视觉系统的具体实现方法同时也由其功能决定——是预先固定的抑或是在运行过程中自动学习调整。尽管如此，有些功能却几乎是每个计算机系统都需要具备的：\n\n图像获取：一幅数字图像是由一个或多个图像传感器产生，这里的传感器可以是各种光敏摄像机，包括遥感设备，X射线断层摄影仪，雷达，超声波接收器等。取决于不同的传感器，产生的图片可以是普通的二维图像，三维图组或者一个图像序列。图片的像素值往往对应于光在一个或多个光谱段上的强度（灰度图或彩色图），但也可以是相关的各种物理数据，如声波，电磁波或核磁共振的深度，吸收度或反射度。\n预处理：在对图像实施具体的计算机视觉方法来提取某种特定的信息前，一种或一些预处理往往被采用来使图像满足后继方法的要求。例如：\n二次取样保证图像坐标的正确\n平滑去噪来滤除传感器引入的设备噪声\n提高对比度来保证实现相关信息可以被检测到\n调整尺度空间使图像结构适合局部应用\n特征提取：从图像中提取各种复杂度的特征。例如：\n线、边缘提取和脊偵測\n局部化的特征点检测如边角检测、斑点检测\n更复杂的特征可能与图像中的纹理形状或运动有关。\n检测/分割：在图像处理过程中，有时会需要对图像进行分割来提取有价值的用于后继处理的部分，例如：\n筛选特征点\n分割一或多幅图片中含有特定目标的部分\n高级处理：到了这一步，数据往往具有很小的数量，例如图像中经先前处理被认为含有目标物体的部分。这时的处理包括：\n验证得到的数据是否符合前提要求\n估测特定系数，比如目标的姿态、体积\n对目标进行分类\n\n影響視覺系統的要件\n光源佈局影響大需審慎考量。\n正確的選擇鏡組，考量倍率、空間、尺寸、失真。\n選擇合適的攝影機（CCD），考量功能、規格、穩定性、耐用。\n視覺軟體開發需靠經驗累積，多嘗試、思考問題的解決途徑。\n以創造精度的不斷提升，縮短處理時間為最終目標。\n\n参考文献\n外部連結\nMachine Perception of Three-Dimensional Solids - the paper mentioned by Joseph Mundy in the video\nCVonline: The Evolving, Distributed, Non-Proprietary, On-Line Compendium of Computer Vision （页面存档备份，存于互联网档案馆）\nIntroduction to computer vision（464KB pdf file）\nCMU's Computer Vision Homepage（页面存档备份，存于互联网档案馆）\nFudan University's Computer Vision Lab（页面存档备份，存于互联网档案馆）\nKeith Price's Annotated Computer Vision Bibliography（页面存档备份，存于互联网档案馆） and the Official Mirror Site Keith Price's Annotated Computer Vision Bibliography（页面存档备份，存于互联网档案馆）\nHIPR2 image processing teaching package（页面存档备份，存于互联网档案馆）\nUSC Iris computer vision conference list（页面存档备份，存于互联网档案馆）\nHow to come up with new research ideas in computer vision? (in Chinese)（页面存档备份，存于互联网档案馆）\nPeople in Computer Vision（页面存档备份，存于互联网档案馆）\nThe Computer Vision Genealogy Project（页面存档备份，存于互联网档案馆）\n\n參見\n\n機器視覺\n人工智能与模式识别\n图像处理\n自動光學檢查\n开放源代码计算机视觉库：OpenCV"}
{"title": "强化学习", "text": "强化学习（英語：Reinforcement learning，簡稱RL）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。强化学习是除了监督学习和非监督学习之外的第三种基本的机器学习方法。与监督学习不同的是，强化学习不需要带标签的输入输出对，同时也无需对非最优解的精确地纠正。其关注点在于寻找（对未知领域的）探索和（对已有知识的）利用的平衡，强化学习中的“探索-利用”的交换，在多臂赌博机问题和有限MDP中研究得最多。\n其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多智能体系统、群体智能、统计学以及遗传算法。在运筹学和控制理论研究的语境下，强化学习被称作“近似动态规划”（approximate dynamic programming，ADP）。在最优控制理论中也有研究这个问题，虽然大部分的研究是关于最优解的存在和特性，并非是学习或者近似方面。在经济学和博弈论中，强化学习被用来解释在有限理性的条件下如何出现平衡。\n在強化学习问题中，智能體（agent）與环境的交互通常被抽象为马尔可夫决策过程（Markov decision processes，MDP），因为很多强化学习算法在这种假设下才能使用动态规划的方法。传统的动态规划方法和强化学习算法的主要区别是，后者不需要关于MDP的知识，而且针对无法找到确切方法的大规模MDP。\n对于时刻\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n下觀測（observation）\n  \n    \n      \n        \n          o\n          \n            t\n          \n        \n        ∈\n        O\n      \n    \n    {\\displaystyle o_{t}\\in O}\n  \n與環境實際狀態\n  \n    \n      \n        \n          s\n          \n            t\n          \n        \n        ∈\n        S\n      \n    \n    {\\displaystyle s_{t}\\in S}\n  \n的關係，MDP可以被分為：\n\n完全可观测MDP，若\n  \n    \n      \n        \n          o\n          \n            t\n          \n        \n        =\n        \n          s\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle o_{t}=s_{t}}\n  \n\n部分可观测MDP (POMDP)，若\n  \n    \n      \n        \n          o\n          \n            t\n          \n        \n        ⊂\n        \n          s\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle o_{t}\\subset s_{t}}\n  \n\n對於Q-learning，其對應的策略\n  \n    \n      \n        π\n      \n    \n    {\\displaystyle \\pi }\n  \n可被定義為：\n\n  \n    \n      \n        π\n        (\n        a\n        |\n        s\n        )\n        =\n        \n          \n            \n              e\n              \n                Q\n                (\n                s\n                ,\n                a\n                )\n                \n                  /\n                \n                τ\n              \n            \n            \n              \n                ∑\n                \n                  \n                    a\n                    \n                      ′\n                    \n                  \n                  ∈\n                  A\n                \n              \n              \n                e\n                \n                  Q\n                  (\n                  s\n                  ,\n                  \n                    a\n                    \n                      ′\n                    \n                  \n                  )\n                  \n                    /\n                  \n                  τ\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\pi (a\\vert s)={\\frac {e^{Q(s,a)/\\tau }}{\\sum _{a^{\\prime }\\in A}e^{Q(s,a^{\\prime })/\\tau }}}}\n  \n\n其中\n  \n    \n      \n        τ\n        ∈\n        \n          \n            R\n          \n          \n            +\n          \n        \n      \n    \n    {\\displaystyle \\tau \\in \\mathbb {R} ^{+}}\n  \n为温度参数，用於控制策略的隨機程度。\n  \n    \n      \n        τ\n      \n    \n    {\\displaystyle \\tau }\n  \n趨於0時，策略趨於貪心策略（\n  \n    \n      \n        \n          \n            a\n            r\n            g\n            m\n            a\n            x\n          \n          \n            a\n            ∈\n            A\n          \n        \n        Q\n        (\n        s\n        ,\n        a\n        )\n      \n    \n    {\\displaystyle \\mathrm {argmax} _{a\\in A}Q(s,a)}\n  \n）；\n  \n    \n      \n        τ\n      \n    \n    {\\displaystyle \\tau }\n  \n趨於正無窮時，策略趨於均勻隨機。\n\n介绍\n由于其通用性很强，强化学习已经在诸如博弈论、控制论、运筹学、信息论、仿真优化、多智能体系统、群体智能和统计学等领域有了深入研究。在运筹学和控制文献中，强化学习被称为近似动态规划或神经动态规划。强化学习所感兴趣的问题在最优控制（一种关注最优解的存在性、表示和求解的理论，但较少涉及学习和近似）中也有所研究，尤其是环境的数学模型难以求得的时候。在经济学和博弈论中，强化学习可能被用来解释在有限的理性（rationality）下如何达到平衡状态。\n基本的强化学习被建模为马尔可夫决策过程：\n\n环境状态的集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n;\n动作的集合\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n;\n在状态之间转换的规则（转移概率矩阵）\n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n；\n规定转换后“即时奖励”的规则（奖励函数）\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n；\n描述主体能够观察到什么的规则。\n规则通常是帶有随机性的。主体通常可以观察即时奖励和最后一次转换。在许多模型中，主体被假设为可以观察现有的环境状态，这种情况称为“完全可观测”（full observability），反之则称为“部分可观测”（partial observability）。通常，主体被允许的动作是有限的，例如，在棋盤中棋子只能上、下、左、右移動，或是使用的钱不能多于所拥有的。\n强化学习的主体与环境基于离散的时间步作用。在每一个时间\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n，主体接收到一个观测\n  \n    \n      \n        \n          o\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle o_{t}}\n  \n，通常其中包含奖励\n  \n    \n      \n        \n          r\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle r_{t}}\n  \n。然后，它从允许的集合中选择一个动作\n  \n    \n      \n        \n          a\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle a_{t}}\n  \n，然后送出到环境中去。环境则变化到一个新的状态\n  \n    \n      \n        \n          s\n          \n            t\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle s_{t+1}}\n  \n，然后决定了和这个变化\n  \n    \n      \n        (\n        \n          s\n          \n            t\n          \n        \n        ,\n        \n          a\n          \n            t\n          \n        \n        ,\n        \n          s\n          \n            t\n            +\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle (s_{t},a_{t},s_{t+1})}\n  \n相关联的奖励\n  \n    \n      \n        \n          r\n          \n            t\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle r_{t+1}}\n  \n。强化学习主体的目标，是得到尽可能多的預期回報（return），其可以為獎勵\n  \n    \n      \n        \n          ∑\n          \n            t\n          \n        \n        \n          r\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle \\sum _{t}r_{t}}\n  \n、帶折扣的回報（discounted return）\n  \n    \n      \n        ∑\n        \n          r\n          \n            t\n          \n        \n        ⋅\n        \n          γ\n          \n            t\n          \n        \n      \n    \n    {\\displaystyle \\sum r_{t}\\cdot \\gamma ^{t}}\n  \n，其中\n  \n    \n      \n        γ\n        ∈\n        (\n        0\n        ,\n        1\n        ]\n      \n    \n    {\\displaystyle \\gamma \\in (0,1]}\n  \n為回報因子，表示對短期獎勵的鼓勵。主体选择的动作是其历史的函数，它也可以选择随机的动作。\n将这个主体的表现和自始自终以最优方式行动的主体相比较，它们之间的行动差异产生了“悔过”的概念。如果要接近最优的方案来行动，主体必须根据它的长时间行动序列进行推理：例如，要最大化我的未来收入，我最好现在去上学，虽然这样行动的即时货币奖励为负值。\n因此，强化学习对于包含长期反馈的问题比短期反馈的表现更好。它在许多问题上得到应用，包括机器人控制、电梯调度、电信通讯，AlphaGo（蒙特卡洛树搜索+RL）和星际争霸II AI（AlphaStar）。\n强化学习的强大能力来源于两个方面：使用样本来优化行为，使用函数近似来描述复杂的环境。它们使得强化学习可以使用在以下的复杂环境中：\n\n模型的环境已知，且解析解不存在；\n仅仅给出环境的模拟模型（模拟优化方法的问题）\n从环境中获取信息的唯一办法是和它互动。前两个问题可以被考虑为规划问题，而最后一个问题可以被认为是genuine learning问题。使用强化学习的方法，这两种规划问题都可以被转化为机器学习问题。\n策略迭代（Policy Iteration）是RL中策略梯度法的理论基础\n值迭代（Value Iteration）与Q-learning存在收敛性等价证明\n\n常用算法\n蒙特卡洛学习 Monte-Carlo Learning\nTemporal-Difference Learning\nSARSA算法\nQ学习\n\n现代基准补充\n探索机制\n强化学习需要比较聪明的探索机制，直接随机的对动作进行采样的方法性能比较差。虽然小规模的马氏过程已经被认识的比较清楚，这些性质很难在状态空间规模比较大的时候适用，这个时候相对简单的探索机制是更加现实的。\n其中的一种方法就是 \n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n-貪婪演算法，这种方法会以比较大的概率(1-\n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n)去选择现在最好的动作。如果没有选择最优动作，就在剩下的动作中随机选择一个。\n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n 在这里是一个可调节的参数，更小的 \n  \n    \n      \n        ϵ\n      \n    \n    {\\displaystyle \\epsilon }\n  \n 意味着算法会更加贪心。\n\n前沿方向补遗\n多智能体RL  引入Nash Q-learning框架：\n  \n    \n      \n        \n          Q\n          \n            i\n          \n        \n        \n          π\n          \n            ⋆\n          \n        \n        (\n        s\n        ,\n        a\n        )\n        =\n        \n          r\n          \n            i\n          \n        \n        +\n        γ\n        \n          s\n          \n            ′\n          \n        \n        \n          ∑\n          \n            \n              s\n              \n                ′\n              \n            \n          \n        \n        P\n        (\n        \n          s\n          \n            ′\n          \n        \n        |\n        s\n        ,\n        a\n        )\n        \n          V\n          \n            i\n          \n        \n        \n          π\n          \n            ⋆\n          \n        \n        (\n        \n          s\n          \n            ′\n          \n        \n        )\n      \n    \n    {\\displaystyle Q_{i}\\pi ^{\\star }(s,a)=r_{i}+\\gamma s^{\\prime }\\sum _{s^{\\prime }}P(s^{\\prime }\\vert s,a)V_{i}\\pi ^{\\star }(s^{\\prime })}\n  \n\n其中\n  \n    \n      \n        \n          π\n          \n            ⋆\n          \n        \n      \n    \n    {\\displaystyle \\pi ^{\\star }}\n  \n为纳什均衡策略\n\n离线RL(Offline RL)  强调重要性权重约束：  πmin​E(s,a)∼D​[β(a∣s)π(a∣s)​Qπ(s,a)]  防止分布偏移问题\n\n\n== 参考文献 =="}
{"title": "Python", "text": "Python（英語發音：/ˈpaɪθən/；英語發音：/ˈpaɪθɑːn/），是一种广泛使用的解释型、高级和通用的编程语言。Python支持多种编程范型，包括结构化、过程式、反射式、面向对象和函数式编程。它拥有动态类型系统和垃圾回收功能，能够自动管理内存使用，并且其本身拥有一个巨大而广泛的标准库。它的语言结构以及面向对象的方法，旨在帮助程序员为小型的和大型的项目编写逻辑清晰的代码。\n吉多·范罗苏姆于1980年代后期开始研发Python，作为ABC语言的后继者，它也可以被视为采用了叫做M-表达式的中缀表示法的一种LISP方言。吉多·范罗苏姆于1991年首次发布 Python 0.9.0。Python 2.0于2000 年发布并引入了新功能。Python 3.0于2008年发布，它是该语言的主要修订版，并非完全向后兼容。Python 2于2020年随2.7.18版停止支持。\nPython的设计哲学，强调代码的可读性和简洁的语法，尤其是使用空格缩进来划分代码块。相比於C语言或Java，Python让开发者能够用更少的代码表达想法。\nPython解释器本身几乎可以在所有的操作系统中运行，它的官方直譯器CPython是用C语言编写的。Python是一個由社群驱动的自由软件，目前由Python软件基金会管理。Python是最受欢迎的编程语言之一。\n\n歷史\nPython的創始人吉多·范羅蘇姆，在1982年至1995年间，参与了荷兰数学和计算机科学研究学会多个项目的工作。1989年的聖誕節期間，他決心開發一個新的腳本解釋程式，作為ABC語言的後繼者，并且用它替代Unix shell和C语言来进行系统管理，担负与Amoeba操作系统之间的交互操作并进行例外處理。他是BBC電視劇《Monty Python的飛行馬戲團》的爱好者，所以选取了Python作为这个编程语言的名字。范羅蘇姆作为Python的主要開發者，独自担负这个项目的发展决策者职责，直到2018年7月12日，他宣布从終身仁慈獨裁者（BDFL）的职位上“永久休假”。他参与了2019年第一届领导项目发展的五人掌控委员会。\n在1991年2月，范羅蘇姆在Usenet新闻组alt.sources上发布了最初代码（标记为版本0.9.0），这时就已经存在了带继承的类、例外處理、函数和核心类型list、dict、str等。在这个最初发行中就有了从Modula-3引进的模块系统，和例外處理机制。在1994年1月，Python版本1.0发布，其主要新特征是由Amrit Prem提供的函数式编程工具lambda、map、filter和reduce。受Modula-3启发，Python 1.1介入了参数缺省值，Python 1.3介入了关键字参数。Python 1.4介入了对复数的内建支持。\n在2000年10月，Python 2.0發布，它从函数式编程语言Haskell中引进了列表推导式。Python 2.1支持了静态嵌套作用域。Python 2.2进行了重大革新，将Python中用C语言写成的类型，和用Python语言写成的类，统一成在同一个层级中，使得Python的对象模型成为纯粹而一致的对象模型；还介入了迭代器，受CLU和Icon启发的生成器，和描述器协议。Python 2.3介入了从Dylan引进的方法决定次序。Python 2.4介入了集合类型，和函数修饰器。Python 2.5在官方实现中介入了抽象语法树。\n在2008年12月，Python 3.0發布，它对语言做了较大修订而不能完全后向兼容，尽管提供了进行自动转换的2to3实用工具，仍有大量现存代码不能移植，故而Python 2.7的产品寿命结束延期至2020年元旦。Python 3.4介入了异步I/O模块。Python 3.5介入了类型提示，和采用async/await语法的协程。Python 3.8介入了赋值表达式。\n在2020年10月，Python 3.9介入了内建的针对容器类的泛化别名（types.GenericAlias）类型，并在官方实现中介入了新的语法解析器。Python 3.10介入了从Haskell和OCaml等借鉴来的结构式模式匹配，和内建的联合类型（types.UnionType）。Python 3.11对官方实现进行了优化提速。Python 3.12介入了类型参数语法，并废弃或移除了一些过时的模块和功能。\n在2024年10月，Python 3.13介入了从PyPy引进的新交互式解释器，并实验性的支持了即时编译器。Python 3.14正式支持了自由线程Python的官方实现构建选项。\n每个版本首次发行后，享有2年的完全支持，随后是3年的安全支持。当前只有Python 3的稳定版本3.13与3.14正在被完全支持，但仍提供对3.10、3.11和3.12版本的安全性修正。\n在2025年12月，活跃的Python核心开发者，选举Pablo Galindo Salgado、Savannah Ostrowski、Barry Warsaw、Donghee Na和Thomas Wouters，为2026年度掌控委员会的五位成员来领导这个项目。\n\n特徵與設計哲學\nPython是多范型编程语言。它完全支持结构化编程和面向对象编程，还有很多特征支持函数式编程和元编程比如元对象协议（元类和魔术方法）。通过扩展还可以支持很多范型，包括面向方面编程、契约式设计和逻辑编程。\nPython使用动态类型，在内存管理上采用的垃圾回收器基于了引用计数，并且结合了检测环引用的分代垃圾回收优化。它的特征还有动态名字解析（后期绑定），即在程序执行期间绑定方法和变量的名字。\nPython對遵循LISP傳統的函数式编程提供了有限的支持，它提供了 map、filter和reduce函数；列表推导式、字典推导式、集合推导式和生成器表达式。標準庫中的模組functools和itertools，实现了从Haskell和Standard ML借鉴来的函數式工具。\nPython的設計理念是“優雅”、“明確”、“簡單”，它的一些重要準則被合稱為「Python之禅」。在Python解釋器内運行import this可以獲得完整的列表，下面举出其中首要：\n\n優美优于丑陋。明瞭优于隐晦。\n简单优于复杂。复杂优于凌乱。\n扁平优于嵌套。稀疏优于稠密。\n可读性很重要。\nPython開發者的方法论是“用一種方法，最好是只有一種方法來做一件事”，显著不同于以Perl语言为代表的“不止一种方法去做一件事”風格。Python開發者在設計語言時，如果面臨多種選擇，一般會選擇明確没有或者很少有歧義的語法。\n范羅蘇姆将Python本身設計為可擴充的，並不把所有的特性和功能都集成到語言核心，而是提供了豐富的API和工具，以便程式設計師能够輕鬆地使用Python、C语言、Cython來編寫擴充模組。Python还可以通过外界函数接口如标准库中的ctypes等，来提供C语言兼容数据类型，并访问动态链接库或共享库中的函数，从而对用其他語言編寫的程式進行集成和封裝。\n在Python的官方实现CPython中，一般避開不成熟的或者對非重要部位的加快運行速度的優化。在某些對運行速度要求很高的情況，可以使用具备JIT技术的Python实现或安装JIT扩展模块。\n\n語法和语义\nPython為了讓程式碼具備高度的可閱讀性，在設計時盡量使用了其它語言常用的符號和英文單字。\n\n行结构\nPython程序在词法分析上被分成若干逻辑行。简单语句包含在一个单一的逻辑行之内，Python支持使用分号作为分隔符，将多个简单语句合并入一个逻辑行之中。\n注释开始于并非字符串文字一部份的一个井号#，并结束于物理行结尾；注释标示逻辑行的结束，除非已受制于隐式行接续规则；注释在语法上被忽略。\nPython支持使用反斜杠作为行接续符，将多个物理行合成为一个逻辑行。在圆括号、方括号或花括号之中的表达式，可以分裂跨越多于一个物理行而不使用反斜杠，这被称为“隐式行接续”。\n\n縮排\nPython语法中的复合语句，包含了一些其他语句，它们以某种方式影响或控制这些其他语句的执行。Python的复合语句包含一个或多个子句（clause），子句构成自一个头部（header）和一个套件（suite）。特定复合语句的子句头部都在同样的缩排层级上，每个子句头部开始于一个唯一标识关键字，并结束于一个冒号。套件即语法意义上的块，是这个子句所控制的一组语句。\n套件有两种形式：可以是与头部在同一行上的一个或多个由分号分隔的简单语句，它们跟随在这个头部的冒号之后；或者是遵循越位規則的在连续诸行上的一个或多个縮排的语句，只有这种套件形式可以包含嵌套的复合语句。\n根據PEP 8的規定，使用4個空格來表示每級縮排。\n缩排层级的变迁，被用来生成语法解析器才能见到的INDENT和DEDENT记号，增加縮排就生成INDENT记号，減少縮排就生成DEDENT记号。二者的作用相当于C语言家族的花括号，或Pascal语言家族的关键字begin和end。\n\n关键字\nPython有如下35个关键字；它们不能用作标识符：\n\n内建常量True、False和None于Python版本3.0中成为关键字，关键字nonlocal介入于版本3.0，关键字async和await介入于版本3.5，并在版本3.7中成为正式关键字。\n在Python中，将只在特定上下文中保留的标识符，称为“软关键字”：\n\nmatch、case和通配符_，介入于版本3.10，它们在与模式匹配语句有关的上下文中，可以在语法上充当关键字；但是这种区分只在语法解析器层次进行，并非在词法分析记号化层次。\ntype，介入于版本3.12，它用在type语句之中。\n\n标识符\n标识符就是名字，在ASCII范围内（U+0001..U+007F），可用于标识符的字符为：大写字母A至Z和小写字母a至z，下划线_以及数字0至9，但首字不可以用数字。如下命名约定，是为“保留标识符类”：\n\n_spam（单下划线开头）：弱“内部使用”标识。对于from M import *，将不导入所有以下划线开头的对象。\nspam_（单下划线结尾）：为了避免与python关键字的命名冲突。\n__spam（双下划线开头）：在命名一个类特性的时候，采用名字修饰，比如在类SpamEggs内，__spam将变成_SpamEggs__spam。\n__spam__（双下划线开头双下划线结尾）：指那些包含在用户控制的命名空间中的“魔术”方法或特性，比如__delattr__、__dir__、__doc__、__getattribute__、__init__、__new__、__repr__、__setattr__、__sizeof__等。建议永远不要将这样的命名方式应用于自己的变量或函数。\n\n語句\nPython的语句包括简单语句：\n\n赋值语句，采用的中缀记号是等号=。赋值语句被用来将名字绑定（含重新绑定）到值，以及用来修改可变对象的特性或项目。赋值语句支持链式赋值。\nPython还支持增广赋值语句，将一个二元运算和一个赋值语句合并成一个单一语句，例如x += 1。\nPython支持“序列解包”：在等号左侧可以是一个表达式列表，其中每个表达式都可求值成能被赋值的东西；在等号右侧相应的是一个“可迭代”对象，它在被迭代时产生的值的数量，同于左手侧可写表达式的数量；赋值语句对这个对象进行迭代，将产生的每个值分别赋值给左侧对应的可赋值者。在等号右侧直接包装出序列解包所要求的元组，就形成了并行赋值。\n表达式语句，用来交互式的计算并写出一个值，或者用来调用一个过程（即返回无含义结果的函数），在Python中过程返回值None。\nglobal语句，是在整个当前代码块中成立的声明，它意味着随后列出的标识符被解释为全局变量。\nnonlocal语句，导致随后列出的标识符，提及在除了全局作用域之外的最近包围作用域中的先前绑定变量。\ndel语句，递归的进行删除。\ntype语句，声明作为类型别名类型（typing.TypeAliasType）的实例的一个类型别名。\npass語句，充当无操作指令，表示此行為空，不執行任何操作。\nassert語句，用於程式調適階段時測試執行條件是否滿足。\ncontinue语句，越过这次迭代并继续进行下个项目。\nbreak语句，从循环中跳出。\nraise语句，抛出一个例外。\nreturn语句，用来从函数返回值。当函数执行到return语句时，它会停止执行并将指定的值返回给调用者。\nyield语句，用来从一个生成器中返回一个值，yield语句在语义上等价于加圆括号的yield表达式，在函数主体中使用yield表达式将导致它成为生成器函数。\n通过生成器的send()方法传入的信息，就是其中yield表达式的返回值。\n自从版本3.3，介入了yield from语句，它在语义上等价于加圆括号的yield from表达式，含有此表达式的生成器函数将特定任务委托给另一个子生成器函数，将传入信息递送给它并直接回传它产生的值。\n自从版本3.6，在协程函数主体中使用yield表达式将导致它成为异步生成器函数。\nimport语句，导入一个模块或包，它组合了两种操作，查找指名的模块，接着将找到的结果绑定到在局部作用域中的名字。导入语句有三种形式（下述语句样本采用了EBNF，这里的方括号表示其中内容为可选的）：\nimport 模块名字 [as 别名]，找到一个模块，装载它，如果有需要的话初始化它；在这个导入语句出现的作用域的局部名字空间中，定义一个名字或一些名字。\nfrom 模块名字 import 定义1 [as 别名1], 定义2 [as 别名2], …，找到、装载、必需时初始化一个模块；接着在局部名字空间中，增加到找到指名特性的引用。\nfrom 模块名字 import *，在导入语句出现的作用域的局部名字空间中，绑定模块中定义的所有公开的名字。\n复合语句：\n\nif語句，當條件成立時執行語句套件。它經常包含elif、else子句。\nwhile語句，當條件為真時，重複執行語句套件。\nfor語句，遍历列表、字符串、字典、集合等迭代器，依次處理迭代器中的每個元素。\nmatch语句，用于模式匹配。\nclass語句，是定义类的可执行语句。\ndef語句，是定義函數和方法的可执行语句。\nasync def语句，用于协程函数定义。await表达式、async for语句和async with语句，只能用在协程函数的主体中。\ntry語句，它经常包含except、else、finally子句，處理在程式執行中出现的例外情況。Python 3.11介入了except*子句。Python支持并广泛使用EAFP（请求原谅比获得许可更容易）风格的例外处理，作为检测错误状况和程序中其他“例外”事件的方式。例如：在访问一个文件或资源之时，事先不进行测试就尝试使用它，事后再捕获可能的访问失败所引发的例外。\nwith語句，把一块代码包裹在一个上下文管理器之内。它允许了RAII（对象初始化时获取资源）方式的行为，可替代常见的try/finally惯用法。Python使用with语句处理资源，例如：在执行一块代码时，事先获取一个锁，并且事后释放这个锁；或事先打开一个文件，并且事后关闭这个文件。\n\n块与模块\n在Python的执行模型中，程序构造自块（也称为代码块）。块是作为一个单元执行的Python程序文本，模块、函数主体和类定义都是块。交互式键入的每个命令、脚本文件和脚本命令都是块。传递给内建函数eval()和exec()执行的字符串是块。块在执行框架（frame）中执行。框架包含一些用于调试的管理信息，并确定在这个块执行完成后，执行在何处以及如何继续。\n模块是包含Python定义和语句的一个文件，这个文件名字是模块名字附加上后缀.py；在一个模块中，模块的名字（作为字符串）可获得为全局变量__name__的值。包（package）是可以包含子模块或递归性的子包的模块。包在技术上是具有__path__特性的Python模块。可以将包视为文件系统上的目录，而将模块视为这种目录中的文件，但是包和模块不必然源自文件系统。\n名字即标识符，是通用的引用持有者，它不关联于一个固定的数据类型，但是，一个名字在给定时间，总是被绑定到有一个类型的某个对象上，这就是动态类型的特征。名字的存储位置不“包含”所指示的值，一个共同的值可以赋值给多个名字，一个名字在任何时候，都可以重新绑定到各种不同类型的对象上，包括字符串、过程、具有数据和方法的复杂对象等。\n如果一个名字绑定在一个块中，它是这个块的局部变量，除非被声明为nonlocal或global。如果一个名字绑定在模块层次，它是全局变量。模块对应的块的变量，既是局部的也是全局的。如果一个变量使用在一个块中，却不定义在这里，它是自由变量。\n在Python中，赋值所进行的操作，是将一个名字绑定为到一个分立的动态分配的对象的一个引用。\n作用域定义一个名字在一个块中的可见性。如果一个局部变量被定义在一个块中，它的作用域包括这个块。如果这个定义出现在一个函数块中，作用域扩展到在所界定作用域内包含的任何块，除非所包含的块为这个名字介入了不同的绑定。对一个块可见的所有这种作用域的集合，叫做这个这个块的“环境”。\n当一个名字在一个块之中使用，它采用最近包围作用域来解析。如果一个名字绑定在一个块中，并且在其中于绑定之前就被使用，会导致一个错误。当一个函数或类的定义被嵌套到其他函数的定义之内，它的非局部作用域就是这个包围函数的局部作用域。nonlocal语句导致其列出的标识符，提及在非局部作用域内先前绑定的名字（即非局部变量）。\n名字空间是存储变量的地方，它被实现为字典。有局部名字空间、全局空间即包含这个块对应的模块的名字空间，和内建名字空间即模块builtins的名字空间；对象的方法是定义在类主体内的函数，它有着嵌套的名字空间。名字空间通过防止命名冲突而支持了模块性，还通过明晰了哪个模块实现了哪个函数而增进可读性和可维护性。\n如果global语句出现在一个块之中，在这个语句中指定的所有名字，提及在顶层名字空间中这些名字的绑定。名字在顶层名字空间解析，首先查找全局名字空间，未果查找内建名字空间。global语句与在同一个块中的名字绑定运算有同样的作用域。如果一个自由变量的最近包围作用域包含针对它的global语句，这个自由变量被当作全局的。\n\n表达式\nPython的表达式主要包括如下：\n\n在Python中，表达式的最基本元素被称为原子，最简单的原子是文字或标识符。由逗号,分隔的一系列表达式，叫做表达式列表。\n在Python中，加圆括号（parenthesized）形式被归类为原子，它是包围在圆括号中的可选的表达式列表。加圆括号的表达式列表产生的东西，就是这个表达式列表所产生的：如果这个列表包含至少一个逗号，例如(a,b,c)，则它产生一个元组；否则它产生的就是这个单一表达式，例如(a)产生a。要表示仅有单个元素的元组，需要给这个元素后缀一个逗号，例如(a,)。空的圆括号产生空元组对象。元组不是圆括号形成的，而是使用逗号形成的，在没有歧义的情况下，元组的圆括号是可选的。\nPython提供了称为展示（display）的特殊语法来构造列表、字典或集合，展示被归类为原子，并且有两种方式：要么其所包容的元素是显式的列举出来的，要么它们是通过叫做“推导式”的特定循环和过滤指令运算出来的。列表展示，是包围在方括号中的可以为空的一系列表达式，例如[a,b,c]。字典展示，是包围在花括号中的可能为空的一系列的用冒号:分隔的键-值对。集合展示，是包围在花括号中的一系列表达式。\nPython支持列表推导式和更一般性的生成器表达式，Python 3.0增补了字典推导式和集合推导式。自从Python 3.5，介入了在表达式列表中的“可迭代解包”*，和在字典展示中的“字典解包”**。\nPython对容器类实例，比如序列类型的列表、元组或字符串，支持形如a[索引]的下标，和形如a[开始:停止]或a[开始:停止:步长]的分片。此二者与函数调用和特性引用，一起被归类为表示语言中最紧密运算绑定的初等项（primary）。这里的下标索引是基于零的，负数是相对于结尾的。分片范围自从开始索引，直到但不包括停止索引，分片的第三个步长参数，允许元素被跳过和用负数指示反向。分片的每个元素都是浅层复制的。分片索引可以省略，例如a[:]，这返回整个列表的一个复本。\n在Python中，算术运算的加法+、减法-、乘法*，与C语言和java相同的。除法和模除%的行为有所不同，在Python中有两种除法：除法/和下取整除法//。Python增加了指数算符**。自从Python 3.5，介入了矩阵乘法算符@，它已经用于了NumPy库。中缀算符+、-，还可以分别表示取原数和取相反数的一元算符。\n在Python中，有如下必须用于整数的位运算：AND（与）&、OR（或）|、NOT（非）~、XOR（异或）^、右移>>、左移<<。\n在Python中，有如下比较运算：大于>、小于<、大于等于 >=、小于等于<=、等于==、不等于!=，用来比较两个对象的值的大小。Python有同一性测试算符：is、is not，用来比较两个运算元是否引用了同一个对象；还有成员关系测试算符：in、not in，用于判断一个对象是否属于另外一个对象。Python允许由比较运算链接起来的布尔表达式，比如a < b < c，它测试a < b and b < c；C语言将它解析为(a < b) < c：即首先求值a < b得出结果0或1，接着将此结果比较于c。\nPython使用and、or、not表示逻辑运算与、或、非，不采用C语言和Java中所用的符号&&、||、!。\nPython的条件表达式表示为x if c else y。意思是当c为真时，表达式的值为x，否则表达式的值为y。 在运算元的次序上不同于很多其他语言中常见的c ? x : y。\nPython的lambda表达式是匿名函数，其函数体只能是一个表达式。\n自从Python 3.8，介入了赋值表达式，其记号是:=。它将一个表达式赋值给一个标识符，同时还返回这个表达式的值。\nPython中运算符具有优先级，下表中的运算符按照从最高（最先绑定）到最低（最后绑定）的次序列出。在相同单元格中运算符具有相同的优先级，它们从左至右结合，除了指数表达式和条件表达式从右至左结合之外：\n\nPython为序列提供了串接算符+和倍增算符*。自从Python 3.9，介入了字典归并算符|和字典更新算符|=。\nPython为集合提供了集合论运算：并集|、交集&、相对补集-、对称差^，和子集测试<=、真子集测试<、超集测试>=、真超集测试>。\n在Python中，语句不能成为表达式的一部份，表达式比如列表推导式和字典推导式以及lambda表达式，都不能包含语句。这个限制的一个示例：赋值语句比如a = 1，不能用作条件语句的条件判断表达式的一部份；这能够避免C语言编程中的一个常见错误，即在条件判断时把等于算符==误写为赋值算符=，这不是预期代码却在语法上有效而能通过C语言编译器检查，在Python中这会导致一个语法错误。\n\n数值运算\nPython的二元算术运算，先将两运算元转为共同类型，加法、减法、乘法、下取整除法、模除和指数运算的结果也采用此类型，举下取整除法//例子：5//2 == 2而5.0//2 == 2.0。自从Python 3.0，除法/总是产生浮点数结果，例如5/2 == 2.5。\n下取整除法//的修约是朝向负无穷的，这意味着等式(a + n)//n == a//n + 1永远成立；很多其它编程语言比如C99采用截尾取整规则，其整数除法不能保证这个等式永远成立。Python提供了round()内建函数，用于把一个浮点数修约成最近的整数，自从Python 3.0，为了打破平局它采用了IEEE 754的约半成偶规则，例如round(1.5) == 2 == round(2.5)。\n模除%同样采用下取整规则，它所得余数的符号同于除数，例如-5%2 == 1而5%-2 == -1。很多其它语言采用截尾取整规则，其模除所得余数的符号同于被除数。Python模除运算结果余数的定义，确使等式a == (a//n)*n + a%n对于a和n分别为正数或负数的情况均为成立；数学中的欧几里得除法，同样保证这个等式永远成立，但它的余数总是非负数。\nPython对所有整数运算，使用任意精度算术。在decimal模块中的Decimal类，提供十进制浮点数，具有用户可按需要而更改的缺省28个十进制有效数位精度，并有多种修约方式。在fractions模块中的Fraction类，提供任意精度的有理数。第三方库gmpy2，提供了到任意精度计算库GMP/MPIR、MPFR和MPC的接口。\n除了求绝对值函数abs()列入内建函数之外，大多数数学函数，处于math和cmath模块内。前者用于实数运算，而后者用于复数运算。Python有着广泛的数学库，特别是第三方库NumPy进一步扩展了固有能力。\n\n字符串操作\nPython的文本序列类型，包括字符串str和字节序列bytes与bytearray。文本序列的文字有多种写法：\n\n短字符串文字，由单引号'或双引号\"界定。不同于Unix shell、Perl和受Perl影响的语言，单引号和双引号功能相同。这二种字符串都使用反斜杠\\作为转义字符。\n长字符串文字，是开始并结束于三个单引号'''或三个双引号\"\"\"的序列。它们可以跨越多行，其功能就像shell、Perl和Ruby中的here文档。\n字节文字总是前缀上一个b或B，它产生bytes类型的实例。它们只可以包含ASCII字符，其数值大于等于128的字节必须通过转义来表达。\n字符串文字或字节文字都可选的能前缀上一个r或R，这叫做原始字符串。转义序列不被解释，因此在文字反斜杠常见的地方很有用，比如正则表达式和Windows风格的路径。\nPython允许多个毗邻的字符串文字或字节文字（它们以空白分界并可以使用不同的引述约定），在编译时间于语法层面上串接起来。要在运行时间串接字符串，必须使用序列串接算符+。\n自从Python 3.0，字符串类str提供了格式化方法format()，例如\"spam={0} eggs={1:04d}\".format(\"blah\", 2)，它求值为'spam=blah eggs=0002'。格式化方法被推荐用来替代早先的字符串对象内建格式化算符%，它在功能上类同于C语言中的printf格式化字符串，例如\"spam=%s eggs=%04d\" % (\"blah\", 2)。\n自从Python 3.6，介入了字符串插值，即“格式化字符串文字”或称为“f字符串”，它向字符串文字前缀上f或F，例如x=\"blah\"; y=2; f'spam={x} eggs={y:04d}'。\n\n类型\nPython使用鸭子类型，并拥有有类型的对象，和无类型的变量名字。在编译期不检查类型约束，而宁愿在一个对象上的操作出现可能的失败，表现出这个给定对象不具有适合的类型。尽管是动态类型系统，Python却是强类型的，禁止没有明确定义的操作，比如将一个数和一个字符串相加，而不是默默的去尝试转换使其有意义。\nPython有着范围广泛的基本数据类型。同时具备常规的整数和浮点算术，它透明的支持任意精度算术、复数和十进制浮点数。Python支持种类繁多的字符串操作。在Python中，字符串是不可变的，所以在其他编程语言中可能就地改变字符串的字符串操作，比如字符替换，在Python中返回新的字符串。\nPython有一个非常有用特征，就是搜集（或称容器）类型的概念。一般的说，搜集是以一种易于引用或索引的方式，包含其他对象的对象。Python的搜集类型包括了序列、映射和集合，Python提供了广泛的搜集操纵能力，比如内建包含检查和通用迭代器协议。\n列表（动态数组）、元组和字符串是序列类型。所有序列类型都有位置索引，并且除了字符串，都可以包含任意类型的对象，在同一个序列中可以包括多种类型的对象。字符串和元组是不可变的，使得它们成为字典的键的完美候选者。列表是可变的，元素可以被插入、删除、修改、添加或就地排序。\n字典是无次序的映射类型，它将一组不可变的键，映射到相应的元素上。在字典中的键，必须是不可变的Python类型，比如整数或字符串，因为在底层它们是通过散列函数实现的。集合是无次序的类型，它包含唯一性的不可变对象作为元素。有二种类型的集合：可变的set和不可变的frozenset。\nPython允许编程者使用类，定义自己的类型。类的新实例，是通过调用这个类的构造器而创建的，而类型和类都是元类type的实例，元类type更是其自身的实例，这允许了元编程和反射。Python支持对类型和类的广泛内省，它们可以被读取和比较。\n长期规划是支持渐进类型，并且自从Python 3.5，语言的语法允许指定静态类型，但在缺省实现CPython中不检查它们。静态类型检查器mypy，支持编译期类型检查。\n\n除了各种数据类型，Python解释器还内建了很多其他类型，包括可调用类型：用户定义函数、实例方法、生成器函数、协程函数、异步生成器函数、内建函数、内建方法、类、类方法；模块，定制类，类实例，I/O对象（也叫做文件对象），和暴露给用户的一些内部类型：代码对象、框架对象、溯回对象、切片对象、静态方法对象、类方法对象。\n\n函数\nPython的函数支持闭包和其他头等函数特征，并支持限制最大深度的递归，\n它不支持函数重载即不能创建具有相同名字而有不同实现的多个函数，但其标准库可支持单一分派泛化函数。Python的函数作为头等对象，具有和普通对象平等的地位。Python官方实现不提供尾调用优化或头等续体，吉多·范罗苏姆曾声称他不会对其加以支持，有第三方库支持弹跳床。\n在Python中，函数调用的实际参数与函数定义的形式参数之间的结合，所传递的是“对象引用”，函数在被调用之时，所给予的实际参数被介入到一个局部符号表中，实际参数使用传值调用来传递，而这个值总是对象引用，并非这个对象的值。如果形式参数绑定到一个可变对象，则通过形式参数对此对象内容的修改，在函数外也是可见的。如果形式参数绑定到一个不可变对象，则通过形式参数不能修改此对象内容，但可以把形式参数重新绑定到其它对象上，这并不影响函数外的对象的值。\nPython在函数定义时，可以在形式参数序列中，以形式参数=值的样式指定形式参数缺省值。在函数调用时可以省略有缺省值的形式参数，这时这个缺省值就被代入到它的位置中。在这个函数定义被执行之时，从左至右的求值作为形式参数的缺省值的这些表达式。这意味着这种表达式在这个函数被定义之后只被求值一次，而每次函数调用之时都使用相同的“预先计算”的值。\nPython在函数调用中，可以给予位置实际参数和关键字实际参数。实际参数可以如同C语言那样，按照位置与函数定义的形式参数匹配；也可以采用关键字实际参数，即形式参数=值样式的实际参数。Python在函数定义中，可以使用不对应实际参数的特殊形式参数/和*，将形式参数序列分为三部份：唯位置形式参数、可位置可关键字形式参数和唯关键字形式参数。如果一个形式参数有缺省值，则在其后直到*之前的所有形式参数也都必须有缺省值。\n在函数定义中的位置形式参数序列和关键字形式参数序列，可以分别在其末尾有*args或**kwargs这样的加了前缀*或**的形式参数，它们捕获在函数调用时提供的，超出形式参数序列规定而无所对应的多个实际参数；在形式参数args前加*号，则args是元组类型，它捕获可变数目的位置实际参数；在形式参数kwargs前加**号，则kwargs是字典类型，它捕获可变数目的关键字实际参数。\n在函数调用的实际参数序列中，关键字实际参数必须出现在位置实际参数之后。如果要传递给一个函数的一些位置实际参数，已经在一个序列类型如列表或元组的对象中，则可以在函数调用中给它前缀*来进行可迭代解包；如果要传递的一些关键字实际参数已经在字典对象中，则可以给它加**号来进行字典解包。\n在函数定义头部之后可以插入“文档字符串”，用作函数的使用帮助，它可以使用内置函数help()打印出来。自从Python 3.0，函数定义可以对形式参数与返回值增加类型标注。自从Python 3.5，开始支持类型提示。\nPython的修饰器（decorator）可用来修改任何可调用Python对象，其用法是将已定义的对象比如函数、方法或类定义传递给修饰器，再将它所返回的修改后的对象绑定到原来对象的名字。修饰器可用于元编程，其用途至少包括：建立类方法或静态方法，设置先决条件和后置条件、实现多方法、记忆化。\nPython使用@作为关键字形成修饰符，它是用来应用修饰器的语法糖。\n通过在毗连的行上放置多个修饰符，多个修饰器可以链接起来应用。\n\n对象及其方法\nPython支持大多数面向对象编程技术。在Python中所有东西都是对象，包括数、函数、类和模块。它允许多态性，不限定于在类层级之内子类型方式，而是采用了鸭子类型方式，就是说针对变量的方法调用和特性（attribute）访问，不事先限制这个的变量的类型，它可被绑定到任何对象。Python的类继承支持多重继承，这可以用来实现混入。Python支持元类，还支持抽象基类，自从Python 3.6，提供了定制化类创建的简单机制。\n对象的方法，是附属于这个对象的类的函数。对于正常的方法和函数，语法实例.方法(实际参数)，是类.方法(实例, 实际参数)的语法糖。Python不提供其他一些面向对象编程语言比如C++和Java中的隐式的this关键字，Python的对象方法沿袭自Modula-3，使用显式的第一个形式参数来访问实例特性，习惯上将其命名为self。\nPython支持一些名字以__开始和结束的特殊方法，它们用于实现实现多种特殊功能，尤其是实例初始化，在一个类中定义__init__()，它在实例创建后返回给调用者之前被调用，所给予的实际参数就是传递给对象构造器表达式的那些实际参数。某些特殊方法可以实现运算符重载，比如在一个类中定义__add__()，将允许在这个类的实例上使用+算符。\n在Python中，对象的特殊特性__dict__，是存储其所有（可写）特性的字典。在一个类中的类变量__slots__，可以被赋值为变量名字序列，它为所声明的这些变量在类实例对象中保留空间，并阻止其自动建立__dict__。\n在Python中，定义了一个或多个特殊方法__get__()、__set__()、__delete__()的类，可以用作描述器（descriptor）。在类的定义中，如果一个成员若是另一个描述器类的实例，则它被称为这个类的属性（property），使用与特性（attribute）访问相同的语法，访问这个类的实例对象中的属性。\n在Python中，不强制采用访问子与变异子方法，来访问对象的数据成员。Python使用名字修饰，有限的支持私有变量。Python的property内建函数和@property修饰符，将一个类中特殊定义的访问某个特性的那些方法，包装成的这个类的一个属性。\nPython允许通过使用@classmethod和@staticmethod修饰符，来分别建立类方法和静态方法。在方法调用之时，类方法接收这个类的作为其隐式的第一个实际参数，而静态方法不接收隐式的第一个实际参数。\nPython不提供隐式的super关键字而是提供了super()内建函数，在一个类的方法中调用此函数返回一个代理（proxy）对象，它为了在类层级内这个类所有基类中查找实现了特定方法的基类，确定了优先次序即方法决定次序（MRO），次序居前的基类优先于位居其后的它的父辈类或平辈类。当一个子类的方法覆盖了其超类方法的时候，可通过调用super().方法，将这个方法调用委托给与子类的self.方法同名的超类方法。\n\n标准库\nPython拥有一个强大的标准库。Python标准库包括了如下功能：\n\n程序代码实例\n一個在標準輸出設備上輸出Hello World的簡單程式通常被作為開始學習程式語言時的第一個程式。可将如下代码录入纯文本文件并命名（如program01.py），然后执行这个命令python3 program01.py以執行該程序：\n\nPython也可以單步直譯執行。執行Python直譯器進入互動式命令列的環境後，你可以在提示符號>>>旁輸入print(\"Hello, world!\")，按Enter鍵輸出結果：\n\n计算非負整数的阶乘的程序代码：\n\n注意：在Python 3.0及以上版本中，print是个函数，需要在要打印的參數前后加上圆括号；在Python 2.x版本中，print是一个关键字而可以不加圆括号。\n\n实现\nPython是一门跨平台的脚本语言，Python规定了一个Python语法规则，根据该规则可编写Python直譯器。Python属于动态语言，其官方实现CPython将Python程序编译成中间形式的字节码，并接着在它的虚拟机上执行，运行速度缓慢于C/C++所编译出的机器码和在HotSpot JVM上运行的java字节码。\n\n活跃开发的实现\n\n转译成其他语言的编译器\n\n其他实现举例：Cinder，它是Meta孵化器发布的面向性能的CPython分叉。Jython，它是用Java实现的Python 2.7。IronPython，它基於DLR之上的Python 2.7和Python 3.4实现。Stackless Python，它是实现微线程的CPython 3.8分叉。Pyston，它是具有JIT等性能优化的CPython 3.8.12的分叉。Pyjion，将Python代码编译成本机CIL的CPython 3.10的JIT扩展。Grumpy，它是Python 2.7到Go的转译器和运行时系统。py2many，将Python转译成多种语言如C++17、Rust、Go和Julia等的转译器。\n\n开发环境\n通用文本编辑器\n很多并非集成开发环境软件的文本编辑器，也对Python有不同程度的支持，并且加上专门为Python设计的编辑器插件也会有很高的可用性。\n\n专用开发环境\n适用于Python的集成开发环境（IDE）软件，除了标准二进制发布包所附的IDLE之外，还有许多其他选择。其中有些软件设计有语法着色、语法检查、运行调试、自动补全、智能感知等便利功能。由于Python的跨平台出身，这些软件往往也具备各种操作系统的版本或一定的移植性。\n\n第三方扩展包\nPython社群提供了大量的功能覆盖众多领域的第三方模組，其使用方式与标准库类似。第三方模块可以使用Python/Cython或者C语言编写。软件工具比如SWIG，通过定义接口文件或规定文件的方式，可以将C/C++编写的程序库包装为Python模块。Python解释器本身也可以被集成到其它需要腳本語言的程式内。\nPython包索引是公开的软件包在线仓库。pip是官网推荐的以安全方式安装Python应用及其依赖软件包的最流行工具。要安装在整个操作系统范围内共享的Python包，现在需要通过操作系统的软件包管理系统。为了将特定于应用的依赖包隔离于共享的Python安装，需要创建虚拟环境，这可以使用标准库的venv，或第三方工具比如virtualenv和pipenv。\n\n網絡编程\nPython标准库對於各种網路協定的支援很完善，因此適用於編寫伺服器軟體、網路爬蟲等Web開發。Python定義了WSGI標準應用接口，来協調HTTP伺服器與基於Python的Web程式之間的溝通。比如，通過mod_wsgi模組，Apache HTTP Server可以運行用Python編寫的Web程式。\n用Python编写的一些Web框架，有助於輕鬆地開發和管理複雜的Web程式。重要的第三方网络编程库和Web框架有：\n\n图形用户界面\nPython本身包含了Tkinter库，它是Python的业界标准GUI并被集成进入了IDLE。Tkinter基于了Tcl命令工具，能够支持简单的GUI开发。但是为了让所开发的软件运行速度更快，并与用户的桌面环境更契合，人们一般会选择采用第三方GUI库或框架。主要的第三方GUI库有：\n\n数据科学\n重要的数据科学用第三方软件库有：\n\n数据可视化\n主要的数据可视化软件库及仪表板框架有：\n\n机器学习\n基础性的机器学习软件库及框架有：\n\n其它种类\n应用\n在很多作業系統裡，Python是標準的系统元件，它被列入了ISO/IEC 23360-1-4:2021 Linux标准规范（LSB）之语言规定。大多數Linux發行版和macOS都集成了Python，可以在终端模拟器或虚拟控制台下直接執行Python。第三方工具pipx，可以将Python应用安装于隔离的环境中并在其中运行它。\n雖然Python可被粗略地分類為腳本語言，Python的支持者較喜歡稱它為一種高階動態語言，常像“胶水”一样被用来连接软件组件，已经显著的区别于Unix shell、Windows PowerShell这样的语言。基于Python的xonsh，是跨平台的、青睐Unix的shell语言和命令行界面。\n\n应用程序\n一些Linux發行版，使用Python語言編寫安裝器，比如Ubuntu的Ubiquity和Fedora的Anaconda；或使用它編寫軟件包管理系统，比如Gentoo的Portage。下面举例使用Python编写或将它作为嵌入式脚本的一些应用程序：\n\n人工智能\n经由Python开发了众多的人工智能模型和作为其支撑的软件库：\n\n社群流行\n自从2003年，Python始终排行于TIOBE编程社区索引前十最流行编程语言，在2021年10月它首次达到了第一名最流行语言（居于C和Java之前），并被选为2007年、2010年、2018年、2020年、2021年和2024年的年度编程语言。它有如下著名的社群：\n\n影響的语言\nPython的设计和哲学已经影响了很多其他编程语言，例如：\n\n此外还有：Boo、Cobra、GDScript、Ring、Starlark和V等等。\n在Python基础上开发的编程语言有：\n\n示例与注释\n引用\n延伸閱讀\n参閲\n\n\n== 外部連接 =="}
{"title": ".NET", "text": ".NET（3.1版以前稱作.NET Core）是微軟開發的第一個跨平台 （Windows、macOS和Linux）的應用程式開發框架（Application Framework）。.NET也是微軟在一開始發展時就開源的軟體平台，它經常也會拿來和現有的開源 .NET平台Mono比較。\n.NET包含 .NET Framework的類別庫，但與 .NET Framework不同的是 .NET採用套件化（Packages）的管理方式，應用程式只需要取得需要的組件即可，與 .NET Framework大包式安裝的作法截然不同，同時各套件亦有獨立的版本線（Version line），不再硬性要求應用程式跟隨主線版本。\n.NET專案的主要目標有 ：\n\n支援或可以移轉（port）到更多的作業系統平台與晶片架構（也就是未來計畫會跨出x86平台）。\n具有引人注目的效能與高可靠度。\n開發人員能快速與直覺的獲取 .NET開發環境。\n在直覺與具生產力的情況下建造應用程式、使用文件、範例與NuGet元件。\n\n历史\n.NET Core 1.0于2016年6月27日发布。\n2020年11月，微软发布了 .NET 5.0，统一了.NET的各个平台的碎片版本： .NET Framework 4.8、.NET Standard、.NET Core 3.1、Mono和Xamarin等。\n此后，微软每年11月发布一个 .NET 的大版本更新，并将偶数大版本指定为長期支援（LTS）版本。\n2021年11月，微软发布了 .NET 6.0，为LTS版本，提升了性能并完善了跨平台开发能力。\n2022年11月，微软发布了 .NET 7.0，进一步提升性能和开发体验，增强了云原生和容器支持。\n2023年11月，微软发布了 .NET 8.0，作为LTS版本，继续在性能、多平台和AI场景方面优化。\n2024年11月，微软发布了 .NET 9.0，聚焦性能提升和云原生应用，并持续完善开发工具链。\n2025年11月，微软发布了 .NET 10.0。\n\n核心功能\n.NET是由許多專案所組成，除了基本的類別庫（Core FX）之外，也包含採用RyuJIT編譯的執行平台Core CLR、編譯器平台.NET Compiler Platform、採用AOT編譯技術運行最佳化的套件Core RT（.NET Core Runtime），以及跨平台的MSIL編譯器LLILC（LLVM-based MSIL Compiler）等專案。\n同時，微軟也發展了一個建置技術文件的平台docfx ，並運用於 .NET的文件網站。\n\nRyuJIT\nRyuJIT是微軟發展的新式即地編譯器（Just-in-Time Compiler），用以取代現有的 .NET Framework的JIT以及JIT64即地編譯器，依據微軟公佈的測試報告，RyuJIT的效能較前一代的JIT提升約25%，並支援SIMD（Single Instruction, Multiple Data）的技術。RyuJIT同時應用於 .NET Framework 4.6以及 .NET Core。\n\nCore CLR\nCore CLR移植 .NET Framework的CLR的功能，包含核心程式庫mscorlib、JIT編譯器、垃圾收集器（GC）以及其他執行MSIL所需要的執行期環境。\n\nCore RT\nCore RT是以预先编译為主的核心功能，在 .NET Core內稱為Core RT，在UWP則是稱為 .NET Native。\nCore RT會在建造時期（非執行期）在編譯時將MSIL轉換成平台原生的機器碼，以獲取較短的啟動時間（JIT採用的是執行時期編譯，使得啟動時間拉長），以及記憶體用量減少的優點。Core RT會在不同的平台使用不同的AOT技術：\n\nWindows上使用的是 .NET Native。\nmacOS與Linux上使用的是LLILC（同時支援JIT和AOT）。\n\nLLILC\nLLILC（LLVM-based MSIL Compiler，英文發音為 \"lilac\"）是 .NET在非Windows平台的MSIL編譯器，基於ECMA-335（Common Language Infrastructure）的標準將MSIL編譯成原生碼執行，適用於可運行LLVM的作業系統，例如macOS與Linux作業系統。\nLLILC同時支援JIT（內含RyuJIT的實作） 以及AOT（未來將開始支援）的編譯方式。\n因为RyuJIT的跨平台能力与性能逐渐追上，LLILC的Github仓库已于2022年被归档，不再维护\n\nRoslyn\n.NET Compiler Platform（專案代碼為Roslyn）是將 .NET平台的編譯架構標準化的平台，它可提供程式管理工具 （如整合開發環境） 相當多的情報，用以發展有助於編寫程式與管理程式結構所需要的功能，例如型別資訊、語法結構、參考連結、語意、編譯器、自動化、錯誤回報等等功能，只要是遵循CLI標準的程式語言，都可以利用 .NET Compiler Platform實作出編譯器，讓程式管理工具能實作如語法提示、語法自動完成、關鍵字高亮等視覺化能力。\n.NET Compiler Platform可同時支援 .NET Framework 4.6以上版本，.NET Core也原生支援。\n\n套件管理\n.NET Core v1.0時期\n.NET Core的類別庫採用NuGet套件化的架構，應用程式只需要使用project.json的dependencies區段加入指定套件版本的參考，就能獲得該套件的功能，與以往 .NET Framework大包式的提供方法完全不同。.NET Core團隊宣佈已經有98%的 .NET Framework主要類別庫移轉到 .NET Core平台。\n例如下列project.json內容，可直接加入 .NET Standard Library（v1.0.0-rc2-23901）的參考。\n\n.NET Standard Library是一個總括型的NuGet Package，其內包含了這些類別庫套件：\n\nMicrosoft.DotNet.CoreHost\nNETStandard.Platform\nSystem.Collections.Concurrent\nSystem.Linq\nSystem.Runtime.Numerics\nSystem.Text.RegularExpressions\n其中的NETStandard.Platform也是一個總括型套件，包含了下列類別庫套件：\n\nMicrosoft.NETCore.Platforms\nMicrosoft.NETCore.Runtime\nMicrosoft.Win32.Primitives\nSystem.AppContext\nSystem.Collections\nSystem.Diagnostics.Debug\nSystem.Diagnostics.Tools\nSystem.Diagnostics.Tracing\nSystem.Globalization\nSystem.Globalization.Calendars\nSystem.IO\nSystem.IO.FileSystem\nSystem.IO.FileSystem.Primitives\nSystem.Net.Primitives\nSystem.Net.Sockets\nSystem.Reflection\nSystem.Reflection.Extensions\nSystem.Reflection.Primitives\nSystem.Reflection.TypeExtensions\nSystem.Runtime\nSystem.Runtime.Extensions\nSystem.Runtime.Handles\nSystem.Runtime.InteropServices\nSystem.Runtime.InteropServices.RuntimeInformation\nSystem.Text.Encoding\nSystem.Text.Encoding.Extensions\nSystem.Threading\nSystem.Threading.Tasks\nSystem.Threading.Timer\n開發人員只需要使用NETStandard.Library就能加入所有必要的 .NET Core類別庫參考，但若不需要這麼多組件，也可以只加入特定的套件即可，不一定都要加入NETStandard.Library。\n\n.NET Core v1.1時期\n對於微軟來說，.NET Core 1.0（以及早期開發時）使用project.json來處理套件管理與版本相依的問題，是因為很多工具還沒趕上（例如微軟主力的建置工具MSBuild），再加上project.json/xproj架構並不相容於以MSBuild為主的工具鏈 （Toolchain），若是要修改成相容 project.json/xproj 架構的話可能會付出極大成本，因此在 .NET Core 1.0 RC2 發布不久，官方就宣布要將project.json/xproj系統移回到以MSBuild為主的csproj ，例如下列csproj的例子即可看到套件參考的內容。\n\n由於 .NET Core移回了MSBuild架構，因此在Visual Studio 2017的 .NET Core工具內，已恢復可直接於IDE的GUI介面中編修套件參考的功能。\n\n應用程式類型\n.NET基於跨平台能力，在 .NET Core 3.0之前，並沒有將與GUI高度相關的API移植到 .NET Core內，因此像是Windows Forms或是Windows Presentation Foundation（WPF）並未移植到 .NET Core。.NET支援主控台應用程式（Console Application）以及類別庫（Class Library）類型的專案。\n不過從 .NET Core 3開始，微軟在其Universal Windows Platform（UWP）開發平台使用了 .NET，並且利用 .NET Native技術將其效能提升至十分接近原生碼的速度。\nASP.NET Core則以主控台應用程式驅動其代管環境Kestrel Server以支援ASP.NET Core程式的執行。\n\n.NET CLI\n.NET CLI（Command-Line Interface）指令列工具是 .NET處理建造、執行與編輯工作的主要工具 ，有幾個主要的動作：\n\n與其他平台的關係\n.NET經常會拿來與其他平台做比較，尤其是它的源頭 .NET Framework以及另一個相似性質的開源平台Mono。\n\n.NET Framework\n據微軟的說明，.NET Core和 .NET Framework是子集（Subset）與超集（Superset）的關係，.NET Core將會實作出部份的 .NET Framework功能 （基本上是不含使用者介面的部份），例如 JIT（.NET Core採用 RyuJIT）、垃圾收集器（GC）以及型別（包含基本型別以及泛型型別等）。.NET Framework与 .NET Core已经在 .NET 5及以后版本合并为统一的 .NET平台。\n\nMono\nMono是另一個已發展許久的 .NET Framework跨平台開源版本，起初由社群主导，并由Xamarin等技术推动了.NET跨平台应用的开发。在.NET Core问世后，微软逐步将跨平台的核心功能和支持纳入微软官方的.NET生态中，最终在.NET5及以后版本将.NET Core和Mono合并至统一的.NET平台。此后不再区分.NET Framework、.NET Core和Mono。\nMono的最后一个大版本于2024年2月发布，之后微软将其移交至Wine进行管理。\n然而，Mono仍然具有其特定的用途，例如作为Unity游戏引擎和Xamarin。Android/Xamarin.iOS的运行环境，因为其提供的轻量级JIT编译和AOT（Ahead Of Time）功能。\n\n與ASP.NET Core的關係\n.NET Core與ASP.NET Core的關係其實一開始並不是主從關係 ，ASP.NET Core的開發初期（ASP.NET 5）.NET Core還沒有開始起跑，因此ASP.NET Core當時有自己的執行期與工具，一開始稱為Project K，後來改為DNX（.NET Execution Environment），DNX本身就具有可獨立運作的執行能力，不需要依賴 .NET Core執行，但是這樣會變成 .NET Core和ASP.NET Core雙頭馬車的現象，在 .NET Core逐漸成熟之後，微軟也決定要將這兩個各自獨立發展的產品線整合在一起，DNX也將因改用 .NET Core執行期而終止開發，DNX的功能將由 .NET Core以及旗下的 .NET CLI接替提供，整合後的版本將在1.0 RC2時釋出。\n\n支援作業系統\n.NET 9支援下列作業系統 ：\n\n\n== 參考 =="}
{"title": "ABC (程式語言)", "text": "ABC是一種指令式通用程式語言和編程環境，最初由荷兰数学和计算机科学研究学会（CWI）的里奥·格茨（Leo Geurts）、兰伯特·梅尔滕斯與史蒂文·彭伯顿开发。它是指令式、结构化的高级语言，意图用來取代BASIC、Pascal與AWK，它的设计目標是用于教學或建立原型，而非用作一种系统编程语言。\nABC語言对Python语言有着主要的影响，Python的创立者吉多·范罗苏姆在1982年至1986年间参与了ABC系统的设计与实现工作。\n\n特征\nABC的设计者声称，典型的ABC程序的大小只是等价的Pascal或C程序的四分之一，并且更加具有可读性。它的关键特征包括：\n\n只有五种基本数据类型。\n不要求变量声明。\n显式的支持自上而下编程。\n语句嵌套通过越位规则使用缩进来指示。\n任意精度算术，无大小限制的列表和字符串，支持正交性和初学者易用性的其他特征。\nABC最初是一个单体实现，导致它不能适配新的需求，比如建立图形用户界面。ABC不能直接访问底层文件系统和操作系统。\n完全的ABC系统包括了使用结构编辑器（语法导向编辑器）、提示、持久变量和多工作空间的编程环境，并可获得到ABC的解释器/编译器，其当前版本是1.05.02，它已经移植到了Unix、DOS、Atari和Apple Macintosh。\n\n例子\n一个函数words，它在文档中收集出所有单词的集合：\n\nHOW TO RETURN words document:\n   PUT {} IN collection\n   FOR line IN document:\n      FOR word IN split line:\n         IF word not.in collection:\n            INSERT word IN collection\n   RETURN collection\n\n引用\n參考文獻\n外部連結\nA Short Introduction to the ABC Language（页面存档备份，存于互联网档案馆）\nABC Programmer's Handbook（页面存档备份，存于互联网档案馆）"}
{"title": "ABC語言", "text": "ABC是一種指令式通用程式語言和編程環境，最初由荷兰数学和计算机科学研究学会（CWI）的里奥·格茨（Leo Geurts）、兰伯特·梅尔滕斯與史蒂文·彭伯顿开发。它是指令式、结构化的高级语言，意图用來取代BASIC、Pascal與AWK，它的设计目標是用于教學或建立原型，而非用作一种系统编程语言。\nABC語言对Python语言有着主要的影响，Python的创立者吉多·范罗苏姆在1982年至1986年间参与了ABC系统的设计与实现工作。\n\n特征\nABC的设计者声称，典型的ABC程序的大小只是等价的Pascal或C程序的四分之一，并且更加具有可读性。它的关键特征包括：\n\n只有五种基本数据类型。\n不要求变量声明。\n显式的支持自上而下编程。\n语句嵌套通过越位规则使用缩进来指示。\n任意精度算术，无大小限制的列表和字符串，支持正交性和初学者易用性的其他特征。\nABC最初是一个单体实现，导致它不能适配新的需求，比如建立图形用户界面。ABC不能直接访问底层文件系统和操作系统。\n完全的ABC系统包括了使用结构编辑器（语法导向编辑器）、提示、持久变量和多工作空间的编程环境，并可获得到ABC的解释器/编译器，其当前版本是1.05.02，它已经移植到了Unix、DOS、Atari和Apple Macintosh。\n\n例子\n一个函数words，它在文档中收集出所有单词的集合：\n\nHOW TO RETURN words document:\n   PUT {} IN collection\n   FOR line IN document:\n      FOR word IN split line:\n         IF word not.in collection:\n            INSERT word IN collection\n   RETURN collection\n\n引用\n參考文獻\n外部連結\nA Short Introduction to the ABC Language（页面存档备份，存于互联网档案馆）\nABC Programmer's Handbook（页面存档备份，存于互联网档案馆）"}
{"title": "Java", "text": "Java是一種廣泛使用的電腦程式設計語言，擁有跨平台、物件導向、泛型程式設計的特性，广泛应用于企业级Web应用开发和移动应用开发。\n任職於昇陽電腦的詹姆斯·高斯林等人于1990年代初开发Java語言的雛形，最初被命名为Oak，目標設定在家用电器等小型系統的程式语言，應用在电视机、电话、闹钟、烤面包机等家用电器的控制和通訊。由于这些智能化家电的市场需求没有预期的高，昇陽電腦放弃了该项计划。随着1990年代網際網路的发展，昇陽電腦看見Oak在網際網路上应用的前景，于是改造了Oak，於1995年5月以Java的名称正式发布。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的网络编程语言。\nJava编程语言的风格十分接近C++语言。继承了C++语言面向对象技术的核心，舍弃了容易引起错误的指標，以參照取代；移除了C++中的运算符重载和多重继承特性，用接口取代；增加垃圾回收器功能。在Java SE 1.5版本中引入了泛型编程、类型安全的枚举、不定长参数和自动装/拆箱特性。昇陽電腦对Java语言的解释是：「Java编程语言是个简单、面向对象、分布式、解释性、健壮、安全、与系统无关、可移植、高性能、多线程和动态的语言」。\nJava不同於一般的编译語言或直譯語言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2发布后，Java的執行速度有了大幅提升。\n与传统型態不同，昇陽電腦在推出Java時就将其作为开放的技术。全球的Java开发公司被要求所设计的Java软件必须兼容。“Java语言靠群体的力量而非公司的力量”是昇陽電腦的口号之一，并获得了广大软件开发商的认同。这与微软公司所倡导的注重精英和封闭式的模式完全不同，此外，微软公司後來推出了与之竞争的.NET平台以及模仿Java的C#语言。後來昇陽電腦被甲骨文公司併購，Java也隨之成為甲骨文公司的產品。\n目前，行動作業系統Android大部分的代碼採用Java程式設計語言編程。\n\n历史\n早期的Java\n語言最開始只是昇陽電腦（Sun MicroSystems）公司在1990年12月開始研究的一個內部項目。昇陽電腦公司的一個叫做帕特里克·諾頓的工程師被公司自己開發的C++和C語言編譯器搞得焦頭爛額，因為其中的API極其難用。帕特里克決定改用NeXT，同時他也獲得了研究公司的一個叫做「Stealth計劃」的項目的機會。\n「Stealth計劃」後來改名為「Green計劃」，詹姆斯·高斯林和麥克·舍林丹（Mike Sheridan）也加入了帕特里克的工作小組。他們和其他幾個工程師一起在加利福尼亞州門羅帕克市沙丘路的一個小工作室裡面研究開發新技術，瞄準下一代智能家電（如微波爐）的程序設計，昇陽電腦預料未來科技將在家用電器領域大顯身手。團隊最初考慮使用C++語言，但是很多成員包括昇陽電腦的首席科學家比爾·喬伊，發現C++和可用的API在某些方面存在很大問題。\n工作小組使用的是嵌入式系統，可以用的資源極其有限。很多成員發現C++太複雜以至很多開發者經常錯誤使用。他們發現C++缺少垃圾回收系統，還有可移植的安全性、分佈程序設計、和多執行緒功能。最後，他們想要一種易於移植到各種設備上的平台。\n根據可用的資金，喬伊決定開發一種集C語言和Mesa語言大成的新語言，在一份報告上，喬伊把它叫做「未來」，他提議昇陽電腦的工程師應該在C++的基礎上，開發一種物件導向的環境。最初，高斯林試圖修改和擴展C++的功能，他自己稱這種新語言為C++ -- ，但是後來他放棄了。他將要創造出一種全新的語言，被他命名為「Oak」（橡樹），以他的辦公室外的橡樹命名。\n就像很多開發新技術的秘密工程一樣，工作小組沒日沒夜地工作到了1993年的夏天，他們能夠演示新平台的一部分了，包括Green操作系统，Oak的程序設計語言，類庫及其硬件。最初的嘗試是面向一種類PDA設備，被命名為Star7，這種設備有鮮豔的圖形界面和被稱為「Duke」的智能代理來幫助用戶。1992年12月3日，這台設備進行了展示。\n同年11月，Green計劃被轉化成了「FirstPerson有限公司」，一個昇陽電腦的全資子公司，團隊也被重新安排到了帕洛阿爾托。FirstPerson團隊對建造一種高度互動的設備感興趣，當時代華納發佈了一個關於電視機頂盒的徵求提議書時（Request for proposal），FirstPerson改變了他們的目標，作為對徵求意見書的響應，提出了一個機頂盒平台的提議。但是有線電視業界覺得FirstPerson的平台給予用戶過多的控制權，因此FirstPerson的投標敗給了SGI。與3DO公司的另外一筆關於機頂盒的交易也沒有成功，由於他們的平台不能在電視工業產生任何效益，公司被併回昇陽電腦。\n\nJava和「Java」\n由于商标搜索显示Oak已被一家显示卡制造商注册。于是同年，Oak被改名为Java。当使用十六进制编辑器打开由Java源代码编译出的二进制文件（.class文件）的话，最前面的32位将显示为CA FE BA BE，即词组“CAFE BABE”（咖啡屋宝贝）。\n\nJava和互联网\n1994年6月，在同约翰·盖吉、詹姆斯·高斯林、比尔·乔伊、帕特里克·诺顿、韦恩·罗斯因和埃里克·施密特经历了一场历时三天的头脑风暴后，团队决定再一次改变努力的目标，这次他们决定将该技术应用于万维网。他们认为随着Mosaic浏览器的到来，因特网正在向同样的高度互动的远景演变，而这一远景正是他们在有线电视网中看到的。作为原型，帕特里克·诺顿写了一个小型万维网浏览器，WebRunner，后来改名为HotJava。\n1994年10月，HotJava和Java平台为公司高层进行演示。1994年，Java 1.0a版本已经可以提供下載，但是Java和HotJava浏览器的第一次公开发布却是在1995年3月23日SunWorld大会上进行的。昇陽電腦的科学指导约翰·盖吉宣告Java技术。这个发布是与网景公司的执行副总裁马克·安德森的惊人发布一起进行的，宣布网景将在其浏览器中包含对Java的支持。1996年1月，昇陽電腦成立了Java业务集团，专门开发Java技术。\n在流行几年之后，Java在浏览器中的地位被逐步侵蚀。它在简单交互性动画方面的用途已经完全被Adobe公司的Flash排挤，2005年Java倾向只被用于雅虎游戏那样的更为复杂的应用程序。Java同时遭受到来自微软的反对，他们决定在新版本的Internet Explorer和Windows中不再附带Java平台。\n与此相反，在万维网的服务器端和手持设备上，Java变得更加流行。很多网站在後端使用JSP和其他的Java技术。\n在桌面系统上，独立的Java程序还是相对少见。这是因为Java平台的运行开销较大，而许多人的电脑上没有安装Java，由于网络带宽在以前较小，下载Java曾经是个耗时的事情。但是随着计算机计算能力、网络带宽在10年中取得了很大的进步，同时虚拟机和编译器的质量得到了提高，许多应用程序得到了广泛的使用，包括：\n\n开源软件\nNetBeans和Eclipse等軟件開發工具\nAndroid操作系统\nJEdit\nAzureus BitTorrent客户端。\nJNode操作系统\nApache軟件基金會的Ant、Derby、Hadoop、Jakarta、POI和Tomcat\nJBoss和GlassFish應用伺服器\n商業軟體\nEIOffice（永中Office）\nMinecraft\n纯Java 3D游戏合金战士Chrome\nIBM Websphere、ColdFusion和WebLogic\nIntelliJ IDEA\n目前Java提供以下三个版本：\n\nJava Platform, Enterprise Edition（Java EE：Java平台企业版）\nJava Platform, Standard Edition（Java SE：Java平台标准版）\nJava Platform, Micro Edition（Java ME：Java平台微型版）\nJava Platform, Card Edition\n\nJava開放原始碼項目\n2006年昇陽電腦在JavaOne公佈Java 開放原始碼項目，並推出OpenJDK计划。Java虛擬機、Java編譯器和Java類庫以GNU通用公共許可證公開。\n\n版本历史\n1995年5月23日，Java语言诞生\n1996年1月，第一个JDK-JDK1.0诞生\n1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术\n1996年9月，约8.3万个网页应用了JAVA技术来制作\n1997年2月18日，JDK1.1发布\n1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录\n1997年9月，JavaDeveloperConnection社区成员超过十万\n1998年2月，JDK1.1被下载超过2,000,000次\n1998年12月8日，JAVA2企业平台J2EE发布\n1999年6月，昇陽電腦发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）\n2000年5月8日，JDK1.3发布\n2000年5月29日，JDK1.4发布\n2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机\n2001年9月24日，J2EE1.3发布\n2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升\n2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0\n2005年6月，JavaOne大会召开，昇陽電腦公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME\n2006年12月，昇陽電腦发布JRE6.0\n2009年12月，昇陽電腦发布Java EE 6\n2010年11月，由於Oracle公司對於Java社群的不友善，因此Apache揚言將退出JCP\n2011年7月28日，Oracle公司發佈Java SE 7\n2014年3月18日，Oracle公司发布Java SE 8 (LTS)\n2017年9月21日，Oracle公司发布Java SE 9\n2018年3月21日，Oracle公司发布Java SE 10\n2018年9月25日，Oracle公司发布Java SE 11 (LTS)\n2019年3月，Oracle公司发布Java SE 12\n2019年9月，Oracle公司发布Java SE 13\n2020年3月，Oracle公司发布Java SE 14\n2020年9月，Oracle公司发布Java SE 15\n2021年3月，Oracle公司发布Java SE 16\n2021年9月，Oracle公司发布Java SE 17 (LTS)\n2022年3月，Oracle公司发布Java SE 18\n2022年9月，Oracle公司发布Java SE 19\n2023年3月，Oracle公司发布Java SE 20\n2023年9月，Oracle公司发布Java SE 21 (LTS)\n2024年3月, Oracle公司发布Java SE 22\n2024年9月, Oracle公司发布Java SE 23\n2025年3月, Oracle公司发布Java SE 24\n2025年9月, Oracle公司发布Java SE 25 (LTS)\n\n语言特性\nJava之所以被开发，是要达到以下五个目的：\n\n应当使用面向对象程序设计方法学\n应当允许同一程序在不同的计算机平台执行\n应当包括内建的对计算机网络的支持\n应当被设计成安全地执行远端代码\n应当易于使用，并借鉴以前那些面向对象语言（如C++）的长处。\nJava技术主要分成几个部分：Java语言、Java執行環境、类库。一般情况下说Java时并不区分指的是哪个部分。\nJava在1.5版本時，做了重大改變，昇陽電腦並1.5版本重新命名為Java 5.0。\n\n面向对象\nJava的特点之一就是面向对象，是程序设计方法的一种。“面向对象程序设计语言”的核心之一就是开发者在设计软件的时候可以使用自定义的类型和关联操作。代码和数据的实际集合体叫做“对象”。一个对象可以想象成绑定了很多“行为（代码）”和“状态（数据）”的物体。对于数据结构的改变需要和代码进行通信然后操作，反之亦然。面向对象设计让大型软件工程的计划和设计变得更容易管理，能增强工程的健康度，减少失败工程的数量。\n\n跨平台性\n跨平台性是Java主要的特性之一，跨平台使得用Java语言编写的程序可以在编译后不用经过任何更改，就能在任何硬件设备条件下运行。这个特性经常被称为“一次编译，到处运行”。\n执行Java应用程式必须安装Java 运行时环境（Java Runtime Environment，JRE），JRE包括Java虚拟机（Java Virtual Machine，JVM），以及Java平台核心类和基础Java 平台库。通过JVM才能在电脑系统执行Java应用程序（Java Application），这与.Net Framework的情况一样，所以电脑上没有安装JVM，那么这些java程序将不能够执行。\n实现跨平台性的方法是大多数编译器在进行Java语言程序的编码时候会生成一个用字节码写成的“半成品”，这个“半成品”会在Java虚拟机（解释层）的帮助下运行，虚拟机会把它转换成当前所处硬件平台的原始代码。之后，Java虚拟机会打开标准库，进行数据（图片、线程和网络）的存取工作。主要注意的是，尽管已经存在一个进行代码翻译的解释层，有些时候Java的字节码代码还是会被JIT编译器进行二次编译。\n有些编译器，比如GCJ，可以自动生成原始代码而不需要解释层。但是这些编译器所生成的代码只能应用于特定平台。并且GCJ目前只支持部分的Java API。\n甲骨文公司对于Java的许可是“全兼容的”，这也导致了微软和昇陽電腦关于微软的程序不支持RMI和JNI接口、并且增加特性为己所用的法律争端。昇陽電腦最终赢得了官司，获得了大约两千万美元的赔偿，法院强制要求微软执行昇陽電腦关于Java的许可要求。作为回应，微软不再在Windows系统中捆绑Java，最新的Windows版本，Windows Vista和Internet Explorer 7.0版本也不再提供对于Java应用程序和控件的支持。但是昇陽電腦和其他使用Java运行时系统的公司在Windows操作系统下对用户提供无偿的第三方插件和程序支持。\nJava语言在最开始应用的时候是没有解释层的，所有需要编译的代码都直接转换成机器的原始代码。这样做虽然使程序获得了最佳的性能，但是导致程序异常臃肿。从JIT技术开始，Java的程序都经过一次转换之后才变成机器码。很多老牌的第三方虚拟机都使用一种叫做“动态编译”的技术，也就是说虚拟机实时监测和分析程序的运行行为，同时选择性地对程序所需要的部分进行编译和优化。所有这些技术都改善了代码的运行速度，但是又不会让程序的体积变得失常。\n程序的轻便性事实上是软件编写很难达到的一个目标，Java虽然成功地实现了“一次编译，到处运行”，但是由于平台和平台之间的差异，所编写的程序在转换代码的时候难免会出现微小的、不可察觉的错误和意外。有些程序员对此非常头疼，他们嘲笑Java的程序不是“一次编译，到处运行”，而是“一次编译，到处调试”。以Java AWT為例，早期Java AWT內提供的按鈕、文字區等均是以電腦系統所預設的樣式而顯示。這令Java程式在有些沒有提供圖案的電腦系統產生錯誤（在Microsoft Windows設有視窗管理員，在一些Linux distribution則沒有）。後來昇陽電腦針對Java AWT一些問題而推出Java Swing。\n平台无关性让Java在服务器端软件领域非常成功。很多服务器端软件都使用Java或相关技术建立。\n\n自動垃圾回收（Garbage Collection）\nC++語言被用戶詬病的原因之一是大多數C++編譯器不支持垃圾收集機制。通常使用C++編程的時候，程式設計師於程式中初始化對象時，會在主機記憶體堆疊上分配一塊記憶體與位址，當不需要此對象時，進行解構或者刪除的時候再釋放分配的記憶體位址。如果對象是在堆疊上分配的，而程序員又忘記進行刪除，那麼就會造成記憶體洩漏（Memory Leak）。長此以往，程序運行的時候可能會生成很多不清除的垃圾，浪費了不必要的記憶體空間。而且如果同一記憶體地址被刪除兩次的話，程序會變得不穩定，甚至崩潰。因此有經驗的C++程序員都會在刪除之後將指標重置為NULL，然後在刪除之前先判斷指標是否為NULL。\nC++中也可以使用「智慧指標」（Smart Pointer）或者使用C++託管擴展編譯器的方法來實現自動化記憶體釋放，智慧指標可以在標準類庫中找到，而C++託管擴展被微軟的Visual C++ 7.0及以上版本所支持。智慧指標的優點是不需引入緩慢的垃圾收集機制，而且可以不考慮線程安全的問題，但是缺點是如果不善使用智慧指標的話，性能有可能不如垃圾收集機制，而且不斷地分配和釋放記憶體可能造成記憶體碎片，需要手動對堆進行壓縮。除此之外，由於智慧指標是一個基於模板的功能，所以沒有經驗的程序員在需要使用多態特性進行自動清理時也可能束手無策。\nJava語言則不同，上述的情況被自動垃圾收集功能自動處理。對象的建立和放置都是在記憶體堆疊上面進行的。當一個物件沒有任何引用的時候，Java的自動垃圾收集機制就發揮作用，自動刪除這個物件所佔用的空間，釋放記憶體以避免記憶體洩漏。\n注意程式設計師不需要修改finalize方法，自動垃圾收集也會發生作用。但是記憶體洩漏並不是就此避免了，當程序員疏忽大意地忘記解除一個物件不應該有的引用時，記憶體洩漏仍然不可避免。\n不同廠商、不同版本的JVM中的記憶體垃圾回收機制並不完全一樣，通常越新版本的記憶體回收機制越快，IBM、BEA、昇陽電腦等等開發JVM的公司都曾宣稱過自己製造出了世界上最快的JVM，JVM性能的世界紀錄也在不斷的被打破並提高。\nIBM有一篇有關Java記憶體回收機制比不啟用垃圾收集機制的C++記憶體處理快數倍的技術文章，而著名的Java技術書籍《Java編程思想》（Thinking in Java）也有一段論述Java記憶體及性能達到甚至超過C++的章節。\n\n基本语法\n编写Java程序前应注意以下几点：\n\n大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。\n类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如MyFirstJavaClass。\n方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写，例如myFirstJavaMethod。\n源文件名：源文件名必须和文件内名字唯一且公开(由public 关键词修饰)的类名相同。当保存文件的时候，你应该使用该类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。\n主方法入口：所有的Java程序由public static void main(String[] args)方法开始执行。\n\nJava关键字\n下面列出了Java关键字。这些关键字不能用于常量、变量、和任何标识符的名称。\n\n注释\n注释的作用：标识程序是干什么的，以及它是如何构建的。注释帮助程序员进行相互沟通以及理解程序。注释不是程序设计语言，所以编译器编译程序时忽略它们。\n\n接口和类別\nJava自带了创建接口的类別，可以这样使用：\n\n这段代码的意思是任何实现（implement）Deleteable接口的类別都必须实现delete()方法。每个类別对这个方法的实现可以自行定制。由此概念可以引出很多种使用方法，下面是一个类別的例子：\n\n在另外一个类別中，可以使用这样的代码：\n\n因为队列中所有的对象都可以使用delete()方法。Deleteable队列中包含Fred对象的引用，而这个类別和其他Deleteable类別在使用deleteAll()方法时候不需要进行任何改变。\n之所以这样做就是为了在接口的执行和其代码之间进行区别。举例来说，一个名叫Collection的接口可以包含任何对象所需要的引入、转换和存储数据的方法，其他的类都可以使用这个接口。但是这个接口可以是一个可重定义大小的队列、一个链表或者是其他功能的集合。\n这种特性其实是一种折中的办法。Java的设计者们不想让Java有多重继承的特性，因为C++的多重继承显示了这种特性的困难。Java的接口功能可以提供同样的功能，但是又不会很复杂。\n\n应用程序开发接口\n在Java语言中，应用程序接口（API）化身成类，并且分组成为包。每个包中包含有相关的接口和类。对于不同的平台，Java提供了不同版本的包。API的设定由昇陽電腦和其他公司通过JCP（Java社群程序）决定。任何公司和个人都可以参与这个工程，对API进行设计。2004年，IBM和BEA公司准备联合对官方的Java开源软件工程进行支持，但是2005年初，昇陽電腦拒绝了这个支持。\n\nHello World\n下面这个程序显示“Hello world!”然后结束运行，注意java.lang套件是自動載入的，所以不需要在程式之前加入import java.lang.*;\n\n關於Java的批評\nJava試圖通過新的方式解決軟體編寫的複雜性。很多人認為Java語言做到了它承諾的一切，然而，某些情况下，Java会将简单问题导向复杂化。尽管Java並不是一門完美的語言，但它的出现确实给大规模软件协同开发提供了新的思路。\n\n整體性問題\n並不是所有的工程和環境需要企業等級的複雜性，比如一個簡單的個人網站或者獨自編程的程式師所寫的程式。這些程式師會發現Java的複雜管理對於自己要做的程式來說過於強大了。一些人覺得Java在物件導向上面做的沒有Ruby和Smalltalk純粹。但是最新出現的用Java實現的語言Groovy解決了這些問題。\n作為一種已經建立的新技術，Java顯然綜合了很多語言的特性，比如C++、C語言、Python等等。一些對於Java的評論認為Java的不變性在動搖。\n\n語言問題\n有些程式師不喜歡原始類型（primitive type）和類別（class）的分離，尤其是那些曾經使用過Smalltalk和Ruby的程序员。Java的代碼相對於其他的代碼來說過於冗長，這與它的輕便化聲明相違背。此外Java一般也會默認式的自動植入過多的標準庫代碼,導致整體運行會出現緩慢\nJava是一種單繼承的語言。這也導致了程式師在試圖使用多重繼承時候的不便，而很多語言都可以使用這個特性。但是Java可以使用介面類，把多重繼承可能導致的風險減少到最小。Java不支持運算符重載，這是為了防止運算符重載使得代碼的功能變得不清晰。但是用Java實現的語言Groovy可以進行運算符重載。過去Java對於文本的操作和其他語言，比如Perl和PHP相比差的較多，但Java在1.4版本時候引入了正则表达式。\n至Java 1.7为止，Java语言不支持闭包（closure）和混入（mixin）特性。\nJava 1.8加入lambda表达式（Lambda Expressions）。\n\n類庫問題\n使用Swing平臺編寫的帶有GUI（圖形用戶介面）的程式和其他原始程式非常不同。選用AWT工具包編寫程式的程式師看到的都是原始介面，而且也無法獲得先進的GUI編程支援，如果使用的話，就要提供每個平臺上面所需的API，這將是一項龐大的工程。Swing則是完全用Java語言所寫的程式，避免了介面元素重複的問題，只使用所有平臺都支持的最基本的繪圖機制。但是很多用戶不知道如何在Java風格和Windows風格之間進行轉換，結果造成了Java程式的介面在很多程式中非常特殊。蘋果電腦已經提供了優化過的Java運行時程式，包含了Mac OS X的經典Aqua介面風格。\n在IBM捐赠给Eclipse基金会的SWT界面框架中，用户会看到熟悉的本地风格界面。但这又引起了不同喜好的开发人员之间的争论。\n\n性能問題\n由於Java編譯器和虛擬機的不同對Java代碼的性能影響比語言本身的影響大的多，所以統一討論Java的程式的性能經常是有誤導性的。據IBM的資料，在同樣的硬體上2001年時的IBM JDK版本的性能是1996年的JDK版本的十倍左右。而即使是在同一時期，不同公司的JDK和JRE的性能也不一樣，比如昇陽電腦、IBM、BEA等公司都有自己開發的JDK和JRE。\nJava語言的一些特性不可避免的有額外的性能代價，例如陣列範圍檢查、運行時類型檢查等等。Java程式的性能還會因為不同的動態複雜性和垃圾處理機制使用的多少而各有不同。如果JVM的實現比較優化的話，那麼這些功能甚至可以增加記憶體分配的性能。這和總是使用STL或者託管C++的程式的情況類似。\n儘管如此，仍然有許多人認為Java的性能低。這部分歸因於昇陽電腦最初的JVM實現使用未優化的解釋機制來執行位元組碼。一些新版本的JVM使用Just-In-Time（JIT）編譯器，在載入位元組碼的時候將其編譯成針對運行環境的本地代碼來實現一些本地編譯器的優化特性。Just-In-Time機制和本地編譯的性能比較仍舊是一個有爭議的話題。JIT編譯需要很多時間，對於運行時間不長或者代碼很多的大型程式並不適宜。但是不算JIT編譯階段的話，程式的運行性能在很多JVM下可以和本地編譯的程式一爭短長，甚至在一些計算比較密集的數值計算領域也是這樣。目前，Java已經使用更先進的HotSpot技術來代替JIT技術，Java的性能有了更進一步的提升。另外，在使用-server選項運行Java程式時，也可以對Java進行更深入的優化，比如在運行時將調用較多的方法內聯（inline）到程式中來提高運行速度，這就是所謂的“動態優化”，而本地編譯器是無法做到這一點的；這也是一些Java代碼比對應用C/C++等語言編寫的本地代碼運行的更快的原因之一。微軟的.NET平臺也使用JIT編譯器，所以也有類似問題。\nJava的設計目的主要是安全性和可攜性，所以對於一些特性，比如對硬體架構和記憶體位址的直接訪問都被去除了。如果需要間接調用這些底層功能的話，就需要使用JNI（Java本地介面）來調用本地代碼，而間接訪問意味著頻繁調用這些特性時性能損失會很大，微軟的.NET平臺也有這樣的問題。所以到目前為止，性能敏感的代碼，例如驅動程式和3D电子游戏，還是大多使用本地編譯，甚至直接以不直接支援面向对象的C語言或機器碼編寫。但最近已經有了許多用純Java編寫的3D遊戲，其效果與用C語言編寫的不相上下，例如“合金戰士”（英文名：Chrome）。這主要是因為新版的Java 3D技術已經能像C++一樣調用硬體加速，也就是使用顯卡來加速，無論是C++還是Java語言寫的3D遊戲都是使用顯卡及GPU來處理，從而使得CPU可以專注於其他方面的工作。\n\n用途\n桌面GUI应用程序：\nJava通过抽象窗口工具包（AWT），Swing和JavaFX等多种方式提供GUI开发。虽然AWT包含许多预先构建的组件，如菜单，按钮，列表以及众多第三方组件，但Swing（一个GUI小部件工具包）还提供某些高级组件，如树，表格，滚动窗格，选项卡式面板和列表。JavaFX是一组图形和媒体包，提供了Swing互操作性，3D图形功能和自包含的部署模型，可以快速编写Java小应用程序和应用程序的脚本。\n\n移动应用程序：\nJava Platform，Micro Edition（Java ME或J2ME）是一个跨平台框架，用于构建可在所有Java支持的设备（包括功能手机和智能手机）上运行的应用程序。此外，最受欢迎的移动操作系统之一的Android应用程序通常使用Android软件开发工具包（SDK）或其他环境在Java中编写脚本。\n\n嵌入式系统：\n从微型芯片到专用计算机的嵌入式系统是执行专门任务的大型机电系统的组件。诸如SIM卡，蓝光光盘播放器，公用事业仪表和电视机等多种设备都使用嵌入式Java技术。据甲骨文公司称，100％的蓝光光盘播放器和1.25亿台电视设备都采用Java技术。\n\nWeb应用程序：\nJava通过Servlets，Struts或JSP提供对Web应用程序的支持。编程语言提供的简单编程和更高的安全性使得大量政府应用程序可用于基于Java的健康，社会安全，教育和保险。Java也可以使用Broadleaf等开源电子商务平台开发电子商务Web应用程序。\n\n分布式系统：\nJava更多时候用于构建大型分布式应用, 基于Java的分布式生态非常丰富, 各种成熟的基础组件帮助Java开发者迅速搭建起分布式系统. 比较著名的分布式框架有: Spring Cloud, Dubbo, ZooKeeper等。\n\nWeb服务器和应用程序服务器：\n今天的Java生态系统包含多个Java Web服务器和应用程序服务器。虽然Apache Tomcat，Simple，Jo !, Rimfaxe Web服务器（RWS）和Project Jigsaw占据了Web服务器空间，但WebLogic，WebSphere和Jboss EAP在商业应用服务器领域占据重要地位。\n\n企业应用程序：\nJava企业版（Java EE）是一种流行的平台，为脚本和运行企业软件（包括网络应用程序和Web服务）提供API和运行时环境。甲骨文宣称Java可以在97％的企业计算机上运行。Java凭借更高的性能保证和更快的计算能力使得像Murex这样的高频交易系统可以被编入脚本中。同时它也是各种银行应用程序的中枢，它们将Java从前端用户端运行到后端服务器端。\n\n科学应用：\nJava是许多软件开发人员用于编写涉及科学计算和数学运算的应用程序的选择之一。这些程序通常被认为是快速和安全的，具有更高的便携性和低维护性。像MATLAB这样的应用程序使用Java来作为交互用户界面和作为核心系统的一部分。\n\n参见\n註釋\n參考文獻\n引用\n来源\n外部链接\n\nJava官方网站 （页面存档备份，存于互联网档案馆）"}
{"title": ".NET Framework", "text": ".NET框架（英語：.NET Framework）是由微軟開發，一個致力於敏捷軟體開發（agile software development）、快速應用開發（rapid application development）、平臺獨立性和網路透明化的軟體框架。.NET是微軟為2000年代對伺服器和桌上型軟體工程邁出的第一步。.NET包含許多有助於互聯網和內部网应用迅捷发的技術。\n.NET框架是微軟公司继Windows DNA之后的新发平台，採用系統虛擬機器運行，以通用語言運行庫（Common Language Runtime）为基础，支援多种語言（C#、F#、VB.NET、C++、Python等）的開发。\n.NET也为應用程式介面（API）提供了新功能和发工具。這些革新使得程式設計員可以同時進行Windows應用軟體和網路應用軟體以及元件和服務（web服務）的開發。.NET提供了一個新的反射性的且物件導向程式設計編程介面。.NET設計得足夠通用化從而使許多不同高阶語言都得以被汇集。\n甲骨文公司的Java程式語言和Java平台企業版技术是.NET平台的竞爭对手之一。\n2014年11月12日，微軟宣布完全开放.NET Framework的原始碼，並提供給Linux和macOS使用。 微軟於2019年4月釋出了該框架作為專有軟體的最後一個主要版本 .NET Framework 4.8，隨後於 2022年8月釋出了 4.8.1。從此之後便只有安全性或是穩定性的臭蟲修復更新，亦無後續版本改動的計畫。.NET Framework 4.8將會持續包含在Windows的更新中接收安全性更新，截至2023年11月為止，並無將其移除的計畫。官方推薦後續的新開發改用 .Net 6 起的版本進行開發。\n\n版本\n發行歷史\n.NET Framework 1.0\n完整版號 - 1.0.3705\n這是最早的.NET架構，於2002年發行。它可以以一個獨立且可重新分發的包的形式或在一個軟體發展工具包集中被獲得。它也是第一個微軟Visual Studio .NET的發行版的一部分（也被稱作Visual Studio .NET 2002）。\n\n.NET Framework 1.1\n完整版號 - 1.1.4322\n這是首個主要的.NET框架升級版本，發行於2003年。它可以以一個獨立的可重新分發的包的形式或在一個軟體發展工具包集中被獲得。它也是第二個微軟Visual Studio .NET版本的一部分（也被稱作Visual Studio .NET 2003）。它也是首個被Windows作業系統-Windows Server 2003所內置的.NET框架版本。\n自1.0版本以來的改進：\n\n內建了對mobile ASP.NET控制項的支援。這在1.0版本是以附加功能方式實現的，現在已經集成到框架的內部。\n安全方面的變更 - 使得Windows表單代碼以可靠的行為執行，從而可以在Internet環境內安全運行，並且加入了ASP.NET應用程式的代碼安全訪問功能。\n內建了對ODBC和Oracle資料庫的支援。這在1.0版本是以附加功能方式實現的，現在已經集成到框架的內部。\n.NET Compact Framework- 這是一個用於智慧設備（例如Pocket PC或者SmartPhone）的.NET框架的子集。\n對IPv6的支持。\n大量的API變更。\n\n.NET Framework 2.0\n完整版號 - 2.0.50727.42，發行於2005年10月27日。\n.NET Framework 2.0的元件都包含在 Visual Studio 2005和SQL Server 2005里面。通過MSDN Universe版可以免費下載RTM版本。\n自1.1版本以來的改進：\n\n大量的API變更。\n新的API讓需要管理.NET運行庫實例的非.NET的應用程式可以做到這點。這個新的API對.NET運行庫的各種功能，包括：多線程、記憶體分配、代碼載入等，提供了很好的控制。它最初是為Microsoft SQL Server能夠有效率的使用.NET運行庫而設計的，因為Microsoft SQL Server擁有它自己的日程管理器和記憶體管理器。\n\n.NET Framework 3.0\n發佈日期2006/11/21。曾用名「WinFX」。依然使用.NET Framework 2.0版本的公共語言運行庫（CLR），並加入了適應未來軟體發展方向的4個框架：\n\nWindows Presentation Foundation（WPF）：提供更佳的用戶體驗，用來開發Windows Forms程式以及浏览器應用程式（參見WPF/E）.\nWindows Communication Foundation（WCF）：提供SOA（面向服務的軟體構架）支援的安全的網路服務（Web Service）框架。\nWindows Workflow Foundation（WF）：提供一個設計與發展工作流程導向（Workflow-oriented）應用程式基礎支援的應用程式介面。\nWindows CardSpace：提供一個SSO的解決方案，每個使用者都有各自的CardSpace。\n\n.NET Framework 3.5\n這個版本將包含一個支持C#和VB.Net中心的語言特性的編譯器，以及對語言整合查詢（LINQ, Language-Integrated Query）的支援。該版本隨Visual Studio 2008一起發佈。\n同时，.NET Framework 3.5自动包含.NET Framework 2.0 SP1以及.NET Framework 3.0 SP1，用于为这两个版本提供安全性修复，以及少量新增的类库（如System.DateTimeOffest），此版本提供的新功能有：\n\n扩展方法（Extension Method）属性（Attribute），用于为扩展方法提供支持\nLINQ支持，包括LINQ to Object、LINQ to ADO.NET以及LINQ to XML\n表达式目录树（Expression Tree），用于为Lambda表达式提供支持\n与语言集成查询（LINQ）和数据感知紧密集成。借助这个新功能，您可以使用相同的语法，在任何支持LINQ的语言中编写相关代码，以筛选和枚举多种类型的SQL数据、集合、XML和数据集，以及创建它们的投影。\n利用ASP.NET AJAX可以创建更有效、更具交互性、高度个性化的Web体验，这些体验在所有最流行的浏览器上都能实现。\n用于生成WCF服务的全新Web协议支持，包括AJAX、JSON、REST、POX、RSS、ATOM和若干新的WS-*标准。\nVisual Studio 2008中面向WF、WCF和WPF的完整工具支持，其中包括支持工作流的服务这一新技术。\n.NET Framework 3.5基类库（BCL）中的新类可满足许多常见的客户请求。\n\n.NET Framework 3.5 SP1\n.NET Framework 3.5 SP1自动包含.NET Framework 2.0 SP2以及.NET Framework 3.0 SP2。该版本随Visual Studio 2008 SP1发布，此版本提供了下列的新功能：\n\n新增的ASP.NET功能包括ASP.NET动态数据和ASP.NET AJAX附加功能，前者提供了无需编写代码就可实现数据驱动的快速开发的丰富支架框架，后者为管理浏览器历史记录提供了支持（后退按钮支持）。\nADO.NET Entity Framework。\n对SQL Server 2008的数据提供程序支持。\n.NET Framework客户端配置文件是完整版.NET Framework的子集，面向客户端应用程序。这改善了尚未安装.NET Framework的计算机上的安装体验。\n改进Windows Presentation Foundation的性能，其中包括启动速度的位图效果性能的提高。为Windows Presentation Foundation增加的功能包括对业务线应用程序的更好支持、本机闪屏支持、DirectX像素着色器支持以及新的WebBrowser控件。\nClickOnce应用程序发布者可以根据具体情况决定是否取消签名和散列，开发人员可以以编程方式安装显示自定义署名的ClickOnce应用程序，ClickOnce错误对话框支持指向网络上特定于应用程序的支持站点的链接。\n用于SQL Server的.NET Framework数据提供程序（System.Data.SqlClient）完全支持SQL Server 2008数据库引擎的所有新功能。有关.NET Framework对SQL Server 2008的支持的更多信息，请参见SQL Server中的新功能（ADO.NET）。ADO.NET数据平台是一种多版本策略，它使开发人员能够针对概念性实体数据模型进行编程，从而减轻他们的编码和维护工作。此平台提供了ADO.NET Entity Framework、实体数据模型（EDM）、对象服务、LINQ to Entities、Entity SQL、EntityClient、ADO.NET数据服务及实体数据模型工具。\nWindows Communication Foundation现在提供了改进的互操作性支持，增强了部分信任方案中的调试体验，并扩展了整合协议支持以更广泛地应用于Web 2.0应用程序，从而使DataContract序列化程序更易于使用。\nMicrosoft.VisualBasic.PowerPacks命名空间引入了新的DataRepeater控件，该控件以可自定义的列表格式显示数据。此命名空间还包含新的矢量形状。\n\n.NET Framework 4.0\n.NET Framework 4.0主要增加了并行支持，英文版於2010年4月12日推出。\n新增System.Lazy <T>，做為延遲初始化時使用。\n新增大整數的System.Numerics.BigInteger與複數的System.Numerics.Complex（使用時需加入參考System.Numerics.dll）\n微軟於2016年1月12開始停止對.NET 4.0, 4.5, 4.5.1的安全性更新及技術支援\n\n.NET Framework 4.5\n.NET Framework 4.5是.NET Framework 4高相容性的置位更新（in-place update）。搭配C# 或Visual Basic程式設計語言使用.NET Framework 4.5，即可編寫Windows Store風格的應用程式。.NET Framework 4.5可提升效能、可靠度及安全性。於2012年8月15日推出。但請注意，.NET Framework 4.5只支援Windows Vista SP2以上版本的作業系統。\n\n微軟於2016年1月12開始停止對.NET 4.0, 4.5, 4.5.1的安全性更新及技術支援\n\n.NET Framework 4.5.1\n.NET Framework 4.5.1於2013年10月17日隨著Visual Studio 2013發布。此版本需要Windows Vista SP2或更新的環境，並且包含在Windows 8.1和Windows Server 2012 R2中。.NET Framework 4.5.1的新功能有：\n\n偵錯器支持X64編輯和繼續（EnC）\n偵錯器支持查看託管返回值\n“Call Stack”和“Task”視窗中的異步感知偵錯\n偵錯器支持分析.NET內存轉儲（在Visual Studio Ultimate SKU中）\n適用於Performance 及 Diagnostics中心的.NET開發者工具\n代碼分析UI改進\nADO.NET空閒連接彈性\n\n.NET Framework 4.5.2\n.NET Framework 4.5.2的發表宣佈於2014年5月5日。此版本需要Windows Vista SP2及更新版本。對於Windows Forms應用程序，對高DPI方案進行了改進。對於ASP.NET，可以使用更高可靠性的HTTP開頭檢查和修改方法，這是一種規劃背景異步工作任務的新方法。\n\n.NET Framework 4.6\n.NET Framework 4.6 是在2014年11月12月宣佈，而在2015年7月20日發行。 它對64位元系統支援一個新的即時編譯（JIT），稱之為 RyuJIT，呈現較佳的性能，並支援SSE2與AVX2指令集。WPF 與 Windows Forms 都獲得更新以達成較高的 DPI 情境。支援TLS 1.1 與 TLS 1.2 的功能已經被加入 WCF。 此版本需要Windows Vista SP2 或更新的版本。\n\n.NET Framework 4.6.1\n.NET Framework 4.6.1 發行的訊息在2015年11月30日宣佈。這個版本需要 Windows 7 SP1 或更新的版本。新的功能與 API 包括：\n\nWPF改進了拼寫檢查，支援用戶自定義詞典，並改進觸控性能。\n增強支援橢圓曲線數字簽名算法（ECDSA）X509 認證。\n當連接Azure SQL數據庫時，添加了對AlwaysOn、Always Encrypted的SQL連接，並改進連接開放彈性。\nAzure SQL數據庫現在使用更新的System.Transactions API支援分散式處理。\nRyuJIT、GC、WPF和WCF中的許多其他性能、穩定性和可靠性相關修復。\n\n.NET Framework 4.6.2\n.NET Framework 4.6.2 的預覽在2016年3月30日宣佈，發行日期則為2016年8月2日。此版本需要 Windows 7 SP1 或更新版。 New features include:\n\n支援超過260個字符的路徑\n支援X.509認證的FIPS 186-3 DSA\nTLS 1.1 / 1.2支援 ClickOnce\n支援 ASP.NET 數據註釋的本地化\n啟用具備 Project Centennial 的 .NET桌面應用程序\n針對WPF支援軟鍵盤和每個監視器DPI\n\n.NET Framework 4.7\n2017年4月5日，微軟宣佈 .NET Framework 4.7 將被整合到 Windows 10 創作者更新, 承諾為其他Windows版本提供獨立安裝程式。同日，發行一個 Visual Studio 2017 更新版以加強支援標的物 .NET Framework 4.7。 所承諾的 Windows 7 及更新版本獨立安裝程式在2017年5月2日發行， 但有一些重要成份不包含在內。\n.NET Framework 4.7 的新功能包括：\n\n使用橢圓曲線密碼學的增強加密\n改進對傳輸層安全性協定（TLS）的支援，尤其是對於1.2版\n支援Windows Forms 的高DPI感知支援\n在 WPF 中對觸控和手寫的更多支援\nWPF 的新印表 API\n\n.NET Framework 4.7.1\n.NET Framework 4.7.1 在2017年10月17日發行。在修復程式和新功能中，它修正了d3dcompiler依賴性問題。 \n它還增加了與.NET Standard 2.0開箱即用的相容性。\n\n.NET Framework 4.7.2\n.NET Framework 4.7.2 在2018年4月30日發行。主要的異動是改進 ASP.NET、BCL、CLR、ClickOnce、Networking、SQL、WCF、Windows Forms、Workflow 及 WPF。\n\nCLR與CLI\n.NET的初級組成是CLI（通用語言架構）和CLR（通用語言運行庫）。\nCLI（通用語言架構）全名為Common Language Infrastructure，是一套運作環境規範，包括一般系統、基礎類庫和與機器無關的中間代碼。CLR則是確認操作密碼符合CLI的平臺。在通用中間語言（CIL）執行前，CLR必須將指令及時編譯轉換成原始機械碼。\n所有CLI都可經由.NET自我表述。CLR檢查元資料以確保正確的方法被調用。元資料通常是由語言編譯器生成的，但開發人員也可以通過使用客戶屬性創建他們自己的元資料。\n如果一種語言實現生成了CLI，它也可以通過使用CLR被調用，這樣它就可以與任何其他.NET語言生成的資料相交互。CLR也被設計為作業系統無關性。\n當一個彙編體被載入時，CLR執行各種各樣的測試。其中的兩個測試是確認與核查。在確認的時候，CLR檢查彙編體是否包含有效的元資料和CIL，並且檢查內部表的正確性。核查則不那麼精確。核查機制檢查代碼是否會執行一些“不安全”的操作。核查所使用的演算法非常保守，導致有時一些“安全”的代碼也通不過核查。不安全的代碼只有在彙編體擁有“跳過核查”許可的情況下才會被執行，通常這意味著代碼是安裝在本機上的。\n通過.NET，你可以用SOAP和不同的web服務進行交互。\n\n標準化和版權\n2000年8月，微軟、惠普和英特爾共同制定CLI和C#程式語言的標準規格。2001年12月，以上兩者通過並成為ECMA標準規格。（ECMA 335（页面存档备份，存于互联网档案馆）和ECMA 334（页面存档备份，存于互联网档案馆））。ISO亦於2003年4月跟隨（ISO/IEC 23271（页面存档备份，存于互联网档案馆）和ISO/IEC 23270（页面存档备份，存于互联网档案馆））。\n這會有一定的風險，但它可以鼓勵標準聯合的實現，以提供一座橋樑來把非Windows的軟體轉變為微軟.NET。將此推廣為標準的一個團體是國際.NET聯合會（INETA）。\n儘管微軟及其他合作夥伴持有CLI及C#的專利，ECMA和ISO要求所有專利都應該遵守“合理與非歧視準則”。除此之外，這些公司亦同意讓使用者免費使用這兩項專利。\n不過，這並不包括.NET Framework內並不為ECMA/ISO標準涵蓋的範圍，這包括了：Windows Forms、ADO.NET及ASP.NET。微軟對上述部件所持有的專利，使開發者未必能夠為非微軟平臺開發出一套完整的作品。\n2014 年11月13日，微軟新任執行長薩帝亞·納德拉決心下，該公司釋出的.NET原始碼包含了伺服器部分的核心，如.NET Framework Libraries、.NET Core Framework Libraries和RyuJit VM，正式對外開放原始碼。\n\n.NET与Java EE\n公共語言基礎（CLI），通用中間語言（CIL）以及C#與甲骨文公司的Java虛擬機和Java之間有不少的相似之處，因此它們無疑是強烈的競爭者。它們兩者都使用它們各自的中間碼（在微軟，它們叫做通用中間語言，而在Oracle，它們叫位元組碼）。通用中間語言被設計來即時編譯（JIT），而Java的位元組碼在最初的時候則是設計成用於解釋運行，而非即時編譯。.NET現在只在Windows上被完美地支持，而Java則可在很多平臺上被完好支持。然而，現在一些正在開發中的實現版本例如Mono或者Shared source CLI可以用於在類Unix作業系統例如Linux，FreeBSD和Mac OS X上運行.NET應用程式。甲骨文公司的一個產品，J2EE提供與微軟的一些捆綁於Windows中的技術例如COM+（先前的MTS）和MSMQ等效的功能。\nJava和.NET可經由IKVM，一個在.NET平臺上實作的Java虛擬機作更多的溝通。\nJava有其專門的遠端程式呼叫技術RMI（Remote Method Invocation）, RMI的另一版本RMI-IIOP更可相容CORBA。\n然而，.NET與Java之間的競爭關係，在.NET Core出現後，一切都改觀了。\n\n.NET与COM\n前一版軟體元件技術由Microsoft所提出的COM，該技術被用來建立大型（large-scale）的軟體系統上，使用COM+ 或MTS對於傳統分散式元件有強化的作用。當.NET將COM-objects封裝成.NET元件以及將.NET元件封裝成COM-objects後，Microsoft分別將他命名為Runtime Callable Wrapper（RCW）和COM Callable Wrapper（CCW）。很明顯的，Microsoft最終將以.NET全面取代COM成為軟體元件的架構。Microsoft希望開發者能夠在Win32平臺上使用.Net取代COM，而已經存在的服務則透過抽象介面來使用（如：目前交易的.Net元件仍然使用COM+）。\n\n.Net Remoting与XML WebServices\n.NET remoting屬於行程（process）內溝通的抽象方法。\nMicrosoft® .NET Remoting提供一個豐富可擴充的框架給存在兩個不同AppDomain中的Object，使得在不同行程（行程）和不同機器中能夠進行無縫地溝通。.NET Remoting提供一種強大但簡單的可程式化模型並且在執行階段支援資料交換。\nXML Web services將基礎的功能區塊佈署到網路的不同電腦上。開放標準的通訊協定以及人和應用程式可以透過Web Services整合應用程式的環境來合作。應用程式可以從不同的來源使用多個XML Web Services來建構應用程式而不需要知道他們在哪裡以及如何來運作。\n\n.NET的語言\nCLI被設計成支援任何物件導向的程式語言，分享共同物件模型與大型共同類別庫。.NET支援超過40種程式語言。這些編譯器大都是免費的（软件廠商仅开发出售集成开发环境）。\n大部分的語言都做了重大改變以搭配.NET Framework。廠商通常利用這個機會來同時改變語言的其他特性。\n\n微軟開發的.NET平臺編程語言\nC#，一個以C++和Java語法為基礎開發的一個全新的物件導向語言，是.NET開發的首選語言。\nVisual Basic .NET，一個加強了物件導向支持的，支持多線程的Visual Basic版本。\nC++/CLI，一個C++的.NET平臺版本變種。\nJScript .NET，一個編譯版本的MicrosoftJScript語言。\nJ#，一個對應於Java和J++（微軟自己開發的Java變種）的.NET平臺版本，但是由于知识产权问题，目前微软公司已经停止其开发应用。\nF#，ML語言家族的一員。\nMicrosoft Small Basic\n\n第三方使用.NET的編程語言\nAda，參閱A#。\nAPL\nBoo，基於Python。\nCOBOL\nComponent Pascal，基於部件的Pascal，比起Pascal來更接近於Oberon。\nDelphi 8 and Delphi 2005以及现在的delphi xe2都采用.net\nEiffel\nForth\nFORTRAN\nIKVM，Java。\nIronPython，基於Python。\nIronRuby，基于Ruby。\nLexico，基於西班牙語的面向物件編程語言。\nLisp\nMercury (RemObjects BASIC programming language)\nMondrian為了便於腳本部件編程而開發的功能型語言。\nNemerle函數式／指令式混合語言。\nOberon\nPerl\nPhalanger，PHP的.net编译器。\nRPG\nSmalltalk\nTclBridge，基于Tcl。\nPowerBuilder.NET PowerBuilder 11.5及以后的版本都采用.net技术，但这种语言目前停止开发了。\n\nASP.NET & ADO.NET\nASP.NET是內含於.NET Framework中，專門用來發展Web應用程式的一組類別庫集。\nADO.NET是內含於.NET Framework中，專門處理與資料來源溝通的資料存取類別庫集，被Windows Forms與ASP.NET應用程式大量使用，可說是.NET Framework中唯一的資料存取介面。\n\n可供選擇的實現版本\n微軟的.NET Framework是.NET技術的旗艦級實現版本，在此之外還有一些其他實現版本。\n\n.NET Core 是微軟開發的跨平台 (Windows、Mac OSX、Linux) 的應用程式開發框架（Application Framework）\n微軟开发了一个称为共享源码公共语言基础（Shared Source Common Language Infrastructure，Shared Source CLI；即今ECMA—通用语言架构），是微軟的.NET Framework（共通語言執行平臺）的一個源碼共用的實現架构，可運行於Windows XP，FreeBSD，和Mac OS X10.2。\nMono是一個開源的.NET運行時和開發庫實現版本。Mono現正由xamarin公司和開源軟體發展社區負責開發。它正迅速發展成熟，現已經包含了對ASP.NET和ADO.NET的支持，对Windows Forms庫的支持也较充分。它提供了一個C#編譯器，而一個VB.NET編譯器現在也已經處於pre-beta階段。Mono項目還包含了一些新的庫和技術的開發：\nGtk：一個GTK+GUI工具包的.NET封裝。\nxSP：一個用C#編寫的支持運行ASP.NET應用程式的網頁伺服器軟體。\nMonoDevelop：SharpDevelop的一個移植版本，是一個符合GPL標準的面向Gtk#和Mono的.NET集成開發環境。\nNovell.Directory.Ldap類庫：Lightweight Directory Access Protocol（LDAP）for .NET的一個免費的實現版本。\nSerialPortNet：Aserial portlibrary for .Net & Mono implementing .NET 2.0 specifications.\nMono for Android和MonoTouch for iOS：Mono在移动平台Android和iOS上的移植，使开发者可以在Android和iOS平台上使用C#和Mono框架开发应用。Xamarin Forms是这些实现的核心，可以根据系统不同生成符合该系统风格的界面。\nMonoMac：Mono对于一些OS X原生Step API的封装。\nPortable.NET不及Mono成熟，這得歸因於Portable.NET並不是在最初的時候就使用了微軟的開發框架。提供了一个可以从C编译到通用中间语言的编译器。\n\n參見\nC#\nVB.NET\nASP.NET\nAJAX\nCOM Interop\nWindows API\n.NET Compact Framework\n.NET Micro Framework\n\n参考文献\n外部链接\n官方网站 \nOverview of .NET Framework (MSDN)（页面存档备份，存于互联网档案馆）（英文）\n.NET Framework 概述（页面存档备份，存于互联网档案馆）（简体中文）\n.NET Framework 的概觀（页面存档备份，存于互联网档案馆）（繁體中文）\n.NET Github repository（页面存档备份，存于互联网档案馆）"}
{"title": ".Net Framework", "text": ".NET框架（英語：.NET Framework）是由微軟開發，一個致力於敏捷軟體開發（agile software development）、快速應用開發（rapid application development）、平臺獨立性和網路透明化的軟體框架。.NET是微軟為2000年代對伺服器和桌上型軟體工程邁出的第一步。.NET包含許多有助於互聯網和內部网应用迅捷发的技術。\n.NET框架是微軟公司继Windows DNA之后的新发平台，採用系統虛擬機器運行，以通用語言運行庫（Common Language Runtime）为基础，支援多种語言（C#、F#、VB.NET、C++、Python等）的開发。\n.NET也为應用程式介面（API）提供了新功能和发工具。這些革新使得程式設計員可以同時進行Windows應用軟體和網路應用軟體以及元件和服務（web服務）的開發。.NET提供了一個新的反射性的且物件導向程式設計編程介面。.NET設計得足夠通用化從而使許多不同高阶語言都得以被汇集。\n甲骨文公司的Java程式語言和Java平台企業版技术是.NET平台的竞爭对手之一。\n2014年11月12日，微軟宣布完全开放.NET Framework的原始碼，並提供給Linux和macOS使用。 微軟於2019年4月釋出了該框架作為專有軟體的最後一個主要版本 .NET Framework 4.8，隨後於 2022年8月釋出了 4.8.1。從此之後便只有安全性或是穩定性的臭蟲修復更新，亦無後續版本改動的計畫。.NET Framework 4.8將會持續包含在Windows的更新中接收安全性更新，截至2023年11月為止，並無將其移除的計畫。官方推薦後續的新開發改用 .Net 6 起的版本進行開發。\n\n版本\n發行歷史\n.NET Framework 1.0\n完整版號 - 1.0.3705\n這是最早的.NET架構，於2002年發行。它可以以一個獨立且可重新分發的包的形式或在一個軟體發展工具包集中被獲得。它也是第一個微軟Visual Studio .NET的發行版的一部分（也被稱作Visual Studio .NET 2002）。\n\n.NET Framework 1.1\n完整版號 - 1.1.4322\n這是首個主要的.NET框架升級版本，發行於2003年。它可以以一個獨立的可重新分發的包的形式或在一個軟體發展工具包集中被獲得。它也是第二個微軟Visual Studio .NET版本的一部分（也被稱作Visual Studio .NET 2003）。它也是首個被Windows作業系統-Windows Server 2003所內置的.NET框架版本。\n自1.0版本以來的改進：\n\n內建了對mobile ASP.NET控制項的支援。這在1.0版本是以附加功能方式實現的，現在已經集成到框架的內部。\n安全方面的變更 - 使得Windows表單代碼以可靠的行為執行，從而可以在Internet環境內安全運行，並且加入了ASP.NET應用程式的代碼安全訪問功能。\n內建了對ODBC和Oracle資料庫的支援。這在1.0版本是以附加功能方式實現的，現在已經集成到框架的內部。\n.NET Compact Framework- 這是一個用於智慧設備（例如Pocket PC或者SmartPhone）的.NET框架的子集。\n對IPv6的支持。\n大量的API變更。\n\n.NET Framework 2.0\n完整版號 - 2.0.50727.42，發行於2005年10月27日。\n.NET Framework 2.0的元件都包含在 Visual Studio 2005和SQL Server 2005里面。通過MSDN Universe版可以免費下載RTM版本。\n自1.1版本以來的改進：\n\n大量的API變更。\n新的API讓需要管理.NET運行庫實例的非.NET的應用程式可以做到這點。這個新的API對.NET運行庫的各種功能，包括：多線程、記憶體分配、代碼載入等，提供了很好的控制。它最初是為Microsoft SQL Server能夠有效率的使用.NET運行庫而設計的，因為Microsoft SQL Server擁有它自己的日程管理器和記憶體管理器。\n\n.NET Framework 3.0\n發佈日期2006/11/21。曾用名「WinFX」。依然使用.NET Framework 2.0版本的公共語言運行庫（CLR），並加入了適應未來軟體發展方向的4個框架：\n\nWindows Presentation Foundation（WPF）：提供更佳的用戶體驗，用來開發Windows Forms程式以及浏览器應用程式（參見WPF/E）.\nWindows Communication Foundation（WCF）：提供SOA（面向服務的軟體構架）支援的安全的網路服務（Web Service）框架。\nWindows Workflow Foundation（WF）：提供一個設計與發展工作流程導向（Workflow-oriented）應用程式基礎支援的應用程式介面。\nWindows CardSpace：提供一個SSO的解決方案，每個使用者都有各自的CardSpace。\n\n.NET Framework 3.5\n這個版本將包含一個支持C#和VB.Net中心的語言特性的編譯器，以及對語言整合查詢（LINQ, Language-Integrated Query）的支援。該版本隨Visual Studio 2008一起發佈。\n同时，.NET Framework 3.5自动包含.NET Framework 2.0 SP1以及.NET Framework 3.0 SP1，用于为这两个版本提供安全性修复，以及少量新增的类库（如System.DateTimeOffest），此版本提供的新功能有：\n\n扩展方法（Extension Method）属性（Attribute），用于为扩展方法提供支持\nLINQ支持，包括LINQ to Object、LINQ to ADO.NET以及LINQ to XML\n表达式目录树（Expression Tree），用于为Lambda表达式提供支持\n与语言集成查询（LINQ）和数据感知紧密集成。借助这个新功能，您可以使用相同的语法，在任何支持LINQ的语言中编写相关代码，以筛选和枚举多种类型的SQL数据、集合、XML和数据集，以及创建它们的投影。\n利用ASP.NET AJAX可以创建更有效、更具交互性、高度个性化的Web体验，这些体验在所有最流行的浏览器上都能实现。\n用于生成WCF服务的全新Web协议支持，包括AJAX、JSON、REST、POX、RSS、ATOM和若干新的WS-*标准。\nVisual Studio 2008中面向WF、WCF和WPF的完整工具支持，其中包括支持工作流的服务这一新技术。\n.NET Framework 3.5基类库（BCL）中的新类可满足许多常见的客户请求。\n\n.NET Framework 3.5 SP1\n.NET Framework 3.5 SP1自动包含.NET Framework 2.0 SP2以及.NET Framework 3.0 SP2。该版本随Visual Studio 2008 SP1发布，此版本提供了下列的新功能：\n\n新增的ASP.NET功能包括ASP.NET动态数据和ASP.NET AJAX附加功能，前者提供了无需编写代码就可实现数据驱动的快速开发的丰富支架框架，后者为管理浏览器历史记录提供了支持（后退按钮支持）。\nADO.NET Entity Framework。\n对SQL Server 2008的数据提供程序支持。\n.NET Framework客户端配置文件是完整版.NET Framework的子集，面向客户端应用程序。这改善了尚未安装.NET Framework的计算机上的安装体验。\n改进Windows Presentation Foundation的性能，其中包括启动速度的位图效果性能的提高。为Windows Presentation Foundation增加的功能包括对业务线应用程序的更好支持、本机闪屏支持、DirectX像素着色器支持以及新的WebBrowser控件。\nClickOnce应用程序发布者可以根据具体情况决定是否取消签名和散列，开发人员可以以编程方式安装显示自定义署名的ClickOnce应用程序，ClickOnce错误对话框支持指向网络上特定于应用程序的支持站点的链接。\n用于SQL Server的.NET Framework数据提供程序（System.Data.SqlClient）完全支持SQL Server 2008数据库引擎的所有新功能。有关.NET Framework对SQL Server 2008的支持的更多信息，请参见SQL Server中的新功能（ADO.NET）。ADO.NET数据平台是一种多版本策略，它使开发人员能够针对概念性实体数据模型进行编程，从而减轻他们的编码和维护工作。此平台提供了ADO.NET Entity Framework、实体数据模型（EDM）、对象服务、LINQ to Entities、Entity SQL、EntityClient、ADO.NET数据服务及实体数据模型工具。\nWindows Communication Foundation现在提供了改进的互操作性支持，增强了部分信任方案中的调试体验，并扩展了整合协议支持以更广泛地应用于Web 2.0应用程序，从而使DataContract序列化程序更易于使用。\nMicrosoft.VisualBasic.PowerPacks命名空间引入了新的DataRepeater控件，该控件以可自定义的列表格式显示数据。此命名空间还包含新的矢量形状。\n\n.NET Framework 4.0\n.NET Framework 4.0主要增加了并行支持，英文版於2010年4月12日推出。\n新增System.Lazy <T>，做為延遲初始化時使用。\n新增大整數的System.Numerics.BigInteger與複數的System.Numerics.Complex（使用時需加入參考System.Numerics.dll）\n微軟於2016年1月12開始停止對.NET 4.0, 4.5, 4.5.1的安全性更新及技術支援\n\n.NET Framework 4.5\n.NET Framework 4.5是.NET Framework 4高相容性的置位更新（in-place update）。搭配C# 或Visual Basic程式設計語言使用.NET Framework 4.5，即可編寫Windows Store風格的應用程式。.NET Framework 4.5可提升效能、可靠度及安全性。於2012年8月15日推出。但請注意，.NET Framework 4.5只支援Windows Vista SP2以上版本的作業系統。\n\n微軟於2016年1月12開始停止對.NET 4.0, 4.5, 4.5.1的安全性更新及技術支援\n\n.NET Framework 4.5.1\n.NET Framework 4.5.1於2013年10月17日隨著Visual Studio 2013發布。此版本需要Windows Vista SP2或更新的環境，並且包含在Windows 8.1和Windows Server 2012 R2中。.NET Framework 4.5.1的新功能有：\n\n偵錯器支持X64編輯和繼續（EnC）\n偵錯器支持查看託管返回值\n“Call Stack”和“Task”視窗中的異步感知偵錯\n偵錯器支持分析.NET內存轉儲（在Visual Studio Ultimate SKU中）\n適用於Performance 及 Diagnostics中心的.NET開發者工具\n代碼分析UI改進\nADO.NET空閒連接彈性\n\n.NET Framework 4.5.2\n.NET Framework 4.5.2的發表宣佈於2014年5月5日。此版本需要Windows Vista SP2及更新版本。對於Windows Forms應用程序，對高DPI方案進行了改進。對於ASP.NET，可以使用更高可靠性的HTTP開頭檢查和修改方法，這是一種規劃背景異步工作任務的新方法。\n\n.NET Framework 4.6\n.NET Framework 4.6 是在2014年11月12月宣佈，而在2015年7月20日發行。 它對64位元系統支援一個新的即時編譯（JIT），稱之為 RyuJIT，呈現較佳的性能，並支援SSE2與AVX2指令集。WPF 與 Windows Forms 都獲得更新以達成較高的 DPI 情境。支援TLS 1.1 與 TLS 1.2 的功能已經被加入 WCF。 此版本需要Windows Vista SP2 或更新的版本。\n\n.NET Framework 4.6.1\n.NET Framework 4.6.1 發行的訊息在2015年11月30日宣佈。這個版本需要 Windows 7 SP1 或更新的版本。新的功能與 API 包括：\n\nWPF改進了拼寫檢查，支援用戶自定義詞典，並改進觸控性能。\n增強支援橢圓曲線數字簽名算法（ECDSA）X509 認證。\n當連接Azure SQL數據庫時，添加了對AlwaysOn、Always Encrypted的SQL連接，並改進連接開放彈性。\nAzure SQL數據庫現在使用更新的System.Transactions API支援分散式處理。\nRyuJIT、GC、WPF和WCF中的許多其他性能、穩定性和可靠性相關修復。\n\n.NET Framework 4.6.2\n.NET Framework 4.6.2 的預覽在2016年3月30日宣佈，發行日期則為2016年8月2日。此版本需要 Windows 7 SP1 或更新版。 New features include:\n\n支援超過260個字符的路徑\n支援X.509認證的FIPS 186-3 DSA\nTLS 1.1 / 1.2支援 ClickOnce\n支援 ASP.NET 數據註釋的本地化\n啟用具備 Project Centennial 的 .NET桌面應用程序\n針對WPF支援軟鍵盤和每個監視器DPI\n\n.NET Framework 4.7\n2017年4月5日，微軟宣佈 .NET Framework 4.7 將被整合到 Windows 10 創作者更新, 承諾為其他Windows版本提供獨立安裝程式。同日，發行一個 Visual Studio 2017 更新版以加強支援標的物 .NET Framework 4.7。 所承諾的 Windows 7 及更新版本獨立安裝程式在2017年5月2日發行， 但有一些重要成份不包含在內。\n.NET Framework 4.7 的新功能包括：\n\n使用橢圓曲線密碼學的增強加密\n改進對傳輸層安全性協定（TLS）的支援，尤其是對於1.2版\n支援Windows Forms 的高DPI感知支援\n在 WPF 中對觸控和手寫的更多支援\nWPF 的新印表 API\n\n.NET Framework 4.7.1\n.NET Framework 4.7.1 在2017年10月17日發行。在修復程式和新功能中，它修正了d3dcompiler依賴性問題。 \n它還增加了與.NET Standard 2.0開箱即用的相容性。\n\n.NET Framework 4.7.2\n.NET Framework 4.7.2 在2018年4月30日發行。主要的異動是改進 ASP.NET、BCL、CLR、ClickOnce、Networking、SQL、WCF、Windows Forms、Workflow 及 WPF。\n\nCLR與CLI\n.NET的初級組成是CLI（通用語言架構）和CLR（通用語言運行庫）。\nCLI（通用語言架構）全名為Common Language Infrastructure，是一套運作環境規範，包括一般系統、基礎類庫和與機器無關的中間代碼。CLR則是確認操作密碼符合CLI的平臺。在通用中間語言（CIL）執行前，CLR必須將指令及時編譯轉換成原始機械碼。\n所有CLI都可經由.NET自我表述。CLR檢查元資料以確保正確的方法被調用。元資料通常是由語言編譯器生成的，但開發人員也可以通過使用客戶屬性創建他們自己的元資料。\n如果一種語言實現生成了CLI，它也可以通過使用CLR被調用，這樣它就可以與任何其他.NET語言生成的資料相交互。CLR也被設計為作業系統無關性。\n當一個彙編體被載入時，CLR執行各種各樣的測試。其中的兩個測試是確認與核查。在確認的時候，CLR檢查彙編體是否包含有效的元資料和CIL，並且檢查內部表的正確性。核查則不那麼精確。核查機制檢查代碼是否會執行一些“不安全”的操作。核查所使用的演算法非常保守，導致有時一些“安全”的代碼也通不過核查。不安全的代碼只有在彙編體擁有“跳過核查”許可的情況下才會被執行，通常這意味著代碼是安裝在本機上的。\n通過.NET，你可以用SOAP和不同的web服務進行交互。\n\n標準化和版權\n2000年8月，微軟、惠普和英特爾共同制定CLI和C#程式語言的標準規格。2001年12月，以上兩者通過並成為ECMA標準規格。（ECMA 335（页面存档备份，存于互联网档案馆）和ECMA 334（页面存档备份，存于互联网档案馆））。ISO亦於2003年4月跟隨（ISO/IEC 23271（页面存档备份，存于互联网档案馆）和ISO/IEC 23270（页面存档备份，存于互联网档案馆））。\n這會有一定的風險，但它可以鼓勵標準聯合的實現，以提供一座橋樑來把非Windows的軟體轉變為微軟.NET。將此推廣為標準的一個團體是國際.NET聯合會（INETA）。\n儘管微軟及其他合作夥伴持有CLI及C#的專利，ECMA和ISO要求所有專利都應該遵守“合理與非歧視準則”。除此之外，這些公司亦同意讓使用者免費使用這兩項專利。\n不過，這並不包括.NET Framework內並不為ECMA/ISO標準涵蓋的範圍，這包括了：Windows Forms、ADO.NET及ASP.NET。微軟對上述部件所持有的專利，使開發者未必能夠為非微軟平臺開發出一套完整的作品。\n2014 年11月13日，微軟新任執行長薩帝亞·納德拉決心下，該公司釋出的.NET原始碼包含了伺服器部分的核心，如.NET Framework Libraries、.NET Core Framework Libraries和RyuJit VM，正式對外開放原始碼。\n\n.NET与Java EE\n公共語言基礎（CLI），通用中間語言（CIL）以及C#與甲骨文公司的Java虛擬機和Java之間有不少的相似之處，因此它們無疑是強烈的競爭者。它們兩者都使用它們各自的中間碼（在微軟，它們叫做通用中間語言，而在Oracle，它們叫位元組碼）。通用中間語言被設計來即時編譯（JIT），而Java的位元組碼在最初的時候則是設計成用於解釋運行，而非即時編譯。.NET現在只在Windows上被完美地支持，而Java則可在很多平臺上被完好支持。然而，現在一些正在開發中的實現版本例如Mono或者Shared source CLI可以用於在類Unix作業系統例如Linux，FreeBSD和Mac OS X上運行.NET應用程式。甲骨文公司的一個產品，J2EE提供與微軟的一些捆綁於Windows中的技術例如COM+（先前的MTS）和MSMQ等效的功能。\nJava和.NET可經由IKVM，一個在.NET平臺上實作的Java虛擬機作更多的溝通。\nJava有其專門的遠端程式呼叫技術RMI（Remote Method Invocation）, RMI的另一版本RMI-IIOP更可相容CORBA。\n然而，.NET與Java之間的競爭關係，在.NET Core出現後，一切都改觀了。\n\n.NET与COM\n前一版軟體元件技術由Microsoft所提出的COM，該技術被用來建立大型（large-scale）的軟體系統上，使用COM+ 或MTS對於傳統分散式元件有強化的作用。當.NET將COM-objects封裝成.NET元件以及將.NET元件封裝成COM-objects後，Microsoft分別將他命名為Runtime Callable Wrapper（RCW）和COM Callable Wrapper（CCW）。很明顯的，Microsoft最終將以.NET全面取代COM成為軟體元件的架構。Microsoft希望開發者能夠在Win32平臺上使用.Net取代COM，而已經存在的服務則透過抽象介面來使用（如：目前交易的.Net元件仍然使用COM+）。\n\n.Net Remoting与XML WebServices\n.NET remoting屬於行程（process）內溝通的抽象方法。\nMicrosoft® .NET Remoting提供一個豐富可擴充的框架給存在兩個不同AppDomain中的Object，使得在不同行程（行程）和不同機器中能夠進行無縫地溝通。.NET Remoting提供一種強大但簡單的可程式化模型並且在執行階段支援資料交換。\nXML Web services將基礎的功能區塊佈署到網路的不同電腦上。開放標準的通訊協定以及人和應用程式可以透過Web Services整合應用程式的環境來合作。應用程式可以從不同的來源使用多個XML Web Services來建構應用程式而不需要知道他們在哪裡以及如何來運作。\n\n.NET的語言\nCLI被設計成支援任何物件導向的程式語言，分享共同物件模型與大型共同類別庫。.NET支援超過40種程式語言。這些編譯器大都是免費的（软件廠商仅开发出售集成开发环境）。\n大部分的語言都做了重大改變以搭配.NET Framework。廠商通常利用這個機會來同時改變語言的其他特性。\n\n微軟開發的.NET平臺編程語言\nC#，一個以C++和Java語法為基礎開發的一個全新的物件導向語言，是.NET開發的首選語言。\nVisual Basic .NET，一個加強了物件導向支持的，支持多線程的Visual Basic版本。\nC++/CLI，一個C++的.NET平臺版本變種。\nJScript .NET，一個編譯版本的MicrosoftJScript語言。\nJ#，一個對應於Java和J++（微軟自己開發的Java變種）的.NET平臺版本，但是由于知识产权问题，目前微软公司已经停止其开发应用。\nF#，ML語言家族的一員。\nMicrosoft Small Basic\n\n第三方使用.NET的編程語言\nAda，參閱A#。\nAPL\nBoo，基於Python。\nCOBOL\nComponent Pascal，基於部件的Pascal，比起Pascal來更接近於Oberon。\nDelphi 8 and Delphi 2005以及现在的delphi xe2都采用.net\nEiffel\nForth\nFORTRAN\nIKVM，Java。\nIronPython，基於Python。\nIronRuby，基于Ruby。\nLexico，基於西班牙語的面向物件編程語言。\nLisp\nMercury (RemObjects BASIC programming language)\nMondrian為了便於腳本部件編程而開發的功能型語言。\nNemerle函數式／指令式混合語言。\nOberon\nPerl\nPhalanger，PHP的.net编译器。\nRPG\nSmalltalk\nTclBridge，基于Tcl。\nPowerBuilder.NET PowerBuilder 11.5及以后的版本都采用.net技术，但这种语言目前停止开发了。\n\nASP.NET & ADO.NET\nASP.NET是內含於.NET Framework中，專門用來發展Web應用程式的一組類別庫集。\nADO.NET是內含於.NET Framework中，專門處理與資料來源溝通的資料存取類別庫集，被Windows Forms與ASP.NET應用程式大量使用，可說是.NET Framework中唯一的資料存取介面。\n\n可供選擇的實現版本\n微軟的.NET Framework是.NET技術的旗艦級實現版本，在此之外還有一些其他實現版本。\n\n.NET Core 是微軟開發的跨平台 (Windows、Mac OSX、Linux) 的應用程式開發框架（Application Framework）\n微軟开发了一个称为共享源码公共语言基础（Shared Source Common Language Infrastructure，Shared Source CLI；即今ECMA—通用语言架构），是微軟的.NET Framework（共通語言執行平臺）的一個源碼共用的實現架构，可運行於Windows XP，FreeBSD，和Mac OS X10.2。\nMono是一個開源的.NET運行時和開發庫實現版本。Mono現正由xamarin公司和開源軟體發展社區負責開發。它正迅速發展成熟，現已經包含了對ASP.NET和ADO.NET的支持，对Windows Forms庫的支持也较充分。它提供了一個C#編譯器，而一個VB.NET編譯器現在也已經處於pre-beta階段。Mono項目還包含了一些新的庫和技術的開發：\nGtk：一個GTK+GUI工具包的.NET封裝。\nxSP：一個用C#編寫的支持運行ASP.NET應用程式的網頁伺服器軟體。\nMonoDevelop：SharpDevelop的一個移植版本，是一個符合GPL標準的面向Gtk#和Mono的.NET集成開發環境。\nNovell.Directory.Ldap類庫：Lightweight Directory Access Protocol（LDAP）for .NET的一個免費的實現版本。\nSerialPortNet：Aserial portlibrary for .Net & Mono implementing .NET 2.0 specifications.\nMono for Android和MonoTouch for iOS：Mono在移动平台Android和iOS上的移植，使开发者可以在Android和iOS平台上使用C#和Mono框架开发应用。Xamarin Forms是这些实现的核心，可以根据系统不同生成符合该系统风格的界面。\nMonoMac：Mono对于一些OS X原生Step API的封装。\nPortable.NET不及Mono成熟，這得歸因於Portable.NET並不是在最初的時候就使用了微軟的開發框架。提供了一个可以从C编译到通用中间语言的编译器。\n\n參見\nC#\nVB.NET\nASP.NET\nAJAX\nCOM Interop\nWindows API\n.NET Compact Framework\n.NET Micro Framework\n\n参考文献\n外部链接\n官方网站 \nOverview of .NET Framework (MSDN)（页面存档备份，存于互联网档案馆）（英文）\n.NET Framework 概述（页面存档备份，存于互联网档案馆）（简体中文）\n.NET Framework 的概觀（页面存档备份，存于互联网档案馆）（繁體中文）\n.NET Github repository（页面存档备份，存于互联网档案馆）"}
{"title": "JavaScript", "text": "JavaScript（通常缩写为JS）是一门基于原型和头等函数的多范式高级解释型编程语言，它支持面向对象程式設計、指令式编程和函数式编程。它提供方法来操控文本、数组、日期以及正则表达式等。不支持I/O，比如网络、存储和图形等，但这些都可以由它的宿主环境提供支持。它由Ecma通过ECMAScript实现语言的标准化。目前，它被世界上的绝大多数网站所使用，也被世界主流浏览器（Chrome、Firefox、Safari和Opera）所支持。\nJavaScript与Java在名字和语法上都很相似，但这两门编程语言从设计之初就有很大不同。JavaScript在语言设计上主要受到了Self（一种基于原型的编程语言）和Scheme（一门函数式编程语言）的影响，在语法结构上它和C语言很相似（如if条件语句、switch语句、while循环和do-while循环等）。\n对于客户端来说，JavaScript通常被实现为一门解释语言，但如今它已经可以被即时编译（JIT）。随着HTML5和CSS3语言标准的推行，它还可以用于游戏、桌面和移动应用程序的开发，以及在服务器端网络环境运行（如Node.js）。\n\n历史\n肇始於網景\n1993年，國家超級電腦應用中心（NCSA）發表了NCSA Mosaic，這是最早流行的圖形使用者介面網頁瀏覽器，它在全球資訊網的普及上發揮了重要作用。1994年，Mosaic的主要開發人員創立了Netscape公司，並雇用了許多原來的NCSA Mosaic開發者用來開發Netscape Navigator，該公司的目標是取代NCSA Mosaic成為世界第一的網頁瀏覽器。在四個月內，已經佔據了四分之三的瀏覽器市場，並成為1990年代網際網路的主要瀏覽器。\n在網路發展的這些年，網頁只能是靜態的，缺乏在瀏覽器中載入網頁後的動態行為能力。公司的創始人馬克·安德森認為HTML需要一種膠水語言，讓網頁設計師和兼職程式設計師可以很容易地使用它來組裝圖片和外掛程式之類的元件，且程式碼可以直接編寫在網頁標記中。1995年，網景招募了布兰登·艾克，目標是把Scheme語言嵌入到Netscape Navigator瀏覽器中。但更早之前，網景已經跟昇阳合作，计划在Netscape Navigator中嵌入Java語言，這時網景內部產生激烈的爭論，\n網景公司管理層很快決定，最佳的方案是由艾克設計一種新的語言，其語法類似於Java，而不像Scheme或其他現存的腳本語言。為了在其他競爭提案中捍衛JavaScript這個想法，公司需要有一個可以運作的原型。艾克在1995年5月僅花了十天時間就把原型設計出來了。最初命名為Mocha，1995年9月在Netscape Navigator 2.0的Beta版中改名為LiveScript，同年12月在Netscape Navigator 2.0 Beta 3中部署時又被重命名為JavaScript，这是因为當時网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上Java这个编程语言“热词”，所以才将其临时改名为JavaScript，这成了日后这成为大众对这门语言有诸多误解的原因之一。同年昇阳电脑公司在1995年12月1日正式申请注册JavaScript的商标，于2000年7月28日获批\n，但此后昇阳电脑公司和之后收购它的甲骨文公司从未使用该商标制造过产品，给JavaScript社区带来了不确定性，阻碍了JavaScript社区的自由发展，直到几十年后，1.5万多名JavaScript社区成员于2024年11月22日联名向美国专利商标局申请终止该商标\n，甲骨文公司于2025年2月3日以Node.js产品驳回了该申请案。\n\n微軟採納\n微軟公司於1995年首次推出Internet Explorer，引發了與Netscape的瀏覽器大戰。微软對Netscape Navigator直譯器進行了逆向工程，創建了JScript，以與處於市場領導地位的網景產品同台競爭。JScript也是一種JavaScript實作，這兩個JavaScript語言版本在瀏覽器端共存意味著語言標準化的缺失。发展初期，JavaScript的标准并未确定，同期就有网景的JavaScript和微软的JScript。除此之外，微軟也在網頁技術上加入了不少專屬物件，使不少網頁使用非微軟平台及瀏覽器無法正常顯示。这導致在瀏覽器大戰期間網頁設計者通常會把「用Netscape可達到最佳效果」或「用IE可達到最佳效果」的標誌放在首頁。\n\n增长和标准化\n1996年11月，網景正式向ECMA（欧洲计算机制造商协会）提交語言標準。1997年6月，ECMA以JavaScript语言为基础制定了ECMAScript标准规范ECMA-262。JavaScript成為了ECMAScript最著名的實現之一。除此之外，ActionScript和JScript也都是ECMAScript规范的实现语言。儘管JavaScript作為給非程式人員的腳本語言，而非作為給程式人員的程式語言來推廣和宣傳，但是JavaScript具有非常豐富的特性。\n在21世纪初Internet Explorer占主导地位期间，客户端脚本停滞不前。这在2004年开始改变，当时Netscape的继任者Mozilla发布了Firefox浏览器。Firefox受到许多人的好评，从Internet Explorer获得了巨大的市场份额。\n2005年，Mozilla加入了ECMA International，并开始研究ECMAScript for XML（E4X）标准。这导致Mozilla与Macromedia（后来被Adobe Systems收购）合作，他们正在用基于ECMAScript 4草案的ActionScript 3语言实现E4X。目标是将ActionScript 3标准化为新的ECMAScript 4。为此，Adobe Systems将Tamarin实现作为开源项目发布。然而，Tamarin和ActionScript 3与既定的客户端脚本太不同，如果没有微软的合作，ECMAScript 4从未取得成果。\n与此同时，与ECMA工作无关的开源社区正在发生非常重要的发展。2005年，傑西·詹姆士·賈瑞特(Jesse James Garrett)发布了一網誌，其中他创造了「AJAX」一词，并描述了一套技术，其中JavaScript是骨干，用于创建可以在后台加载数据的Web应用程序，避免了重新加载整页的需要。这引发了JavaScript的复兴时期，由开源库和围绕它们形成的社区带头。创建了许多新库，包括jQuery、Prototype、Dojo Toolkit和MooTools。\n谷歌于2008年首次推出Chrome浏览器，其V8 JavaScript引擎比竞争对手更快。关键的创新是及时编译（JIT），因此其他浏览器供应商需要为JIT彻底改革他们的引擎\n2008年7月，这些不同的政党聚集在一起，在奥斯陆举行会议。这导致在2009年初达成了最终协议，将所有相关工作结合起来，推动语言向前发展。结果是2009年12月发布的ECMAScript 5标准。\n\n走向成熟\n关于该语言的雄心勃勃的工作持续了数年，最终随着 2015 年ECMAScript 6的发布而正式形成了广泛的补充和改进。\n瑞安·達爾(Ryan Dahl)在 2009 年创建的Node.js引发了網頁瀏覽器之外 JavaScript 使用的显着增加。Node.js结合了V8引擎、事件循环和I/O API，从而提供了独立的 JavaScript 运行时系统。截至 2018 年，Node.js 已被数百万开发人员使用，并且npm拥有世界上所有軟件包管理系統中最多的模块。\nECMAScript 草案规范目前在GitHub上公开维护，并通过定期的年度快照生成版本。对语言的潜在修订通过全面的提案流程进行审查。现在，开发人员不再单独检查即将推出的功能的状态，而不是版本号。\n当前的 JavaScript 生态系统拥有许多库和框架、已建立的编程实践以及在網頁瀏覽器之外大量使用 JavaScript。另外，随着单页应用程序和其他大量使用 JavaScript 的网站的兴起，已经创建了多个转译器来帮助开发过程。\n\n概論\n一般来说，完整的JavaScript包括以下几个部分：\n\nECMAScript，描述了该语言的语法和基本对象；\n文档对象模型（DOM），描述处理网页内容的方法和接口；\n浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。\nJavaScript的基本特点如下：\n\n是一种解释性脚本语言（代码不进行预编译）；\n主要用来向HTML页面添加交互行为；\n可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。\nJavaScript常用来完成以下任务：\n\n嵌入动态文本于HTML页面；\n对浏览器事件作出响应；\n读写HTML元素；\n在数据被提交到服务器之前验证数据；\n检测访客的浏览器信息；\n控制Cookie，包括创建和修改等；\n\n特性\n不同於伺服器端腳本語言（如PHP和ASP），JavaScript主要被作为客户端腳本語言在用戶的瀏覽器上運行，不需要伺服器的支持。所以在早期程式設計師比較青睞於JavaScript以減少對伺服器的負擔，而與此同時在安全性上出现了问题。隨著伺服器變得強大，現在的程序員更喜歡運行於伺服器端的腳本以保證安全，但JavaScript仍然以其跨平台、容易上手等優勢大行其道。同时，有些特殊功能（如AJAX）必须依赖JavaScript在客户端提供支持。隨著JavaScript引擎（如V8）和軟體框架（如Node.js）的發展，以及事件驅動和異步IO等特性，JavaScript也被逐漸用來編寫伺服器端程式。\n以下是ECMAScript通常所实现的特性。\n\n指令式与结构化\nJavaScript支持许多C语言的结构化编程语法（如if条件语句、while循环、switch语句和do-while循环等），但作用域是一个例外。JavaScript在过去只支持使用var关键字来定义变量的函数作用域，但ECMAScript 2015中加入了let关键字来支持块级作用域。这意味着JavaScript现在既支持函数作用域又支持块级作用域。JavaScript还支持自动在语句末添加分号，允许忽略语句末尾的分号。\n\n弱类型\nJavaScript是弱类型的，这意味着变量可以被隐式转换为另一个类型。\n\n二元运算符+会把两个操作数转换为字符串，除非两个操作数都为数字类型。这是因为+也表示字符串连接操作；\n二元操作符-会把两个操作数转换为数字类型；\n一元操作符，包括+和-，都会把操作数转换为数字。\n下列为变量转换为字符串的例子：\n\n字符串类型不变；\n数字会转换为其字符串表示；\n数组的元素会转换为字符串，然后连接成通过逗号,分隔的长字符串；\n其它对象会转换为[object Object]，其中Object中该对象的构造函数名。\n类型的隐藏转换是JavaScript受到批评的原因之一，因为隐藏转换增加了规则的复杂度和发生错误的可能性。\n\n动态化\n类型\nJavaScript是动态类型的语言，其类型与值而不是与变量相关联。例如变量可以为数字，随后又可被赋值为字符串。JavaScript提供了包括鸭子类型在内的方法来检测变量类型。\n\n运行时估值\nJavaScript提供eval()函数，可以在运行时直接执行JavaScript语句。\n\n基于原型的面向对象\n在JavaScript中，对象是关联数组，通过原型（prototype，见下）进行扩充。每一个字符串键值提供对象的一个属性的名称，可以通过使用点号（obj.x）或使用方括号（obj['x']）这两种效果相同的方式来访问。属性可以在运行时添加、重定义或删除。一个对象的大多数属性（包括来自原型继承链的属性）都可以通过 for...in循环访问。\n\n原型\nJavaScript使用原型，而许多其它面向对象程序设计使用类用于实现继承。原型使得在JavaScript中模拟基于类的面向对象特征变成可能。\n\n函数作为对象构造器\n函数在JavaScript中兼作为对象构造函数。在函数调用前加上new会创建一个原型的实例，并继承来自构造函数的属性和方法（包括来自Object原型）。ECMAScript 5提供Object.create方法，可以显式地创建实例而不是自动从Object继承。构造函数的prototype属性决定了用于新对象的内部原型。可以通过修改构造函数的原型的方法来为对象添加新的方法，也可以修改JavaScript的内部对象的原型（如Array或Object）。尽管可以这么做，但对Object原型进行修改并不是好的做法。因为大多数JavaScript对象都会从Object继承，且不会希望其原型被修改。\n\n函数作为方法\n和大多数面向对象的语言不同，在JavaScript中函数定义和方法定义没有明显区别。唯一的区别在于调用时：当函数被作为方法调用时，函数的this会指向调用此函数的对象。\n\n传统的类定义与使用格式\nECMAScript 2015中加入了对class和extends关键字的支持，使得类的定义与继承更类似于其他的面向对象语言，同时也更易使用。\n\n函数式\n在JavaScript中，函数是一等的，函数也被认为是对象。因此，函数可以有属性和方法，例如call()和bind等。嵌套函数指定义于其它函数内部的函数，在外部函数被调用时，嵌套函数会被创建。另外，嵌套函数是一个闭包，在外部函数的作用域（包括常量，局部变量和参数）都成为内部函数状态的一部分，甚至在外部函数执行完毕后，内部函数的状态依然保留。JavaScript同时也支持匿名函数。\n\n其它\n运行时环境\nJavaScript通常依赖于运行时环境（例如浏览器）来提供对象和方法，脚本可以通过这些对象和方法与环境（例如网页DOM）进行交互。它还依赖于运行时环境来提供包或导入脚本（例如HTML的<script>元素）的功能。这本身不是语言功能，但在大多数JavaScript实现中很常见。\n\n承诺\nJavaScript的“承诺”（Promise）是一种编程模型，它允许表示可能在未来某个时间点完成或失败的值。承诺被设计为一个解决异步编程中所遇到的问题的更简洁和一致的方法。相比于传统的回调函数，它为处理异步操作提供了一个更清晰的方式。\n一个承诺有三种状态：\n待定（Pending）: 初始状态，既不是成功也不是失败。\n已履行（Fulfilled）: 意味着操作成功完成。\n已拒绝（Rejected）: 意味着操作失败。\n承诺的主要特点是它们的状态一旦改变（从待定到已履行或已拒绝），就不能再次改变。这使得承诺成为一个可靠的信息来源，无论它们是否成功。\n在JavaScript中，你可以使用then()方法来附加回调函数，这些回调函数会在承诺达到已履行或已拒绝状态时执行。还有一个catch()方法，专门用于处理被拒绝的承诺。为了使链式调用更简洁，then()和catch()都会返回一个新的承诺。ES6（ECMAScript 2015）引入了原生的Promise对象，从此承诺成为JavaScript标准的一部分。此后的版本还提供了额外的实用方法，例如Promise.all()和Promise.race()，用于处理多个承诺。\n\n异步\nJavaScript一般来说是单线程的。为了并发地处理事件，JavaScript程序输入或输出时使用事件和回调函数执行。这意味着JavaScript可以在等待数据库查询返回信息之前处理鼠标单击。ECMAScript 2015引入了Promise用于处理异步事件，其可以使得传统的基于回调的异步代码更加清晰简单。\n\n变长参数\nJavaScript中函数参数的长度是可变的，在函数内部可以通过arguments对象访问这些参数。\n\n编程\nJavaScript是一门腳本語言，其原始碼在客户端執行前不需經過編譯，而是將文本格式的字符代碼發送給瀏覽器，由瀏覽器解釋執行。直譯語言的弱點是安全性較差，而且在JavaScript中，如果一條语句執行不了，通常它下面的語言也就無法執行。解決辦法是使用异常处理try {} catch () {}︰\n\nJavaScript被歸類為直譯語言，因為主流的引擎都是每次執行時載入程式碼並解譯。V8是將所有程式碼解譯後再開始執行，其他引擎則是逐行解譯（SpiderMonkey會將解譯過的指令暫存，以提高效能，稱為即時編譯）。但由於V8的核心部份多數用JavaScript撰寫（而SpiderMonkey是用C++），因此在不同的測試上，兩者效能互有優劣。\n與其相對應的是編譯語言（如C语言），以編譯語言編寫的程式在執行之前必須經過編譯，將程式碼編譯為機器碼，才可以執行。\n\n範例\n以下是一個簡單的JavaScript Hello World︰\n\n或是在瀏覽器的地址栏中使用javascript:，以互動方式表示：\n\n版本\nJavaScript最初開發於1996年，被使用於Netscape Navigator網頁瀏覽器。同年微軟在Internet Explorer發布了一個實作。由於商標問題，這項實作被命名為JScript。1997年，JavaScript已經被網景公司提交給ECMA制定為標準，稱之為ECMAScript，標準編號ECMA-262。使用顯式版本號聲明對語言的引用，作爲一項Mozilla的特性，已在較新版本中被移除（至少為Firefox 59）。Firefox 4是最後一個需要顯式地在引用時聲明明確版本號的版本（1.8.5）。\n下列表格的資訊基於多個參考來源：\n\n參見\n腳本語言\nDMDScript\nECMAScript\nJavaScript引擎\nJScript\nAJAX\nJavaScript函式庫\n\n參考文獻\n外部連結\n\n關於JavaScript介紹（页面存档备份，存于互联网档案馆） Mozilla Developer Network上的資源"}
{"title": "2345加速瀏覽器", "text": "2345王牌瀏覽器是由上海二三四五網路科技股份有限公司所開發的瀏覽器。使用IE內核，並結合2345網址導航。二三四五公司于2005年9月创立，其经营范围为互联网应用和软件开发。2345网址导航于该公司创立的同时开始创建，并将该网站定位为“网民首选的上网入口”。\n2014年1月16日，上海二三四五网络科技股份有限公司被海隆软件收购，成为其子公司。海隆软件自此开始涉足互联网行业。2015年3月13日，海隆软件将其在深交所的证券名称更改为“二三四五”。\n\n版本\n2011~2016中旬-2345王牌瀏覽器\n2016後-2345加速瀏覽器\n\n合作簽約夥伴\n百度、谷歌、新浪网、淘宝网、腾讯网、京东、搜狐、优酷、大众点评、美团网、携程。\n\n恶意软件争议\n有媒体将2345网址导航與Webssearch、hao123等並列惡意軟體。通常隨其他附屬程式下載到使用者的電腦上，並且惡意執行搜尋反導向。使用者常會看見許多網址掛名在蒐尋頁面上，通常內藏高危險網頁病毒，建議處理方式為重灌或解除安裝並改用其他瀏覽器。另外9991網址導航為旗下姊妹計畫。\n\n注释\n外部連結\n二三四五官网（页面存档备份，存于互联网档案馆）"}
{"title": "360极速浏览器", "text": "360极速浏览器是360安全中心推出的一款基于Chromium开源项目的浏览器，也基于世界之窗浏览器再次开发产品的浏览器。奇虎360称其是全球首个无缝衔接Chrome和Internet Explorer的浏览器。革新的UI设计、HTML5和CSS3的标准化支持。它的界面与Google Chrome浏览器的十分相似，但是360极速浏览器为它添加符合中国大陆网民之上网习惯的实用功能。\n2021年10月18日，其64位版本发布，名为“360极速浏览器X”，版本号为21.0.1000.0，采用Chromium 95内核。\n\n基本功能\n基础功能\n收藏夹、地址栏、搜索栏、多标签、历史记录、下载管理、保存密码。\n\n参见\n360安全浏览器\nGoogle Chrome\n世界之窗浏览器\nInternet Explorer\n\n参考资料\n外部链接\n（简体中文）360极速浏览器 （页面存档备份，存于互联网档案馆）\n（简体中文）360极速浏览器X （页面存档备份，存于互联网档案馆）\n（英文）360 Extreme Browser （页面存档备份，存于互联网档案馆）\n（简体中文）360极速浏览器的新浪微博\n（简体中文）极速浏览器-360社区 （页面存档备份，存于互联网档案馆）"}
{"title": "C++", "text": "C++是一种被广泛使用的计算机程序设计语言。它是一种通用程式設計語言，支援多重编程范式，例如過程化程序設計、面向对象程序設計、泛型程式設計和函数式程序設計等。\n比雅尼·斯特勞斯特魯普博士在贝尔实验室工作期间在20世紀80年代發明並實現了C++。起初，這種語言被稱作“C with Classes”（“包含‘類’的C語言”），作為C語言的增強版出現。随后，C++不斷增加新特性。虚函数、运算符重载、多繼承、标准模板库、异常处理、运行时类型信息、命名空間等概念逐漸納入標準草案。1998年，國際標準組織頒布了C++程序設計語言的第一個國際標準ISO/IEC 14882:1998（C++98），目前最新标准为ISO/IEC 14882:2024（C++23）。ISO/IEC 14882通称ISO C++。ISO C++主要包含了核心语言和标准库的规则。尽管从核心语言到标准库都有显著不同，ISO C++直接正式（normative）引用了ISO/IEC 9899（通称ISO C），且ISO C++标准库的一部分和ISO C的标准库的API完全相同，另有很小一部分和C标准库略有差异（例如，strcat等函数提供对const类型的重载）。这使得C和C++的标准库实现常常被一并提供，在核心语言规则很大一部分兼容的情况下，进一步确保用户通常较容易把符合ISO C的源程序不经修改或经极少修改直接作为C++源程序使用，也是C++语言继C语言之后流行的一个重要原因。\n作为广泛被使用的工业语言，C++存在多个流行的成熟实现：GCC、基于LLVM的Clang以及Visual C++等。这些实现同时也是成熟的C语言实现，但对C语言的支持程度不一（例如，VC++对ANSI C89之后的标准支持较不完善）。大多数流行的实现包含了编译器和C++部分标准库的实现。编译器直接提供核心语言规则的实现，而库提供ISO C++标准库的实现。这些实现中，库可能同时包含和ISO C标准库的共用实现（如VC++的msvcrt）；而另一些实现的ISO C标准库则是单独于编译器项目之外提供的，如glibc和musl。C++标准库的实现也可能支持多种编译器，如GCC的libstdc++库支持GCC的g++和LLVM Clang的clang++。这些不同的丰富组合使市面上的C++环境具有许多细节上的实现差异，因而遵循ISO C++这样的权威标准对维持可移植性显得更加重要。现今讨论的C++语言，除非另行指明，通常均指ISO C++规则定义的C++语言（虽然因为实现的差异，可能不一定是最新的正式版本）。\n值得注意，和流行的误解不同，ISO C和ISO C++都从未明确要求源程序被“编译”（compile），而仅要求“翻译”（translate），因此从理论上来讲，C和C++并不一定是编译型语言。技术上，实现C和C++程序的单位是翻译单元（translation unit）。作为对比，Java语言规范中就明确要求Java程序被编译为字节码，明确存在编译单元（compilation unit）。实际上C和C++也存在REPL形式的解释器实现，如CINT和Cling。但因为传统上C和C++多以编译器实现，习惯上仍有一些混用，例如ISO C++中的编译期整数序列（Compile-time integer sequences）。\n传统上，C++语言被视为和C语言实现性能相近的语言，强调运行时的高效。根據《C++編程思想》（Thinking in C++）一書，C++與C的代码执行效率往往相差在±5%之間。\n\n发展历史\nC++語言發展大概可以分為三個階段：第一階段從80年代到1995年。這一階段C++語言基本上是傳統類型上的面向对象語言，並且憑藉着接近C語言的效率，在工業界使用的開發語言中佔據了相當大份額；第二階段從1995年到2000年，這一階段由於標準模板庫和後來的Boost等程式庫的出現，泛型程序設計在C++中佔據了越來越多的比重。當然，同時由於Java、C#等語言的出現和硬體價格的大規模下降，C++受到了一定的衝擊；第三階段從2000年至今，由於以Loki、MPL(Boost)等程式庫為代表的產生式編程和模板元編程的出現，C++出現了發展歷史上又一個新的高峰，這些新技術的出現以及和原有技術的融合，使C++已經成為當今主流程序設計語言中最複雜的一員。\n比雅尼·史特勞斯特魯普工作起於1979年的C with Classes。這個構思起源於斯特劳斯特鲁普做博士論文時的一些程式撰寫經驗。他發現Simula具備很利於大型軟體開發的特點，但Simula的執行速度太慢，無法對現實需求發揮功效；BCPL雖快得多，但它過於低階的特性，使其不適於大型軟體的開發。當斯特劳斯特鲁普開始在貝爾實驗室工作時，他有分析UNIX内核關於分散式計算的問題。回想起他的博士論文經驗，斯特劳斯特鲁普開始為C語言增強一些類似Simula的特點。之所以選擇C，是因為它適於各種用途、快速和可移植性。除了C语言和Simula之外，同時也從其它語言中取得靈感，如ALGOL 68、Ada、CLU以及ML。\n剛開始時，類別、衍生類別、儲存類型檢查、內聯和缺省参数特性，都是透過Cfront引入C語言之中。\n1983年，C with Classes改命名為C++（++是C语言中的增值操作符）。加入了新的特性，其中包括虛擬函式、函式名和運算子多載、參考、常數、使用者可控制的自由空間儲存區控制、改良的型別檢查，并恢复了BCPL风格的雙斜線（//）單行注释（之后C99也支持了这种注释）。\n1985年，發佈第一版《C++程式設計語言》，提供一個重點的語言參考，至此還不是官方標準。1985年10月出現了第一個商業化發佈。\n1989年，發佈了Release 2.0。引入了多重繼承、抽象類別、靜態成員函式、常數成員函式，以及成員保護。1990年，出版了The Annotated C++ Reference Manual。這本書後來成為標準化的基礎。稍後還引入了模板、例外處理、命名空間、新的強制类型转换，以及布林类型。\n隨著C++語言的演變，也逐漸演化出相應的標準程式庫。最先加進C++標準函式庫的是串流I/O程式庫，其用以取代傳統的C函式，如printf和scanf。隨後所引入的程式庫中最重要的便是標準模板庫，簡稱STL。\n多年後，一個聯合的ANSI-ISO委員會於1998年對C++標準化（ISO/IEC 14882：1998）。在官方釋出1998標準的若干年後，委員會處理缺陷報告，並於2003年發佈一個C++標準的修正版本。2005年，一份名為Library Technical Report 1（簡稱TR1）的技術報告釋出。雖然還不是官方標準的一部分，不過它所提供的幾個擴展可望成為下一版C++標準的一部分。幾乎所有目前仍在維護的C++編譯器皆已支援TR1。\n目前最新的C++标准是2023年10月发布的ISO/IEC 14882:2024，又称C++23。\n雖然C++本身無專利，但標準文件本身並不是免費的，尽管标准文档不是免费的，但是很容易从网络中取得，最简单的就是C++标准文档之前的最后一次草稿版本，它与标准的差别几乎只在于排版上。\n\nC++名字的由來\nC++這個名字是Rick Mascitti於1983年中所建議的，並於1983年12月首次使用。更早以前，尚在研究階段的發展中語言曾被稱為「new C」，之後是「C with Classes」。在電腦科學中，C++仍被稱為C語言的上層結構。它最後得名於C語言中的「++」運算子（其對變數的值進行遞增）。而且在共同的命名約定中，使用「+」以表示增強的程式。斯特劳斯特鲁普說：「這個名字象徵著源自於C語言變化的自然演進」。C+是一個和C/C++無關的早期程式語言。\nRick Mascitti在1992年被非正式地問起名字的由來，他表示這是在半開玩笑中說出的。他從沒想過C++會成為這門語言的正式名字。\n有一個關於C++名字的笑話是，當你使用後綴++時，附加只發生在運算之後（因此，它應該是++C，而不是C++，这个笑话是说时下某些程序员还在以使用C的方式使用C++，这通常被一些权威著作认为是不正确的）。\n\nC++标准\n由ISO/IEC JTC1/SC22/WG21进行。已经出版的标准文档如下：\n\n設計原則\n在《C++語言的設計和演化》（1994）中，Bjarne Stroustrup描述了他在設計C++時，所使用的一些原則。知道這些原則有助於理解C++為何會是現在這個樣子。以下總結了一些原則，詳盡的內容可參閱《C++語言的設計和演化》：\n\nC++設計成直接的和廣泛的支援多種程式設計風格（過程化程式設計、数据抽象、物件導向程式設計、泛型程式設計）。\nC++設計成給程式設計者更多的選擇，即使可能導致程式設計者選擇錯誤。\nC++設計成儘可能與C相容，藉此提供一個從C到C++的平滑過渡。\nC++避免平台限定或沒有普遍用途的特性。\nC++不使用會帶來額外開銷的特性。\nC++設計成無需複雜的程式設計環境。\n\n標準程序庫\n1998的C++標準分為兩個部分：核心語言和C++標準程式庫；後者包含了大部分標準模板庫和C標準程式庫的稍加修改版本。存在許多不屬於標準部分的C++程式庫，且使用外部連結，程式庫甚至可以用C撰寫。\nC++標準程式庫充分吸收了C標準程式庫，並佐以少許的修改，使其與C++良好的運作。另一個大型的程式庫部分，是以標準模板庫（STL）為基礎，STL於1994年2月正式成為ANSI/ISO C++。它提供了實用的工具，如容器类（如：Array和Vector），迭代器（廣義指针）提供容器以類似陣列的存取方式，以及泛型算法進行搜尋和排序的運算。此外還提供了(multi)map和(multi)set，它們都共享相似的成员函数。因此，以下成為可能，使用模板撰寫泛型算法，它可以和任何容器或在任何以迭代器定義的序列上運作。如同C，使用#include指令包含標準表頭，即可存取程式庫裡的功能。C++提供69個標準表頭，其中19個不再贊成使用。\n使用標準模板庫（例如：使用std::vector或std::string來取代C風格的数组或字符数组）有助於开发更安全和更靈活的软件。\n在STL在納入C++標準以前，是來自HP和後來的SGI的第三方程式庫，標準中並未稱之為「STL」，它只是標準庫中的一部分，但仍有許多人使用這個名稱，以別於其它的標準庫（輸入／輸出串流、國際化、診斷、C程式庫子集，等等）。\n另外，如std::basic_string此类标准委员会添加的接口，有时也被误认为STL；实际上它们并不存在于原始的SGI STL中，在标准化后SGI STL才从标准库吸收加入其中。\n\nC++中的特色\n和C語言相比，C++引入了更多的特性，包括：复合类型（引用類型等）、const限定符和constexpr常量表达式、类型处理运算符（类型别名及auto和decltype等多种类型指示符）、C++标准库（IO库与多种容器类）与迭代器、动态内存与智能指针、函数重載、面向对象程序设计（如数据抽象、成員函数、类作用域、构造函数与析构函数、静态成员、访问控制与繼承、虚函数、抽象类与接口等）、拷贝控制、运算符重载、造型与函数风格的強制类型转换、模板与泛型编程，以及異常處理、命名空間、多继承与虚继承、运行时类型识别及嵌套类等。\nC++在某些案例中（見下「與C不相容之處」），進行比C還要多的類型檢查。\n以「//」起始作為註解起源自C的前身BCPL，而後被重新引入到C++。\nC++的一些特性，C不久之後也採用了，包括在for循环的括号中声明，C++風格的註解（使用//符號，和inline，雖然C99定義的inline關鍵字與C++的定義不相容。不過，C99也引入了不存在於C++的特性，如：可变参数巨集，和以陣列作為參數的較佳處理；某些C++編譯器可能實作若干特性，以作為擴展，但其餘部分並不符合現存的C++特性）\n一個常見的混淆其實只是一個微妙的術語問題：由於它的演化來自C，在C++中的術語对象和C語言一樣是意味著記憶體區域，而不是類別的實體，在其它絕大多數的物件導向語言也是如此。舉例來說，在C和C++中，語句int i;定義一個int型別的物件，這就是變數的值i將在指派時，所存入的記憶體區域。\n\nC++语言中的const关键字\nconst是一个C和C++语言的关键字，意思是声明一個不能改變值的变量，即只读。使用const在一定程度上可以提高程序的安全性和可靠性，也便于实现对此进行优化（如把只读对象放入ROM中）。const作为型別限定符，是型別的一部分。\nC++不是第一個正式引入const类型的语言。80年代早期，Bjarne Stroustrup和Dennis Retchie讨论之后提供了在C语言中readonly/writeonly的实现机制，并在带類的C中取得了一定经验。关键字const正式引入C語言是在ANSI C89。这早于第一个C++国际标准近十年，但此时const已被C++实现普遍採用。\n以下是和C语言相容的用法：\n\n但是，const在C++中有更强大的特性。它允许在编译时确定作为真正的常量表达式。例如，\n\n此前C语言并不支持这样的用法，直到C99允许用变量作为数组长度（需要注意的是C99中的VLA支持运行期确定数组长度，但C++从未支持）。此外，C++中，命名空间作用域的const对象的名称隐含内部链接。这意味着直接在头文件里定义const对象被多个源文件包含时，也不会重定义。\n在C++11及之后的C++标准中，推荐使用拥有更严格语义的constexpr限定符来表示一个可以出现在常量表达式中的变量。const可区分为顶层const(top-level const)和底层const(low-level const)。\n实际上，在语义表达方面，const更多表示为“只读”，constexpr才表示一定能在翻译时确定的常量，但实际求值仍可能在运行时进行（只有像作为声明数组大小这样确定要求常量表达式的上下文中，才会因为需要确保翻译时必须确定所需的值而进行翻译时求值）。C++20引入了更严格的consteval和constinit的语法，直接限定特定的求值必须在翻译时完成。不过，和const不同，后三者修饰声明但不是类型限定符，不参与类型声明构成复合类型，不通过类型检查实现所谓的const正确性（const correctness），也不影响利用这些特性的相关API的类型签名。\n一些参照C和C++设计的语言中，也存在类似的差异。例如，C#同时具有readonly和const关键字，前者接近原始的“只读”（即最先被讨论的readonly机制和C语言中的const），而后者更接近C++的const。\n\n与C不兼容之处\nC++有时被认为是C的超集（superset），但这並不严谨。\n各个版本的ISO/IEC 14882的附录C中都指出了C++和ISO C的一些不兼容之处。\n大部分的C代码可以很轻易的在C++中正确编译，但仍有少数差异，导致某些有效的C代码在C++中失效，或者在C++中有不同的行为。\n最常见的差异之一是，C允许从void*隐式转换到其它的指标类型，但C++不允许。下列是有效的C代码：\n\n但要使其在C和C++两者皆能运作，就需要使用显式转换：\n\n另一个常见的可移植問題是，C++定义了很多的新关键字，如new和class，它们在C程式中，是可以作为识別字（例：变量名）的。\nC99去除了一些不兼容之处，也新增了一些C++的特性，如//注释，以及在代码中混合使用。不过C99也纳入几个和C++冲突的新特性（如：可变长数组、原生复数类型和复合逐字常数），而C++11已经加入了兼容C99预处理器的特性。\n由于C++函数和C函数通常具有不同的名字修饰和调用约定，所有在C++中呼叫的C函数，须放在extern \"C\" { /* C函数声明 */ }之內。\n\nC++的Hello World程序\n下面这个程序显示“Hello, world!”然后结束运行：\n\n在C++23前：\n\n如果使用“\\n”代替以上代碼裡的“endl”，输出结果相等。\n\nstd::endl 不仅仅会在某个输出流中插入换行字符，还将执行输出流的 flush() 函数（即刷新缓冲区），而'\\n'则不会。\n这里也可以使用using指令以避免多次声明std::——\n\n根据ISO C++的规定，全局main函数必须返回int。\n以下两种形式是合法的：\n\n不过，在一些编译器（例如Visual C++）上，\n\n也是合法的。但是这样的写法兼容性较差。\n\n語言特性\n运算符\n分為\n\n預處理器\nC++主要有三個編譯階段：預處理、轉譯成目的碼和連結（最後的兩個階段一般才視為真正的「編譯」）。在第一階段，預處理，會將預處理器指令替換成原始碼，然後送到下一個編譯階段。\n\n預處理器指令和巨集\n預處理指令的運作方式是根據使用者定義的規則，簡單的把記號字元序列置換成其它的記號字元序列。它們進行巨集置換、含入其它的檔案（由底層至高階的特性，例如包含模組／包／單元／元件）、條件式編譯和條件式含入。例如：\n\n原始代码中出現的PI，都將會替換為3.1415926535897932384626433832795028841971693993751。另一個普遍的例子是\n\n它將使用標準庫头文件print中的所有内容來替換本條預處理指令。除了以上提到的常用指令以外，還有幾個額外的預處理器指令，可以用來控制編譯流程、條件式含入或排除代碼區塊等等。\n\n參閱預處理器和C預處理器\n\n模板\n模板（Template）指C++程式語言中的函式模板（function template）與類別模板（class template），這種觀念是取材自Simula的泛型程式設計。它采用typename和class两个关键字，来标识模板類別的型別参数。C++11和C++14分别引入了类型别名模板和变量模板。\n\n類別与对象\n在物件導向物件程式設計術語中，物件（object）是資料（data）和處理資料的指令（instructions）的聯合（association）。模擬（simulate）實際世界（real-world），物件有三種特質（characteristics）：狀態（State）、行為（Behavior）、同一性身分，並且使用訊息（message）來引發彼此的互動。類別（class）為物件的藍圖或工廠，定義了物件的抽象特質，包括物件的屬性特質和物件的行為特質，屬性的值即是物件的狀態，行為即是物件能夠做的事。\nC++為類別構成式物件導向程式設計語言（class-based object-oriented programming language），類別概念具現化（reification）地作為二等公民（second-class citizen）出現在C++語言當中，在語法中明確地使用類別來做到資料抽象化、封裝、模組化、繼承、子型別多型、物件狀態的自動初始化。C++中，一個類別即為一個型別，加上封裝，一個類別即為一個抽象資料型別（Abstract Data Type，ADT），繼承、多型、模板都加強了類別的可抽象性。在C++可以使用class或struct這兩個關鍵字宣告類別（class），而使用new運算子實體化類別產生的實體（instance）即為物件，是一等公民。C/C++以資料成員（data member）表達屬性，以成員函式（member function）表達行為。\n声明一个Car class：\n\n但是仍然需要注意，严格来说，C++中对象的概念和C的对应概念接近，表示的是具有特定类型的存储，而非面向对象意义上的“对象”：一个对象不一定是类类型的。此外，C++意义上的“实例”仅指模板实例化的结果，而并不指对象。作为对比，Java的“对象”和“实例”的概念和这里的使用一致。\n\n封裝\n封裝（Encapsulation）是將資料和處理資料的程序（procedure）組合起來，僅對外公開接口（interface），达到信息隐藏（information hiding）的功能。封裝的優點是能減少耦合（Coupling）。C++、Java、C# 等語言定義对象都是在語法中明確地使用類別（Class）來做到封裝。\nC++的類別对其成员（包括数据成员、函数成员）分为三种封装状态：\n\n公有（public）：類別的用户可以访问、使用该類別的此种成员。\n保护（protected）：该類別的衍生類別可以访问、使用该類別的此成员。外部程序代码不可以访问、使用这种成员。\n私有（private）：只有類別自身的成员函数可以访问、使用该類別的此成员。\n一般可以将C++類的对外接口设定为公有成员；類内部使用的数据、函数设定为私有成员；供派生自该類別的子類別使用的数据、函数设定为保护成员。\n\n繼承\n繼承（Inheritance）是指派生类（subclass）繼承基类（superclass），會自動取得超類別除私有特質外的全部特質，同一類別的所有實體都會自動有該類別的全部特質，做到程式碼再用（reuse）。C++只支援類別構成式繼承，雖然同一類別的所有實體都有該類別的全部特質，但是實體能夠共享的實體成員只限成員函式，類別的任何實體資料成員乃每個實體獨立一份，因此物件間並不能共享狀態，除非特質為參考型別的屬性，或使用指標來間接共享。C++支持的继承关系为：\n\n公有繼承（public inheritance）：最常用繼承关系，含义是「is-a」關係，代表了在完全使用公有繼承的物件類別之間的层次关系（hierarchy）。\n受保護繼承（protected inheritance）：基礎類別的公有或保护内容可以被衍生類別，以及由此衍生的其他類別使用。但是基礎類別对外界用户是不可见的。衍生類別的用户不能访问基礎類別的成员、不能把派生類別转换（造型）为基礎類別的指针或引用。\n私有繼承（private inheritance）：基礎類別的公有或保护内容仅可以被衍生類別访问。但基礎類別对衍生類別的子類別或衍生類別的用户都是不可见的。衍生類別的子類別或衍生類別的用户都不能访问基礎類別的内容、不能把衍生類別转换为基礎類別的指针或引用。\nC++支持多繼承（multiple inheritance，MI）。多繼承（multiple inheritance，MI）的優缺點一直廣為使用者所爭議，許多語言（如Java）並不支援多重繼承，而改以單一繼承和介面繼承（interface inheritance），而另一些語言则采用用單一繼承和混入（mixin）。C++通过虛繼承（Virtual Inheritance）来解決多繼承带来的一系列问题。\n\n多态\n除了封裝與繼承外，C++還提供了多型功能，物件導向的精神在於多态（Polymorphism），一般的多态，是指動態多态，係使用繼承和動態绑定（Dynamic Binding）實現，使用多型可建立起繼承體系（Inheritance hierarchy）。類（class）與繼承只是達成多态中的一種手段，所以稱物件導向而非類別導向。\n多态又分成靜態多态（Static Polymorphism）與動態多态（Dynamic Polymorphism）。C++语言支持的動態多态必須結合繼承和动态绑定（Dynamic Binding）方式實現。靜態多态是指编译时决定的多态，包括重载和以模板（template）實現多型的方法即參數化型態（Parameterized Types），是使用巨集（macro）的“程序代码膨脹法”達到多型效果。\n类型轉換（type cast）也是一種非参数化（ad hoc）多态的概念，C++提供dynamic_cast, static_cast等运算符來實作强制类型轉換（Coercion）。\n運算元重載（operator overloading）或函式重載（function overloading）也算是多型的概念。\n\n分析和處理C++原始代碼\nC/Java/C#都可以用某種 LR剖析器（或其變形）分析文法，但C++是個著名的例外：请看下面的代码。\n\n上面的table1显然是一个字符串的二维数组，而table2则未必能通过编译：如果严格遵循LR分析过程，串 >> 会被解释为右移运算符而非两个代表模板参数表结束的右尖括号，因此出现编译错误，必须以table1的方式用空格区分。(在C++11发布之后，特别规定了当处理模板时，>>被优先视为两个>，所以table1和table2均可通过编译.)\n\n争议\n「在這12年裡，C++使用者人數大約每七個月半增加一倍」是許多C++相關文件必引的一段話；然而，時至今日新語言層出不窮，使用者人數已不太可能以如此速度增長。分析機構EvansData定期對開發人員展開調查，其資料顯示，以C++為工具的開發人員在整個開發界所佔的比例由1998年春天的76%下降至2004年秋的46%。\n一部分Unix/C程序员对C++语言深恶痛绝，他们批评的理由如下：\n\nSTL以非常丑陋的方式封装了各种数据结构和算法，写出来的代码难以理解、不美观。\nC++编译器复杂和不可靠，不适合构建人命关天类型的程序。\nIan Joyner认为面向对象技术徒增学习成本，不如面向过程的C语言简单容易使用，尤其是在系统软件的构建上。\n概括說來UNIX程式設計師批評C++主要是由於UNIX社群與C++社群的文化差異。\nLinux之父林纳斯·托瓦兹曾经多次炮轰C++。图灵奖得主尼克劳斯·维尔特也曾经批评C++语言太复杂、语法语义模糊，是“拙劣工程学”的成果。\n事实上，对于C++语言的批评并不只来源于Unix/Unix-Like系统下的程序员。就像C++语言本身是一个跨平台的语言一样，对C++的批评并不局限于Unix/Unix-Like系统用户。\n\n參閱\n《C++程式語言》（The C++ Programming Language）\n比较Java和C++\nC++託管擴展\nC++/CLI\nBoost C++ Libraries\nObjective-C ，另一個以C語言添加物件導向設計的程式語言\n\n参考文献\n延伸阅读\nJosuttis, Nicolai M. The C++ Standard Library, A Tutorial and Reference Second. Addison-Wesley. 2012. ISBN 0-321-62321-5. \nLippman, Stanley B.; Lajoie, Josée; Moo, Barbara E. C++ Primer Fifth. Addison-Wesley. 2011. ISBN 0-321-71411-3. \n[美] Stanley B. Lippman; [美] Josée Lajoie; [美] Barbara E. Moo. C++ Primer(中文版)(第5版). 由王刚; 杨巨峰翻译. 电子工业出版社. 2013-09-01. ISBN 9787121155352 （中文（中国大陆））. \nMeyers, Scott. Effective C++ Third. Addison-Wesley. 2005. ISBN 0-321-33487-6. \nMeyers, Scott. Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library. Addison-Wesley. 2001. \nStroustrup, Bjarne. The C++ Programming Language Fourth ed. Addison-Wesley. 2013. ISBN 978-0-321-56384-2.  引文格式1维护：冗余文本 (link)\nStroustrup, Bjarne. The Design and Evolution of C++. Addison-Wesley. 1994. ISBN 0-201-54330-3. \nStroustrup, Bjarne. Programming Principles and Practice Using C++ Second ed. Addison-Wesley. 2014. ISBN 978-0-321-99278-9.  引文格式1维护：冗余文本 (link)\nVandevoorde, David; Josuttis, Nicolai M. C++ Templates: The complete Guide. Addison-Wesley. 2003. ISBN 0-201-73484-2.\n\n外部連結\n\nJTC1/SC22/WG21（页面存档备份，存于互联网档案馆） - The C++ Standards Committee （英文）\nC和C++资源的最终列表（页面存档备份，存于互联网档案馆）\nC++教學 （页面存档备份，存于互联网档案馆）\nC/C++参考手册（中文） （页面存档备份，存于互联网档案馆）"}
{"title": "ALGOL", "text": "ALGOL，名稱源自演算法語言（英語：ALGOrithmic Language）的縮寫，是一族指令式編程語言，發展於1950年代中期，對許多其它程式語言產生了重大影響。计算机协会在教科書及學術文章採用此語言做為描述演算法的標準語法超過三十年。\n由大多數近代程式語言皆使用類似ALGOL的語法來看，ALGOL可與差不多同時期的FORTRAN、LISP及COBOL並列為四大最有影響力的高階語言。ALGOL被設計用來避免FORTRAN中一些已知的問題，最終引領了許多其它程式語言的興起，包括PL/I、Simula、BCPL、B、Pascal及C。\nALGOL引入了代码块，並用begin⋯end來分隔。它是第一個利用詞法作用域實作巢狀函式的語言，也是第一個注重形式語言定義的語言，並在ALGOL 60報告中引入了巴科斯範式來作為設計語言形式文法的原則。\nALGOL主要有三種規格，以初次發表的年份命名：\n\nALGOL 58 – 原提議命名為IAL，代表International Algebraic Language。\nALGOL 60 – 在1960年代中期首先實作成X1 ALGOL 60，1963年修訂。\nALGOL 68 – 引入許多新元素，像是可變陣列、切片、平行化及算子識別。1973年修訂。\n尼克勞斯·維爾特在發展Pascal之前，在ALGOL 60的基礎下建立了ALGOL W。ALGOL W本是下一代ALGOL的提議，但ALGOL委員會決定採用更先進複雜的設計，而不是一個簡潔化ALGOL 60。\n\nALGOL 58 (IAL)\nALGOL 58沒有I/O機制。\n\nALGOL 60家族\n1960年，在巴黎举行的讨论会上，来自欧洲的诺尔、Bauer、Rutishauser、Samelson、Vauquois、van Wijngaarden、Woodger，与来自美国的佩利、巴科斯、麦卡锡、Katz、Wegstein和J. Green，共同发表了《算法语言ALGOL 60报告》。戴克斯特拉实现了ALGOL 60语言的第一个编译器。在1962年罗马会议上，ALGOL 60报告得到了修订，并于1963年出版。\nAlgol 60引进了许多新的概念如：代码块、词法作用域、递归、巴科斯-诺尔范式（BNF）等等。\nAlgol 60是程序设计语言发展史上的一个里程碑，它标志着程序设计语言成为一门独立的科学学科，并为后来软件自动化及软件可靠性的发展奠定了基础。\n\nALGOL 68\n\nALGOL 68的“Hello, World”\n\nBEGIN\n  printf(($gl$,\"Hello, world!\"))\nEND\n\nAlgol W：1966年，IFIP吸收尼克劳斯·维尔特参加对Algol语言进行完善与扩充的工作小组。沃思参加进去以后，提交了一份建议书并由東尼·霍爾等人修改、完善以后形成Algol W。同时还催生了一个新的语言PL360。\n\n\n== 參考資料 =="}
{"title": "Go语言", "text": "Go（又稱Golang）是Google開發的一种静态强类型、編譯型、并发型，并具有垃圾回收功能的编程语言。\n羅伯特·格瑞史莫、羅勃·派克及肯·汤普逊於2007年9月开始设计Go，稍後伊恩·蘭斯·泰勒（Ian Lance Taylor）、拉斯·考克斯（Russ Cox）加入專案。Go於2009年11月正式宣布推出，成為開放原始碼專案，支援Linux、macOS、Windows等作業系統。\n在2009年与2016年，Go在TIOBE指數中被列選為最佳語言。\n目前，Go每半年发布一个二级版本（即从a.x升级到a.y）。\n\n描述\nGo的语法接近C语言，但对于变量的声明有所不同。Go支持垃圾回收功能。Go的并行计算模型是以東尼·霍爾的通信顺序进程（CSP）为基础，采取类似模型的其他语言包括Occam和Limbo，Go也具有这个模型的特征，比如通道传输。通过goroutine和通道等并行构造可以建造线程池和管道等。在Go 1.8版本中開放插件（Plugin）的支持，這意味著現在能從Go中動態載入部分函式。\n与C++相比，Go並不包括如枚举、异常处理、继承、泛型（此功能在Go 1.18版本中加入）、断言、虚函数等功能，但增加了切片（Slice）类型、并发、管道、垃圾回收、接口等特性的语言级支持。對於断言的存在，則持負面態度，同時也為自己不提供型別继承來辯護。\n不同于Java，Go原生提供了关联数组（也称为哈希表（Hashes）或字典（Dictionaries））。\n\n批評\n儘管 Go 的官方與支持者對於語言中不使用泛型與異常處理有著大量辯解說詞，但批評聲也從未停過。在發表 Go 語言 2.0 的草案時，官方稱沒有泛型、異常處理與模組對於 Go 發展造成很大的阻礙，等同承認 Go 沒有這些特色是設計錯誤。\nGo 的垃圾回收機制一直被人詬病，直到 1.8 版本垃圾回收的功能才較為穩定。然而儘管如此，Go 的垃圾回收還是遠遠落後 JVM 的 G1 和 ZGC。Discord 的研發團隊在2020年初甚至發表一篇部落格，宣布把其中一個服務從 Go 轉移至 Rust，理由是 Go 的垃圾回收會導致每2分鐘出現一次卡頓，並且 Discord 研發團隊測試了 Go 語言的1.8、1.9、1.10版本這個問題都沒有改善。\n\n历史\n2007年，Google设计Go，目的在于提高在多核、网络机器（networked machines）、大型代码库（codebases）的情况下的开发效率。当时在Google，设计师们想要解决其他语言使用中的缺点，但是仍保留他们的优点。\n\n静态类型和运行时效率。（如：C++）\n可读性和易用性。（如：Python 和 JavaScript）\n高性能的网络和多进程。\n设计师们主要受他们之间流传的“不要像C++”启发。\nGo於2009年11月正式宣布推出，版本1.0在2012年3月发布。之后，Go广泛应用于Google的产品以及许多其他组织和开源项目。\n在2016年11月，Go（一种无衬线体）和Go Mono 字体（一种等宽字体）分别由设计师查爾斯·比格洛和克莉絲·荷姆斯发布。两种字体均采用了WGL4，并且依照着 DIN 1450 标准，可清晰地使用了 large x-height 和 letterforms 。\n在2018年8月，原生的图标更换了。待描述完整 然而，Gopher mascot 仍旧命相同的名字。\n在2018年8月，Go的主要贡献者发布了两个关于语言新功能的“草稿设计——泛型和异常处理，同时寻求Go用户的反馈。Go 由于在1.x时，缺少对泛型编程的支持和冗长的异常处理而备受批评。\n\n版本历史\nGo 1 保證語言規範和標準庫的主要部分相容。直到目前的 Go 1.25 發布，所有版本都履行了這個承諾。\n每個主要的 Go 發布版本會受到支援，直到出現兩個新的主要版本為止。\n\n代码示例\nHello World\n下面是用Go写成的Hello World程序：\n\nHTTP網頁伺服器\n透過Go僅需幾行程式碼就完成HTTP網頁伺服器的實現：\n\nEcho命令程序\n下面的例子说明了怎样用Go去实现一个像Unix中的Echo命令程序：\n\n语言特征\n撰寫風格\nGo有定義如下的撰寫風格：\n\n每行程式結束後不需要撰寫分號;。\n大括號{不能夠換行放置。\nif判斷式和for迴圈不需要以小括號包覆起來。\n使用 tab 做排版\n除了第二點外（換行會產生編譯錯誤），在不符合上述規定時，仍舊可以編譯，但使用了內建gofmt工具後，會自動整理程式碼，使之符合規定的撰寫風格。\n\n專案架構\nmodule\nGo 採用 module 的概念（於 go1.11才開始啟用，舊版本請參閱工作區），每個專案都是一個 module ，而每個 module 底下會有個 go.mod 的檔案，來管理該 module 所引用的外部庫、開發版本……等等。\n一個 module 的資料夾目錄可能如下\n\ngo.mod\n hello/\n     hello.go                \n outyet/\n     main.go                 \n     main_test.go           # 測試用的程式\n stringutil/\n     reverse.go             \n     reverse_test.go        #  測試用的程式\n bmp/\n     reader.go              \n     writer.go               \n然後 go.mod 的內容可能為\n\nmodule example.org/go-mod-sample\n\ngo 1.11\n\nrequire (\n\tgithub.com/golang/example v0.0.0-20220412213650-2e68773dfca0 \n\tgolang.org/x/image v0.1.0 \n)\n\n工作區\nGo的工作區位於GOPATH，其目录結構如下：\n\nsrc\npkg\nbin\n三個目录的用途分別為\n\n舉例來說，整個專案目录可能會如下：\n\nbin/\n    hello                          # 生成的執行檔\n    outyet                         # 生成的執行檔\npkg/\n    linux_amd64/\n        github.com/golang/example/\n            stringutil.a           # 編譯時，生成的對象檔案\nsrc/\n    github.com/golang/example/\n        .git/                      # 外部 Git 庫的詮釋資料\n hello/\n     hello.go               # Git 庫的程式碼\n outyet/\n     main.go                # Git 庫的程式碼\n     main_test.go           # Git 庫的程式碼（測試用的程式）\n stringutil/\n     reverse.go             # Git 庫的程式碼\n     reverse_test.go        # Git 庫的程式碼（測試用的程式）\n    golang.org/x/image/\n        .git/                      # 外部 Git 庫的詮釋資料\n bmp/\n     reader.go              # Git 庫的程式碼\n     writer.go              # Git 庫的程式碼\n\n轻型协程\nGo的主要特色在於易于使用的併行設計，叫做Goroutine，透過Goroutine能夠讓程式以異步的方式執行，而不需要擔心一個函式導致程式中斷，因此Go也非常地適合網路服務。假設有個程式，裡面有兩個函式：\n\n這個時候透過Go讓其中一個函式同步執行，如此就不需要等待該函式執行完後才能執行下一個函式。\n\nGoroutine是類似線程的概念，属于纖程(区别于协程和线程)。線程屬於系統層面，通常來說建立一個新的線程會消耗較多的資源且管理不易；而协程的主要作用是提供在一個線程內的併發性，卻不能利用多個处理器線程。而 Goroutine就像輕量級的線程，一個Go程式可以執行超過數萬個 Goroutine，並且這些效能都是原生級的，隨時都能夠關閉、結束，且運行在多個處理器執行緒上。一個核心裡面可以有多個Goroutine，透過GOMAXPROCS參數你能夠限制Gorotuine可以佔用幾個系統線程來避免失控。\n在內建的官方套件中也不時能夠看見Goroutine的應用，像是net/http中用來監聽網路服務的函式實際上是建立一個不斷執行迴圈的Goroutine；同时搭配了epoll 等IO多路复用機制维护Goroutine的事件循环。\n\n编译器\n当前有两个Go编译器分支，分别为官方编译器gc和gccgo。官方编译器在初期使用C写成，后用Go重写从而实现自举。Gccgo是一个使用标准GCC作为后端的Go编译器。\n官方编译器支持跨平台编译（但不支持CGO），允许将原始码编译为可在目标系统、架构上执行的二进制文件。\n\n应用\n由于go的原生跨平台，以及大量的官方库，被用于大量开源程序，例如：docker、Syncthing、ipfs、Hugo、caddy、以太坊、V2Ray、Gitea、TiDB。\n\n參考文獻\n\n\n== 外部連結 =="}
{"title": "2014年中国大陆屏蔽谷歌服务事件", "text": "2014年中国大陆屏蔽谷歌服务事件指自2014年5月27日后，Google公司的各项服务遭到疑似来自中国官方的防火长城的恶意干扰，导致中国大陆地区的用户无法正常使用其服务的事件。自当天起，来自中国大陆的用户发现Google旗下的各个分站以及Google的其他服务（Google搜索、Google Play、Gmail等）均无法正常访问与使用，所有google.cn以外的Google服务均受影响无法使用，用户甚至无法登陆Google账户。然而，不同于2009年至2013年仅针对敏感时期的行为规律，六四25周年纪念日结束后攻击者对Google的干扰仍未停止。\n\n背景事件\nGoogle于2006年建立了服务器在中国大陆的google.cn，提供有限的Google服务，主要引进了Google网页搜索服务，接受上级监管部门的网络监管，根据要求删除搜索结果中的“有害信息”。\n2010年3月23日，迫於受到由中國大陸發起的極光攻擊與苛刻的网络审查，Google宣布放棄中國市場並关闭了谷歌中国的搜索服务。在内地访问谷歌搜索將被重定向到服务器在海外的香港版本Google主页。Google香港站点可为大陆用户提供无审查的网页搜索服务。由于Google服务器在海外，未加密的流量在国际网络进出口会被GFW以关键词过滤等多种方法审查，在大陆访问Google香港常常会被断开连接而不稳定或载入速度异常缓慢，以达到减少大陆的Google流量的目的。Google在北京的合資企業\"谷翔\"仍在正常運營。\n此后，随着HTTPS的逐渐普及，Google更多的在页面中使用SSL加密。2014年1月，谷歌主席施密特称将以加密技术进入中国和朝鲜等审查严格的市场。2014年3月，在中国大陆访问Google的流量开始强制使用SSL加密，这意味着GFW无法再使用关键词过滤来审查google.com.hk。\n5月19日，美国以商业间谍罪起诉通缉來自中國人民解放軍61398部隊的五名軍方黑客並公開了來自安全機構Mandiant的入侵調查報告，引起中方不满并导致兩國关系紧张。2014年5月22日，中华人民共和国国家互联网信息办公室发布公告称，“为维护国家网络安全、保障中国用户合法利益”，并以此为目的，制定出网络安全审查制度。该政府机构认为，“关系国家安全和公共利益的系统使用的、重要信息技术产品和服务，应通过网络安全审查。”“对不符合安全要求的产品和服务，将不得在中国境内使用。”5月26日，中国国务院新闻办互联网新闻研究中心发布《美国全球监听行动纪录》（页面存档备份，存于互联网档案馆），指责美国政府长期通过谷歌、微软等科技公司滲透中国大陆和香港网络。\n\n过程\n自2014年5月27日后，Google透明度报告显示来自中國大陆的流量自周五就开始明显地逐渐减少。原因是大量海外Google服务器的IP地址的443端口在中国大陆被封锁，且可用IP数量逐日下降，最终导致访问任何Google.cn以外的所有Google网页均出现连接超时错误，包括各个Google地区版域名。同时，谷歌在北京和上海的服务器也不再提供网页搜索等服务的反向代理，导致用户将很多Google服务用更改hosts的手段定位到内地服务器后打开主页提示HTTP 404。谷歌大陆服务器提供的谷歌地图和谷歌翻译等服务访问不受影响。2014年7月10日傍晚，域名www.google.com被短暂解封，与此同时YouTube的加密版可以正常浏览，这引起网民的强烈反应，但翌日清晨再次遭到屏蔽。\n自2014年12月26日起，Google旗下的电子邮件服务Gmail的POP3、IMAP、SMTP服务的IP地址在中国大陆境内遭到路由封锁。Google透明度报告中的流量监控也显示自25日起，Gmail在中国的流量接近零。。大量网友反映Gmail的IMAP、POP和SMTP服务从中国各地均无法连接，第三方邮箱客户端已经完全失效。同日开始，对Google的IP封锁更为严厉，大量VPN和翻墙软件也出现不能使用的情况。基于Google App Engine的软件Goagent由于Google IP可用度被进一步劣化，作者宣布放弃对GAE的支持。\n2016年3月27日，Google網路服務短暂解封，原因是因为Google新近啟用了部分暂时没有被GFW封禁的服務器（现已完全封锁）。\n\n各方回应\n中国官方\n中国官方并没有公开针对此事作出任何表态或回应，但有媒體认为此为因六四天安门事件25周年临近，中国政府出于“维稳”目的改变防火长城屏蔽策略所致。2014年12月29日，在中国外交部新闻发布会上，当媒体询问关于谷歌邮箱Gmail无法在中国连接的问题时，外交部发言人表示“不知情”。\n2014年12月30日，中国官方媒体《环球时报》发表社论，宣称如果官方出于国家网络安全的考量封锁了Gmail，那么人们应该接受这一事实，并强调中国会一直保持开放姿态，欢迎谷歌等西方公司在中国大陆开展业务，但前提是要遵守相关法律和政策。\n\nGoogle\n谷歌发言人对路透社说：“我们检查过了，问题似乎不是源自于我们这端。”\n\n网民\n2014年7月，有中国大陆网民向工信部请求政府信息公开，试图询问谷歌为何遭到当局封锁。但工信部在答复的文件中否认其曾下达封禁谷歌的命令。\n2014年9月，居住在深圳的独立记者汪龙因长期无法登入Google而将中国联通告上法庭，深圳福田法院9月4日开庭审理了此案。他表示，从5月开始使用中国联通的网络无法访问Google、Gmail等网站，所以想透过法律解决此问题。被告的中国联通代理律师在法庭上也承认他们在律师事务所内使用中国电信网络也无法登陆Google。随后审判员作出结论：Google封锁与联通无关，但未有当庭宣判。目前汪龙已经被软禁，但仍然在新浪微博、Twitter上发布信息。此次事件在互联网引起了高度关注，被称为“封锁Google全球第一案”。不过，2014年9月11日，汪龙透过Twitter、微博、Google+等渠道表示，从当天起自己已被国保软禁在家中。\n\n影响\n对于这次封锁，很多经常需要用到谷歌服务来搜索国外网站的网民表示“太突然”。来自中国大陆的Google用户明显受到该事件的冲击，采用Android系统的手机用户无法使用Google Play等服务。而一些运行在Google服务器下的网站尽管没有被GFW封锁，但也因谷歌被封受到波及，无法访问，如：Snapchat和Android首页等。\n屏蔽谷歌亦殃及在中国的企业，短时间内使得办公效率受到影响。大多数跨国公司因为使用公司的专线，并不受公共国际出口限制，可以用于访问谷歌。本土企业如因为业务需要访问谷歌，也需要购买搭建国际专线，付出一定的额外成本。\n\n应对措施\n由于Google采用了任播技术来实现就近内容分发，用户曾经可以通过自行更改hosts等手段但是要注意使用HTTPS来上Google的网站，将特定域名映射到尚未遭到封锁的IP上，从而得以正常使用Google的服务。但目前Google旗下位于中国大陆境外的大多数服务器的IP地址均已被封锁，该方法基本失效。\n\n参考资料\n参见\n中华人民共和国网络审查\n谷歌涉黄事件\n谷歌退出中国大陆事件"}
{"title": "265上网导航", "text": "265上网导航是一个中文导航网站，目前在谷歌中國公司旗下运营。\n\n简介\n265.com将中国大陆较为常用的网站分门别类，并包括Google搜索，便于网民浏览和检索，并为广大互联网用户提供网址大全、综合搜索、手机导航、网站联盟等多元化服务。截至2006年，265.com覆盖超过50%的中国大陆互联网用户，日均访问量超过1000万，日均浏览量超过5000万。265.com使用起来非常方便和简练，使得其在网民之间依靠口碑传播得非常迅速。\n\n历史\n2003年4月：265上网导航正式推出。\n2004年：265.com品牌的拥有者及运营机构二六五网络技术（北京）有限公司成立。\n2008年5月：谷歌中国收购265.com。\n目前，因受Google退出中国大陆事件的影响以及防火长城对境外的Google服务器的封锁，265的搜索栏已经没有Google搜索的选项。\n\n参考文献\n外部链接\n官方网站"}
{"title": "数据结构", "text": "在计算机科学中，数据结构（英語：data structure）是计算机中存储、组织数据的方式。\n数据结构意味着介面或封装：一个数据结构可被视为两个函数之间的介面，或者是由数据类型联合组成的存储内容的访问方法封装。\n大多数数据结构都由数列、记录、可辨识联合、引用等基本类型构成。举例而言，可為空的引用（nullable reference）是引用与可辨识联合的结合体，而最简单的链式结构链表则是由记录与可空引用构成。\n数据结构可透过程式语言所提供的数据类型、引用及其他操作加以实现。一个设计良好的数据结构，应该在尽可能使用较少的时间与空间资源的前提下，支援各種程式執行。\n不同种类的数据结构适合不同种类的应用，部分資料結構甚至是為了解決特定問題而設計出來的。例如B树即為加快樹狀結構存取速度而設計的資料結構，常被應用在資料庫和檔案系統上。\n正確的数据结构選擇可以提高演算法的效率（請參考演算法效率）。在電腦程式设计的過程中，选择适当的数据结构是一項重要工作。许多大型系统的編寫经验顯示，程式設計的困难程度与最终成果的质量与表现，取决于是否选择了最適合的数据结构。\n系統架構的关键因素是数据结构而非算法的見解，导致了多种形式化的设计方法与编程语言的出现。绝大多数的语言都带有某种程度上的模块化思想，透过将数据结构的具体实现封装隐藏于使用者介面之后的方法，来让不同的应用程序能够安全地重用这些数据结构。C++、Java、Python等面向对象的编程语言可使用类来達到這個目的。\n因为数据结构概念的普及，现代编程语言及其API中都包含了多种預設的数据结构，例如C++标准模板库中的容器、Java集合框架以及微软的.NET Framework。\n\n常见的数据结构\n堆疊（Stack）\n佇列（Queue）\n陣列（Array）\n链表（Linked List）\n樹（Tree）\n圖（Graph）\n堆積（Heap）\n雜湊表（Hash table）\n\n参考文献\n外部链接\n\nDescriptions from the Dictionary of Algorithms and Data Structures\nData structures course （页面存档备份，存于互联网档案馆）\nAn Examination of Data Structures from .NET perspective （页面存档备份，存于互联网档案馆）\nSchaffer, C. Data Structures and Algorithm Analysis （页面存档备份，存于互联网档案馆）"}
{"title": "AA树", "text": "AA樹在電腦科學一種形式的自平衡二元搜尋樹用於高效存儲和檢索序數據。AA樹的名稱是由它的發明者阿爾尼·安德森（Arne Andersson）而來。\nAA樹是紅黑樹的一種變種，是安德森教授在1993年年在他的論文《Balanced search trees made simple》中介紹，設計的目的是減少紅黑樹考慮的不同情況，區別於紅黑樹的是，AA樹的紅節點只能作為右葉子，從而大大簡化了維護2-3樹的模擬。維護紅黑樹的平衡需要考慮7種不同的情況:\n\n因為AA樹有嚴格的條件(紅節點只能為右節點)，故只需考慮2種情形:\n\n旋轉平衡\n平衡一顆紅黑樹需要記錄其顏色，而AA樹是在每個節點記錄其\"level\"這相當於紅黑樹節點的黑高度\n\n所有葉節點的level都是1\n每個左孩子的level恰好為其父親的level減一\n每個右孩子的level等於其父親的level或為其父親的level減一\n每個右孫子的level嚴格小於其祖父節點的level\n每一個level大於1的節點有兩個子節點\n兩個level相同的點之間的邊水平邊，也就是紅黑樹上的紅邊。往右的水平邊是允許的，但不可連續(紅黑樹性質)；不能有向左的水平邊(AA樹性質)。因為AA樹的條件比紅黑樹嚴格，所以重新平衡一顆AA樹會比重新平衡一顆紅黑樹容易。\n插入和刪除會讓AA樹變的不平衡(即違反它的性質)。恢復平衡只需兩種操作:\"skew\"和\"split\". Skew是一個右旋轉使得子樹中向左的水平邊變成向右的水平邊；Split是一個左旋並增加子樹根節點的level(請看範例)使得連續向右的水平邊消失。平衡插入和刪除操作的實現是由skew及split決定是否旋轉，而不是在主程式中判斷。\n\nfunction skew is\n    input: T, a node representing an AA tree that needs to be rebalanced.\n    output: Another node representing the rebalanced AA tree.\n\n    if nil(T) then\n        return Nil\n    else if nil(left(T)) then\n        return T\n    else if level(left(T)) == level(T) then\n        Swap the pointers of horizontal left links.\n        L = left(T)\n        left(T) := right(L)\n        right(L) := T\n        return L\n    else\n        return T\n    end if\nend function\n\nSkew: \n\nfunction split is\n    input: T, a node representing an AA tree that needs to be rebalanced.\n    output: Another node representing the rebalanced AA tree.\n\n    if nil(T) then\n        return Nil\n    else if nil(right(T)) or  nil(right(right(T))) then\n        return T\n    else if level(T) == level(right(right(T))) then\n        We have two horizontal right links.  Take the middle node, elevate it, and return it.\n        R = right(T)\n        right(T) := left(R)\n        left(R) := T\n        level(R) := level(R) + 1\n        return R\n    else\n        return T\n    end if\nend function\n\nSplit:\n\n插入\n在遞迴的實做中，除了葉節點之外，在每次的遞迴結束後呼叫skew和split即可\n\nfunction insert is\n    input: X, the value to be inserted, and T, the root of the tree to insert it into.\n    output: A balanced version T including X.\n\n    Do the normal binary tree insertion procedure. Set the result of the\n    recursive call to the correct child in case a new node was created or the\n    root of the subtree changes.\n    if nil(T) then\n        Create a new leaf node with X.\n        return node(X, 1, Nil, Nil)\n    else if X < value(T) then\n        left(T) := insert(X, left(T))\n    else if X > value(T) then\n        right(T) := insert(X, right(T))\n    end if\n    Note that the case of X == value(T) is unspecified. As given, an insert\n    will have no effect. The implementor may desire different behavior.\n\n    Perform skew and then split. The conditionals that determine whether or\n    not a rotation will occur or not are inside of the procedures, as given\n    above.\n    T := skew(T)\n    T := split(T)\n\n    return T\nend function\n\n刪除\n在大部分的二元搜尋樹，刪除一個內部節點可以轉換成交換內部節點及其最接近的前驅或後繼節點，這取決於使用者。\n為了平衡這顆樹，有幾中方法，Andersson教授描述的original paper（页面存档备份，存于互联网档案馆）是最基本的，儘管它還能再被優化。刪除後第一件事是降低其level(如果可以)，於是，整個level必須skew和split，這個方法最受到歡迎的，因為它的概念易懂，可以列舉成下列三個簡單步驟:\n\n如果可以的話，減少其level\nSkew其level.\nSplit其level.\nfunction delete is\n    input: X, the value to delete, and T, the root of the tree from which it should be deleted.\n    output: T, balanced, without the value X.\n   \n    if nil(T) then\n        return T\n    else if X > value(T) then\n        right(T) := delete(X, right(T))\n    else if X < value(T) then\n        left(T) := delete(X, left(T))\n    else\n        If we're a leaf, easy, otherwise reduce to leaf case. \n        if leaf(T) then\n            return Nil\n        else if nil(left(T)) then\n            L := successor(T)\n            right(T) := delete(value(L), right(T))\n            value(T) := value(L)\n        else\n            L := predecessor(T)\n            left(T) := delete(value(L), left(T))\n            value(T) := value(L)\n        end if\n    end if\n\n    Rebalance the tree. Decrease the level of all nodes in this level if\n    necessary, and then skew and split all nodes in the new level.\n    T := decrease_level(T)\n    T := skew(T)\n    right(T) := skew(right(T))\n    if not nil(right(T))\n        right(right(T)) := skew(right(right(T)))\n    end if\n    T := split(T)\n    right(T) := split(right(T))\n    return T\nend function\n\nfunction decrease_level is\n    input: T, a tree for which we want to remove links that skip levels.\n    output: T with its level decreased.\n\n    should_be = min(level(left(T)), level(right(T))) + 1\n    if should_be < level(T) then\n        level(T) := should_be\n        if should_be < level(right(T)) then\n            level(right(T)) := should_be\n        end if\n    end if\n    return T\nend function\n\n這個網站展示了良好的刪除示範Andersson paper（页面存档备份，存于互联网档案馆）.\n\n效能\nAA樹的性能和紅黑樹是很類似的。儘管AA樹比紅黑樹做較多次旋轉，卻較容易實做，故二者效能相似。但是AA樹高度較淺，故查找時間較快\n\n參見\n紅黑樹\nB樹\nAVL樹\n左傾紅黑樹\n\n引用\n外部連結\nA. Andersson. Balanced search trees made simple（页面存档备份，存于互联网档案馆）\nA. Andersson. A note on searching in a binary search tree（页面存档备份，存于互联网档案馆）\nAA-Tree Applet（页面存档备份，存于互联网档案馆） by Kubo Kovac\nBSTlib - Open source AA tree library for C by trijezdci\nAA Visual 2007 1.5 - OpenSource Delphi program for educating AA tree structures\nThorough tutorial Julienne Walker with lots of code, including a practical implementation\nObject Oriented implementation with tests（页面存档备份，存于互联网档案馆）\nA Disquisition on The Performance Behavior of Binary Search Tree Data Structures (pages 67-75) - Comparison of AA trees, red-black trees, treaps, skip lists, and radix trees\nAn example C implementation\nAn Objective-C implementation（页面存档备份，存于互联网档案馆）"}
{"title": "算法", "text": "算法（英語：algorithm），在数学（算学）和计算机科学中指一个被定义好的、计算机可施行其指示的有限步骤或次序，常用于计算、数据处理和自动推理。算法可以使用条件语句通过各种途径转移代码执行（称为自动决策），并推导出有效的推论（称为自动推理），最终实现自动化。\n相反，启发式是一种解决问题的方法，可能没有完全指定，也可能不能保证正确或最优的结果，尤其是在没有明确定义的正确或最优结果的问题领域。例如，社交媒体推荐系统依赖于启发式，尽管在21世纪的流行媒体中被广泛称为算法，但由于问题的性质，它无法提供正确的结果。\n早在尝试解决希尔伯特提出的判定问题时，算法的不完整概念已经初步定型；在其后的正式化阶段中人們尝试去定义“有效可计算性”或者“有效方法”。这些尝试包括库尔特·哥德尔、雅克·埃尔布朗和斯蒂芬·科尔·克莱尼分别于1930年、1934年和1935年提出的递归函数，阿隆佐·邱奇于1936年提出的λ演算，1936年埃米尔·莱昂·珀斯特的波斯特-图灵机和艾伦·图灵1937年提出的图灵机。即使在当下，依然常有符合直觉的想法难以定义为形式化算法的情况。\n算法是有效方法，包含一系列定义清晰的指令，并可于有限的时间及空间内清楚的表述出来。算法中的指令描述的是一个计算，它执行時从一个初始状态和初始输入（可能为空）开始，经过一系列有限而清晰定义的状态最终产生输出并停止于一个终态。 一个状态到另一个状态的转移不一定是确定的。 包括随机化算法在内的一些算法，都包含了一些随机输入。\n\n历史\n算法在中国古代文献中称为“术”，最早出现在《周髀算經》、《九章算术》。特别是《九章算术》，给出四则运算、最大公约数、最小公倍数、开平方根、开立方根、求素数的埃氏篩，线性方程组求解的高斯消元法。三国時代的刘徽给出求圆周率的算法：刘徽割圆术。\n自唐代以来，历代更有许多专门论述“算法”的专著：\n\n唐代：《一位算法》 一卷，《算法》 一卷；\n宋代：《算法绪论》 一卷、《算法秘诀》 一卷；最著名的是杨辉的《杨辉算法》；\n元代：《丁巨算法》；\n明代：程大位 《算法统宗》\n清代：《开平算法》、《算法一得》、《算法全书》。\n而英文名稱「algorithm」来自于9世纪波斯数学家花拉子米（比阿勒·霍瓦里松，波斯語：خوارزمی，拉丁轉寫：al-Khwarizmi），因為比阿勒·霍瓦里松在数学上提出了算法这个概念。「算法」原为「algorism」，即“al-Khwarizmi”的音转，意思是“花剌子模的”运算法则，在18世纪演变为「algorithm」。\n欧几里得算法被人们认为是史上第一个算法。\n第一次编写程序是愛達·勒芙蕾絲（Ada Byron）于1842年为巴贝奇分析机编写求解解伯努利微分方程的程序，因此愛達·勒芙蕾絲被大多数人认为是世界上第一位程序员。因为查尔斯·巴贝奇（Charles Babbage）未能完成他的巴贝奇分析机，这个算法未能在巴贝奇分析机上执行。\n因为「well-defined procedure」缺少数学上精确的定义，19世纪和20世纪早期的数学家、逻辑学家在定义算法上出现了困难。20世纪的英国数学家图灵提出了著名的图灵论题，并提出一种假想的电脑的抽象模型，这个模型被称为图灵机。图灵机的出现解决了算法定义的难题，图灵的思想对算法的发展起到了重要的作用。\n\n特征\n以下是高德纳在他的著作《计算机程序设计艺术》里对演算法的特征归纳：\n\n输入：一个算法必须有零个或以上输入量。\n输出：一个算法应有一个或以上输出量，输出量是算法计算的结果。\n明确性：算法的描述必须无歧义，以保证算法的实际执行结果是精确地符合要求或期望，通常要求实际执行结果是确定的。\n有限性：依据图灵的定义，一个演算法是能够被任何图灵完备系统模拟的一串运算，而图灵机只有有限个状态、有限个输入符号和有限个转移函数（指令）。而一些定义更规定演算法必须在有限个步骤内完成任务。\n有效性：又称可行性。能够实现，算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现。\n\n基本要素\n算法的核心是建立问题抽象的模型和明确求解目标，之后可以根据具体的问题选择不同的模式和方法完成算法的设计。\n\n常用设计模式\n完全遍历法和不完全遍历法：在问题的解是有限离散解空间，且可以验证正确性和最优性时，最简单的算法就是把解空间的所有元素完全遍历一遍，逐个检测元素是否是我们要的解。这是最直接的算法，实现往往最简单。但是当解空间特别庞大时，这种算法很可能导致工程上无法承受的计算量。这时候可以利用不完全遍历方法——例如各种搜索法和规划法——来减少计算量。\n分治法：把一个问题分割成互相独立的多个部分分别求解的思路。这种求解思路带来的好处之一是便于进行并行计算。\n动态规划法：当问题的整体最优解就是由局部最优解组成的时候，经常采用的一种方法。贪婪算法：常见的近似求解思路。当问题的整体最优解不是（或无法证明是）由局部最优解组成，且对解的最优性没有要求的时候，可以采用的一种方法。\n线性规划法：见条目。\n简并法：把一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。\n\n常用实现方法\n递归方法与迭代方法\n顺序计算、并行计算和分布式运算：顺序计算就是把形式化算法用程序设计语言进行单线程序列化后执行。\n确定性算法和非确定性算法\n精确求解和近似求解\n\n形式化算法\n算法是电脑处理信息的本质，這是因为计算机程序本质上是一个用以告诉电脑确切的步骤並從中执行一个指定的任务的算法，如计算职工的薪水或打印学生的成绩单。一般而言，当算法在处理信息时，会从输入装置或数据的存储地址读取数据，將结果写入输出设备或某个存储地址供以后再调用。\n\n复杂度\n时间复杂度\n算法的时间复杂度是指算法需要消耗的时间资源。一般来说，电脑算法是问题规模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的函数\n  \n    \n      \n        f\n        (\n        n\n        )\n      \n    \n    {\\displaystyle f(n)}\n  \n，算法的时间复杂度也因此记做\n：\n  \n    \n      \n        T\n        (\n        n\n        )\n        =\n        \n          \n            O\n          \n        \n        (\n        f\n        (\n        n\n        )\n        )\n      \n    \n    {\\displaystyle T(n)={\\mathcal {O}}(f(n))}\n  \n\n算法执行时间的增长率与\n  \n    \n      \n        f\n        (\n        n\n        )\n      \n    \n    {\\displaystyle f(n)}\n  \n的增长率正相关，称作渐近时间复杂度，简称时间复杂度。\n常见的时间复杂度有：常数阶\n  \n    \n      \n        O\n        (\n        1\n        )\n      \n    \n    {\\displaystyle O(1)}\n  \n，对数阶\n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(\\log n)}\n  \n，线性阶\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n，线性对数阶\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n，平方阶\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n，立方阶\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{3})}\n  \n，...，\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n次方阶\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            k\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{k})}\n  \n，指数阶\n  \n    \n      \n        O\n        (\n        \n          2\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle O(2^{n})}\n  \n。随着问题规模\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。\n\n空间复杂度\n算法的空间复杂度是指算法需要消耗的空间资源，其计算及表示方法与时间复杂度类似，一般會使用复杂度的渐近性表示。不過，與时间复杂度相比，空间复杂度的分析是简单許多的。\n\n实现\n算法不单可以依靠计算机程序的使用所实现，也可以在人工神经网络、电路或者机械设备上实现。\n\n示例\n求最大值演算法\n这是算法的一个简单的例子。\n即为，我们有一串随机数列，我们的目的是找出这个数列中最大的数。而如果将数列中的每一个数位看成是一颗豆子的大小，可以将下面的算法形象地称为「捡豆子」：\n\n首先将第一颗豆子放入口袋中。\n从第二颗豆子开始检查，如果正在检查的豆子比口袋中的还大，则将它捡起放入口袋中，同时丢掉原先口袋中的豆子。反之则继续下一颗豆子。直到最后一颗豆子。\n最后口袋中的豆子就是所有的豆子中最大的一颗。以上算法在中国大陆的教科书中通常被叫做“打擂法”或者“循环打擂”：在一个for循环中，每轮循环都有新的挑战者。若挑战者胜的话，挑战者做新擂主，否则擂主卫冕。for循环结束后输出最后的擂主。\n下面是一个形式算法，用ANSI C代码表示\n\n求最大公約數演算法\n求两个自然数的最大公约数\n设两个变量\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n和\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n如果\n  \n    \n      \n        M\n        <\n        N\n      \n    \n    {\\displaystyle M<N}\n  \n，则交换\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n和\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n除以\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，得到余数\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n\n判断\n  \n    \n      \n        R\n        =\n        0\n      \n    \n    {\\displaystyle R=0}\n  \n，正确则\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n即为“最大公约数”，否则下一步\n将\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n赋值给\n  \n    \n      \n        M\n      \n    \n    {\\displaystyle M}\n  \n，将\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n赋值给\n  \n    \n      \n        N\n      \n    \n    {\\displaystyle N}\n  \n，重做第一步。\n用ANSI C代码表示\n\n利用if函式以及遞迴則能做出更為精簡的程式碼，更可省去交換的麻煩。（但是也因為遞迴呼叫，其空間複雜度提高）\n\n分类\n分类算法有多种方法，每种方法都有自己的优点。\n\n通过实施\n分类算法的一种方法是通过实现手段。\n\n递归\n递归算法是一种重复调用（引用）自身的算法，直到某个条件（也称为终止条件）匹配，这是函数式编程常用的方法。迭代算法使用循环之类的重复构造，有时使用堆栈之类的附加数据结构来解决给定的问题。有些问题自然适合于这种或那种实现。例如，使用递归实现可以很好地理解河内的塔。每个递归版本都有一个等价的（但可能或多或少复杂）迭代版本，反之亦然。\n串联的、平行的或分布的\n算法通常是在假设计算机一次执行一条算法指令的情况下讨论的。那些计算机有时被称为串行计算机。针对这种环境设计的算法称为串行算法，而不是并行算法或分布式算法。并行算法是利用计算机体系结构的算法，其中多个处理器可以同时处理一个问题。分布式算法是使用与计算机网络连接的多台机器的算法。并行和分布式算法将问题划分为更加对称或不对称的子问题，并将结果收集在一起。例如，CPU 就是并行算法的一个例子。这种算法的资源消耗不仅是每个处理器上的处理器周期，而且是处理器之间的通信开销。有些排序算法可以有效地并行化，但是它们的通信开销很大。迭代算法通常是可并行的，但有些问题没有并行算法，称为固有的串行问题。\n确定的或不确定的\n确定性算法在算法的每一步都用精确的决策来解决问题，而非确定性算法通过猜测来解决问题，虽然通过启发式使典型的猜测更加精确。\n精确的或近似的\n虽然许多算法达到一个精确的解决方案，近似算法寻求一个近似，更接近真正的解决方案。这种近似可以通过使用确定性策略或随机策略来实现。这些算法对许多难题都有实用价值。近似算法的一个例子是背包问题，其中有一组给定的项目。它的目标是包装背包，以获得最大的总价值。每个物品都有一定的重量和价值。可携带的总重量不超过某个固定数字 X，因此，解决方案必须考虑物品的重量及其价值。\n量子算法\n量子算法运行在一个现实的量子计算模型上。这个术语通常用于那些本质上似乎是量子的算法，或者使用量子计算的一些基本特性，如态叠加原理或量子纠缠。\n\n通过设计范例\n对算法进行分类的另一种方法是通过它们的设计方法或范例。有一定数量的范例，每一个不同于其他。此外，这些类别中的每一个都包括许多不同类型的算法。一些常见的范例是:\n\n暴力搜查或彻底搜查\n蛮力是一种解决问题的方法，包括系统地尝试每一种可能的选择，直到找到最佳解决方案。这种方法可能非常耗时，因为它需要遍历所有可能的变量组合。但是，当其他方法不可用或过于复杂时，常常使用这种方法。蛮力可以用来解决各种问题，包括寻找两点之间的最短路径和破解密码。\n各个击破\n分而治之的算法重复地将一个问题的实例减少为同一个问题的一个或多个更小的实例（通常是递归的） ，直到这些实例足够小以便于解决。分而治之的一个例子是合并排序。在将数据分割成片段后，可以对每个片段进行排序，在征服阶段通过合并片段可以对整个数据进行排序。一种更简单的分而治之的算法称为减而治算法，它解决一个相同的子问题，并使用这个子问题的解决方案来解决更大的问题。分治算法将问题划分为多个子问题，因此分治阶段比减少分治算法复杂。递减和征服算法的一个例子是二进制搜索算法。\n搜索和枚举\n许多问题（比如下棋）可以建模为图形上的问题。图探索算法规定了在图中移动的规则，对于这类问题非常有用。这一类别还包括搜索算法、分支和界枚举以及回溯。\n随机算法\n这样的算法随机（或伪随机）做出一些选择。它们可以非常有用地找到近似解决方案的问题，找到精确的解决方案可能是不切实际的（见下面的启发式方法）。对于其中的一些问题，我们知道最快的近似必须包含一些随机性。对于某些问题，具有多项式时间复杂度的随机算法能否成为最快的算法，是一个被称为“ P/NP问题”的悬而未决的问题。这种算法有两大类:\n蒙特卡罗算法以高概率返回正确答案。例如 RP 是这些运行在多项式时间的子类。\n拉斯维加斯算法总是返回正确的答案，但他们的运行时间只是概率约束，例如 ZPP。\n降低复杂性\n这种技术涉及到通过将一个困难问题转化为一个更广为人知的问题来解决它，我们（希望）已经有了渐近最优算法。目标是找到一种复杂度不受所得到的简化算法控制的简化算法。例如，一种用于在未排序列表中查找中值的选择算法首先对列表进行排序（代价较高的部分） ，然后取出排序列表中的中间元素（代价较低的部分）。这种技术也被称为转换和征服。\n反向追踪\n在这种方法中，多个解决方案是逐步构建的，当确定它们不能生成有效的完整解决方案时，就会放弃这些解决方案。\n\n优化问题\n对于最优化问题，有一个更具体的算法分类; 这类问题的算法可能属于上述一个或多个一般类别，也可能属于以下类别之一:\n\n线性规划\n当搜索受线性等式和不等式约束的线性函数的最优解时，该问题的约束可以直接用于产生最优解。有一些算法可以解决这类问题，比如流行的单纯形法。线性规划可以解决的问题包括有向图的最大流问题。如果一个问题额外要求一个或多个未知数必须是一个整数，那么它被分类为整数规划。一个线性规划算法可以解决这样的问题，如果它可以证明所有的限制整数值是表面的，即，解决方案满足这些限制。在一般情况下，根据问题的难度，使用专门的算法或找到近似解的算法。\n动态编程\n当一个问题显示出最优子结构ーー意味着一个问题的最优解可以从子问题的最优解构造出来ーー和重叠子问题，意味着同一个子问题可以用来解决许多不同的问题实例时，一种叫做动态规划的快速方法可以避免重新计算已经计算出来的解。例如，Floyd-Warshall 算法，在一个加权图中，通过使用从所有相邻顶点到达目标的最短路径，可以找到从一个顶点到达目标的最短路径。动态编程和制表一起使用。动态规划与分治的主要区别在于子问题在分治中或多或少是独立的，而子问题在动态规划中是重叠的。动态编程和简单递归的区别在于递归调用的缓存或制表。当子问题是独立的并且没有重复时，制表不起作用; 因此动态编程不是所有复杂问题的解决方案。通过使用制表法或维护已经解决的子问题表，动态规划将许多问题的指数性质降低到多项式复杂度。\n贪婪算法\n贪婪算法类似于动态规划算法，它通过检查子结构来工作，在这种情况下，不是检查问题，而是检查给定的解。这种算法从某种解开始，这种解可能已经给出或已经以某种方式构造出来，然后通过小的修改对其进行改进。对于一些问题，他们可以找到最优解，而对于其他问题，他们停留在局部最优，也就是说，在解决方案，不能改进的算法，但不是最优的。贪婪算法最常用的用途是寻找最小生成树，在这种方法中可以找到最优解。霍夫曼树，克鲁斯卡尔，普里姆，Sollin 是贪婪的算法，可以解决这个最佳化问题。\n启发式方法\n在优化问题中，如果不能找到最优解，可以使用启发式算法来寻找接近最优解的解。这些算法的工作原理是随着它们的进展越来越接近最优解。原则上，如果运行无限长的时间，他们会找到最优解。它们的优点是能够在相对较短的时间内找到一个非常接近最优解的解。这些算法包括本地搜索、禁忌搜索、模拟退火搜索和遗传算法。其中一些算法，如模拟退火，是非确定性算法，而其他的，如禁忌搜索，是确定性的。当非最优解的误差界限已知时，该算法进一步被归类为近似演算法。\n\n通过研究领域\n每个科学领域都有自己的问题，需要高效的算法。一个领域中的相关问题经常被一起研究。一些示例类是搜索算法、排序算法、合并算法、数值算法、图形算法、字符串算法、计算几何算法、组合算法、医学算法、机器学习、密码学、数据压缩算法和解析技术。\n字段之间往往相互重叠，一个字段的算法进步可能会改进其他字段的算法，有时候这些字段完全不相关。例如，动态规划是为了优化工业中的资源消耗而发明的，但是现在被用于解决许多领域中的广泛问题。\n\n通过复杂性\n算法可以根据它们需要完成的时间和它们的输入大小进行分类:\n\n常数时间: 如果算法所需的时间相同，则不管输入大小如何。例如，对数组元素的访问。\n对数时间: 如果时间是输入大小的对数函数。二进制搜索算法。\n线性时间: 如果时间与输入大小成正比。列表的遍历。\n多项式时间: 如果时间是输入大小的幂次。例如，气泡排序算法具有二次时间复杂度。\nEXPTIME: 如果时间是输入大小的指数函数。例如暴力搜索法。\n一些问题可能有多个不同复杂度的算法，而另一些问题可能没有算法或者没有已知的有效算法。还有从一些问题到其他问题的映射。由于这个原因，我们发现根据问题的最佳可能算法的复杂性，将问题本身分类比将算法分为等价类更为合适。\n\n连续算法\n形容词“连续”用于“算法”一词时，可以表示:\n\n对表示连续数量的数据进行操作的算法，即使这些数据是由离散近似表示的ーー这种算法是在数值分析中研究的; 或\n一种微分方程形式的算法，在模拟计算机上运行，不断地对数据进行操作。\n\n基本算法\n枚举\n搜索\n深度优先搜索\n广度优先搜索\n启发式搜索\n遗传算法\n数据结构的算法\n数论与代数算法\n计算几何的算法\n凸包算法\n图论的算法\n哈夫曼编码\n树的遍历\n最短路径算法\n最小生成树算法\n最小树形图\n网络流算法\n匹配算法\n分團問題\n动态规划\n其他\n数值分析\n加密算法\n排序算法\n检索算法\n随机化算法\n关于并行算法，请参阅并行计算一文。\n\n参考文献\n参考书目\n参閱\n延伸阅读\n[编]\n\n 《欽定古今圖書集成·曆象彙編·曆法典·算法部》，出自陈梦雷《古今圖書集成》\n\n外部链接\n\n20世纪十大算法 （页面存档备份，存于互联网档案馆）\n演算法笔记 （页面存档备份，存于互联网档案馆）\n计算几何算法概览 （页面存档备份，存于互联网档案馆）\n石溪算法库 （页面存档备份，存于互联网档案馆） – 石溪大学\n收集的ACM算法 （页面存档备份，存于互联网档案馆） – 计算机协会\n斯坦福图形库 互联网档案馆的存檔，存档日期December 6, 2015，. – 史丹佛大學"}
{"title": "A*搜尋演算法", "text": "A*搜索算法（英語：A* search algorithm）是一種在圖形平面上，有多個節點的路徑，求出最低通過成本的演算法。常用於遊戲中的NPC的移動計算，或网络游戏的BOT的移動計算上。\n该算法综合了最良優先搜索和戴克斯特拉算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（需要评估函数满足单调性）。\n在此算法中，如果以\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n表示从起点到任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的实际距离，\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n表示任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目标顶点的估算距离（根据所采用的评估函数的不同而变化），那么A*算法的估算函数为：\n\n  \n    \n      \n        f\n        (\n        n\n        )\n        =\n        g\n        (\n        n\n        )\n        +\n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle f(n)=g(n)+h(n)}\n  \n\n这个公式遵循以下特性：\n\n如果\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n为0，即只计算任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目标的评估函数\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n，而不计算起点到顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的距离，则算法转化为使用贪心策略的最良優先搜索，速度最快，但可能得不出最优解；\n如果\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n不大于顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目標頂點的實際距離，则一定可以求出最优解，而且\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离；\n如果\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n为0，即只需求出起点到任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的最短路径\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n，而不计算任何评估函数\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n，则转化为最短路问题，即戴克斯特拉算法，此时需要计算最多的顶点；\n\n虛擬碼\n相關連結\n寻路\n广度优先搜索\n深度优先搜索\n\n外部連結\nA* 演算法簡介 (A* Algorithm Brief)（页面存档备份，存于互联网档案馆）"}
{"title": "AC自动机算法", "text": "在计算机科学中，艾侯-科拉希克算法（英語：Aho–Corasick algorithm）是由阿尔佛雷德·艾侯和玛格丽特·J·科拉希克（Margaret J. Corasick）发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为a，aa，aaa，aaaa，输入的字符串为aaaa），算法的时间复杂度会近似于匹配的二次函数。\n该算法主要依靠构造一个有限状态机（类似于在一个trie树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串失败时进行回退（例如设Trie树的单词cat匹配失败，但是在Trie树中存在另一个单词cart，失配指针就会指向前缀ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。\n当一个字典串集合是已知的(例如一个计算机病毒库), 就可以以离线方式先将自动机求出并储存以供日后使用，在这种情况下，算法的时间复杂度为输入字符串长度和匹配数量之和。\nUNIX系统中的一个命令fgrep就是以AC自动机算法作为基础实现的。\n\n样例\n设一个字典中有如下单词：{a,ab,bab,bc,bca,c,caa}.\n下方的图是用AC自动机算法由该词典构造而成的一棵Trie树，其中每个节点都有一条从根节点到它的唯一路径，代表一个单词。\n在这种数据结构中，字符串的每一个前缀都有一个节点来表示（详见Trie）。所以如果（bca）在字典中，则会存在（bca），（bc），（b）和（）对应的节点。如果该节点表示的字符串在字典中存在，则该节点为一个蓝色节点，否则为一个灰色节点。\n树中的黑色有向边代表起点是终点的“父亲”（即起点对应字符串增加一个字符可得终点对应字符串），例如从（bc）有一条指向（bca）的黑色有向边。\n树中的蓝色有向边（后缀节点）代表终点对应字符串是起点对应字符串的最大严格后缀。例如对于一个节点（caa），它的严格后缀为（aa），（a）和（），其中在图中且最长的为（a），所以（caa）有一条指向（a）的蓝色有向边。一个节点的蓝色有向边可以在线性时间内通过重复遍历节点父亲节点的蓝色有向边直到横移节点（the traversing node）有一个属于目标节点前缀的孩子。\n树中的绿色有向边（字典后缀节点）代表终点是起点经过蓝色有向边到达的第一个蓝色节点（即字典中存在终点对应字符串）。例如（bca）有一条绿色边连向（a），因为（a）是（bca）通过蓝色有向边到达的第一个蓝色节点，路径为（bca）→（ca）→（a）。绿色有向边也可以在线性时间内通过遍历蓝色有向边直到找到一个蓝色节点，并用记忆化的方法计算。\n\n在每一步中，算法先查找当前节点的“孩子节点”，如果没有找到匹配，查找它的後缀（suffix）节点的孩子，如果仍然没有，接着查找後缀节点的後缀节点的孩子，如此循環，直到根結點，如果到达根节点仍没有找到匹配则结束。\n当算法查找到一个节点，则输出所有结束在当前位置的字典项。输出步骤为首先找到该节点的字典后缀，然后用递归的方式一直执行到节点没有字典前缀为止。同时，如果该节点为一个字典节点，则输出该节点本身。\n输入abccab后算法的执行步骤如下：\n\n参考来源\n外部链接\nSet Matching and Aho–Corasick Algorithm, lecture slides by Pekka Kilpeläinen\nAho–Corasick entry（页面存档备份，存于互联网档案馆） in NIST's Dictionary of Algorithms and Data Structures\nAho-Corasick implementation in C++（页面存档备份，存于互联网档案馆）\nAho-Corasick implementation in Go（页面存档备份，存于互联网档案馆）"}
{"title": "排序算法", "text": "在計算機科學與數學中，一個排序算法（英語：Sorting algorithm）是一種能將一串資料依照特定排序方式排列的算法，排序後的資料即可放在有序陣列。最常用到的排序方式是數值順序以及字典順序。有效的排序算法在一些算法（例如搜尋算法與合併算法）中是重要的，如此這些算法才能得到正確解答。排序算法也用在處理文字資料以及產生人類可讀的輸出結果。基本上，排序算法的輸出必須遵守下列兩個原則：\n\n輸出結果為遞增序列（遞增是針對所需的排序順序而言）\n輸出結果是原輸入的一種排列、或是重組\n雖然排序算法是一個簡單的問題，但是從計算機科學發展以來，在此問題上已經有大量的研究。舉例而言，泡沫排序在1956年就已經被研究。雖然大部分人認為這是一個已經被解決的問題，有用的新算法仍在不斷的被發明。（例子：圖書館排序在2004年被發表）\n\n分類\n在计算机科学所使用的排序算法通常依以下標準分類：\n\n計算的時間複雜度（最差、平均、和最好性能），依據串列（list）的大小(\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n)。一般而言，好的性能是\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n（大O符号），壞的性能是\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n。對於一個排序理想的性能是\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n，但平均而言不可能達到。基於比較的排序算法對大多數輸入而言至少需要\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n。\n内存使用量（以及其他電腦資源的使用）\n穩定性：穩定排序算法會讓原本有相等鍵值的紀錄維持相對次序。也就是如果一個排序算法是穩定的，當有兩個相等鍵值的紀錄\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n和\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n，且在原本的串列中\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n出現在\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n之前，在排序過的串列中\n  \n    \n      \n        R\n      \n    \n    {\\displaystyle R}\n  \n也將會是在\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n之前。\n排序的方法：插入、交換、選擇、合併等等。\n\n穩定性\n當相等的元素是無法分辨的，比如像是整數，穩定性並不是一個問題。然而，假設以下的數對將要以他們的第一個數字來排序。\n\n  \n    \n      \n        (\n        4\n        ,\n        1\n        )\n        (\n        3\n        ,\n        1\n        )\n        (\n        3\n        ,\n        7\n        )\n        (\n        5\n        ,\n        6\n        )\n      \n    \n    {\\displaystyle (4,1)(3,1)(3,7)(5,6)}\n  \n\n在這個狀況下，有可能產生兩種不同的結果，一個是讓相等鍵值的紀錄維持相對的次序，而另外一個則沒有：\n\n  \n    \n      \n        (\n        3\n        ,\n        1\n        )\n        (\n        3\n        ,\n        7\n        )\n        (\n        4\n        ,\n        1\n        )\n        (\n        5\n        ,\n        6\n        )\n      \n    \n    {\\displaystyle (3,1)(3,7)(4,1)(5,6)}\n  \n （維持次序）\n\n  \n    \n      \n        (\n        3\n        ,\n        7\n        )\n        (\n        3\n        ,\n        1\n        )\n        (\n        4\n        ,\n        1\n        )\n        (\n        5\n        ,\n        6\n        )\n      \n    \n    {\\displaystyle (3,7)(3,1)(4,1)(5,6)}\n  \n （次序被改變）\n\n不穩定排序算法可能會在相等的鍵值中改變紀錄的相對次序，但是穩定排序算法從來不會如此。不穩定排序算法可以被特別地實作為穩定。作這件事情的一個方式是人工擴充鍵值的比較，如此在其他方面相同鍵值的兩個物件間之比較，（比如上面的比较中加入第二个标准：第二个键值的大小）就會被決定使用在原先資料次序中的條目，當作一個同分決賽。然而，要記住這種次序通常牽涉到額外的空間負擔。\n\n排序算法列表\n在這個表格中，\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n是要被排序的紀錄數量以及\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n是不同鍵值的數量。\n\n穩定的排序\n冒泡排序（bubble sort）— \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n\n插入排序（insertion sort）—\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n\n鸡尾酒排序（cocktail sort）—\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n\n桶排序（bucket sort）—\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n；需要\n  \n    \n      \n        O\n        (\n        k\n        )\n      \n    \n    {\\displaystyle O(k)}\n  \n額外空間\n计数排序（counting sort）—\n  \n    \n      \n        O\n        (\n        n\n        +\n        k\n        )\n      \n    \n    {\\displaystyle O(n+k)}\n  \n；需要\n  \n    \n      \n        O\n        (\n        n\n        +\n        k\n        )\n      \n    \n    {\\displaystyle O(n+k)}\n  \n額外空間\n归并排序（merge sort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n；需要\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n額外空間\n原地归并排序— \n  \n    \n      \n        O\n        (\n        n\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log ^{2}n)}\n  \n如果使用最佳的現在版本\n二叉排序树排序（binary tree sort）— \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n期望时间；\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n最坏时间；需要\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n額外空間\n鸽巢排序（pigeonhole sort）—\n  \n    \n      \n        O\n        (\n        n\n        +\n        k\n        )\n      \n    \n    {\\displaystyle O(n+k)}\n  \n；需要\n  \n    \n      \n        O\n        (\n        k\n        )\n      \n    \n    {\\displaystyle O(k)}\n  \n額外空間\n基數排序（radix sort）—\n  \n    \n      \n        O\n        (\n        n\n        k\n        )\n      \n    \n    {\\displaystyle O(nk)}\n  \n；需要\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n額外空間\n侏儒排序（gnome sort）— \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n\n圖書館排序（library sort）— \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n期望时间；\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n最坏时间；需要\n  \n    \n      \n        (\n        1\n        +\n        ε\n        )\n        n\n      \n    \n    {\\displaystyle (1+\\varepsilon )n}\n  \n額外空間\n塊排序（block sort）— \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n\nTim排序（Timsort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n平均、最坏时间；\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n最优时间；需要\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n額外空間；是目前已知最快的排序算法，在Python、Swift、Rust等语言的内置排序功能中被用作默认算法\n\n不穩定的排序\n選擇排序（selection sort）—\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n\n希爾排序（shell sort）—\n  \n    \n      \n        O\n        (\n        n\n        \n          log\n          \n            2\n          \n        \n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log ^{2}n)}\n  \n如果使用最佳的現在版本\n克洛弗排序（Clover sort）—\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n期望时间，\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n最坏情况\n梳排序— \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n\n堆排序（heap sort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n\n平滑排序（smooth sort）— \n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n\n快速排序（quick sort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n期望時間，\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n最壞情況\n內省排序（introsort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(n\\log n)}\n  \n\n耐心排序（patience sort）—\n  \n    \n      \n        O\n        (\n        n\n        log\n        ⁡\n        n\n        +\n        k\n        )\n      \n    \n    {\\displaystyle O(n\\log n+k)}\n  \n最坏情況時間，需要額外的\n  \n    \n      \n        O\n        (\n        n\n        +\n        k\n        )\n      \n    \n    {\\displaystyle O(n+k)}\n  \n空間，也需要找到最長的遞增子序列（longest increasing subsequence）\n\n不實用的排序\nBogo排序— \n  \n    \n      \n        O\n        (\n        n\n        ×\n        n\n        !\n        )\n      \n    \n    {\\displaystyle O(n\\times n!)}\n  \n，最壞的情況下期望時間為無窮。\nStupid排序—\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            3\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{3})}\n  \n;遞迴版本需要\n  \n    \n      \n        O\n        (\n        \n          n\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{2})}\n  \n額外記憶體\n珠排序（bead sort）— \n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n 或 \n  \n    \n      \n        O\n        (\n        \n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle O({\\sqrt {n}})}\n  \n,但需要特別的硬體\n煎餅排序—\n  \n    \n      \n        O\n        (\n        n\n        )\n      \n    \n    {\\displaystyle O(n)}\n  \n,但需要特別的硬體\n臭皮匠排序（stooge sort）算法简单，但需要约\n  \n    \n      \n        \n          n\n          \n            2.7\n          \n        \n      \n    \n    {\\displaystyle n^{2.7}}\n  \n的时间\n\n简要比较\n均按从小到大排列\nk代表数值中的\"数位\"个数\nn代表数据规模\nm代表数据的最大值减最小值\n\n参考文献\n外部链接\n不同排序算法间的比较（英语） （页面存档备份，存于互联网档案馆）\n一些排序算法的C及Pascal实现\n可视化排序 （页面存档备份，存于互联网档案馆）"}
{"title": "Batcher归并网络", "text": "Batcher排序网络（英語：Batcher odd–even mergesort）是由一系列Batcher比较器（Batcher's Comparator）组成的。Batcher比较器是指在两个输入端给定输入x,y，再在两个输出端输出最大值max{x,y}和最小值min{x,y}。\n比较器网络是用Batcher比较器连成的完成某一功能的网络。\n所谓双调序列（Bitonic Sequence）是指由一个非严格增序列X和非严格减序列Y（其中X的最小元素正好是Y的最大元素）构成的序列，比如序列（23,10,8,3,5,7,11,78）。\n定义：一个序列a1,a2,…,an是双调序列，如果：\n\n存在一个ak(1≤k≤n),使得a1≥…≥ak≤…≤an成立；或者\n序列能够循环移位满足条件（1）\n\n奇偶归并网络\n输入两个已排好序的序列，对这两个序列进行归并排序，在串行算法中的时间复杂度为O(n)。在并行计算中可以用奇偶归并算法来实现的。以输入的两个4元素有序序列为A和B为例，首先将这两个序列进行逆洗牌（Unshuffle）得到两个序列：其中一个是由A,B中奇数号元素组成的序列，记作奇序列OM，另一个则是由A,B中偶数号元素组成的序列，记作偶序列序列EM。接着将OM送入（2,2）奇归并器中，将EM送入（2,2）偶归并器中。于是得到一组有序的奇序列和一组有序偶序列。最后除了奇序列一个元素之外将这两个序列进行洗牌（Shuffle）比较操作即可得到一个有序序列。\n算法的递归性：一个n阶的归并器是由两个n/2阶的归并器加一个洗牌比较网络构成的。比如上面的两个（2,2）归并器和最后的洗牌比较网络就构成了一个（4,4）的归并器。\n一个四阶奇偶归并的例子：假设归并前的的序列是（1,5,7,6）和（2,3,4,9），那么第一次操作就将（1,2,7,4）送入（2,2）归并器中归并，得到结果为（1,2,4,7）；（5,3,6,9）送入（2,2）归并器中归并，得到结果为（3,5,6,9），接着将这两个排号序的序列进行洗牌比较：(1,3<->2,5<->4,6<->7,9)=>(1,2,3,4,5,6,7,9)。\n可以证明这个算法是正确的，我们要用到高德纳（Donald Ervin Knuth）的0-1原理，我们发现，对于输入的任意两个有序的0,1序列，奇序列与偶序列正好相差0个，1个或2个0。由于奇序列的第一个元素不参与最后的洗牌比较，所以参与比较的0,1数偶只有0个或1个，所以对0,1序列一定能够得到正确的排序。故而对任意的序列，奇偶归并网络可以产生正确的排序。\n\n双调归并网络\n双调归并网络是基于Batcher定理而构建的。Batcher定理是说将任意一个长为2n的双调序列A分为等长的两半X和Y，将X中的元素与Y中的元素一一按原序比较，即\n  \n    \n      \n        \n          a\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle a_{i}}\n  \n与\n  \n    \n      \n        \n          a\n          \n            i\n            +\n            n\n          \n        \n        (\n        i\n        ≤\n        n\n        )\n      \n    \n    {\\displaystyle a_{i+n}(i\\leq n)}\n  \n比较，将较大者放入MAX序列，较小者放入MIN序列。则得到的MAX和MIN序列仍然是双调序列，并且MAX序列中的任意一个元素不小于MIN序列中的任意一个元素。\n根据这个原理，我们可以将一个输入的n元素双调序列首先通过洗牌比较操作得到一个MAX序列和一个MIN序列，然后通过两个n/2阶双调归并器处理就可以得到一个有序序列。\n这个算法也是递归的，因为n阶的双调归并器是由一个洗牌比较网络两个n/2阶的双调归并器组成的。\n\n参阅\n并行计算\n洗牌交换连接"}
{"title": "搜索算法", "text": "在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题的可行域中计算的信息。这种结构的例子包括但不限于链表，数组或搜索树。合适的搜索算法通常取决于正在搜索的数据结构，并且还可能包括有关数据的先前知识。搜索还包含查询数据结构的算法，例如SQL SELECT命令。\n搜索算法可以根据搜索机制进行分类。线性搜索算法以线性方式检查每个与目标关键字关联的记录。二分或折半搜索（二分查找算法）重复定位搜索结构的中心，并将搜索空间分成两半。比较搜索算法通过基于键的比较相继地消除记录来改进线性搜索，直到找到目标记录为止，并且可以按照定义的顺序应用于数据结构。数字搜索算法基于使用数字键的数据结构中的数字属性工作。最后，哈希根据散列函数直接将键映射到记录。在线性搜索之外进行搜索需要以某种方式对数据进行排序。此外，使用了启发式信息的方法称为启发式搜索。\n搜索功能常根据其复杂性或最大理论运行时间进行评估。例如，二分查找算法的最大复杂度为\n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle O(\\log n)}\n  \n，即对数时间复杂度，这意味着查找搜索目标所需的最大操作次数是搜索空间大小的对数函数。其它评估方式包括完备性、空间复杂性、最优性。\n\n应用\n搜索算法的具体应用包括：\n\n组合优化中的问题，例如：\n车辆路径问题，最短路径问题的一种形式\n背包问题：给定一组物品，每个物品都有一个重量和一个价值，确定每个物品在集合中的数量，使总重量小于或等于给定的极限，并且总价值尽可能大。\n护士排班问题\n約束滿足問題，例如：\n地图着色问题\n填写数独或填字游戏\n在博弈论中，尤其是組合博弈論中，选择下一步的最佳行动（例如极小化极大算法）\n从一整套可能性中找到组合或密码\n整数的因子分解（密码学中的一个重要问题）\n搜索引擎优化（SEO）和网络爬虫的内容优化\n通过改变工艺参数（如温度、压力和pH）来优化包括如化学反应在内的工业工艺\n从数据库中检索记录\n在列表或数组中查找最大值或最小值\n检查给定值是否存在于一组值中\n\n搜索策略\n宽度优先搜索\n宽度优先搜索算法是沿着树的宽度遍历树的节点，如果发现目标，则算法中止。属于盲目搜索。\n\n深度优先搜索\n深度优先搜索沿着树的最大深度方向生成节点并与目标节点进行比较，只有当上次访问的节点不是目标节点，而且没有其他节点可以生成的时候，才转到上次访问节点的父节点，然后搜索该节点的其他子节点。因此深度优先搜索也称为回溯搜索。它既不是完备的，也不是最优的。有时候，某些特定的问题会产生大量重复的节点。例如“八数码”问题就是这样的，当每次运用向上、向下、向左、向右移动空格的算符时，可能产生与已经产生的节点重复的节点。当再次搜索到这个重复节点时，由于应用的算符基本一致，还会产生重复，所以为了节约时间和存储空间，往往在深度优先算法中设立一个机制，用来删除这些重复的节点，以提高效率。\n\n迭代加深搜索（ID搜索）\n对深度优先搜索进行了一定改进，对搜索树的深度进行控制，即有界深度优先搜索。\n在程序找到目标之前，通过迭代不断增大以保证完备性和最优性。虽然会有不少重复搜索，但是鉴于每增加一次d，则搜索的时间复杂度会以指数级别增加，所以重复搜索的时间可以忽略，亦可以与A*算法结合（即IDA*搜索算法）来剪枝。\n迭代加深搜索通常用于那种搜索树又深又宽、但是解并不是很深的情况，这时广度优先搜索会超空间，而深度优先搜索会超时。这时迭代加深搜索很有用，可是说是在用递归方法在实现广度优先搜索。\n\n启发式OR图搜索算法\n爬山算法\n模拟退火算法\n最好优先\n通用图\nA*\n\nAND-OR图启发式搜索\n一个特殊问题：博弈论\n\n约束满足搜索\n搜索策略还可以指在使用搜索引擎中所使用的策略，它通常是搜索之母，一个好的搜索过程必定有一个好的搜索策略来支持。\n\n分类\n对于虚拟搜索空间\n求解器在约束满足问题中使用搜索虚拟空间的算法，其目标是找到一组赋值给某些变量的值赋值，以满足特定的数学方程和不等式。当目标是找到一个可以最大化或最小化这些变量的某个函数的变量赋值时，也会使用它们。针对这些问题的算法包括基本的强力搜索（也称为“天真”或“非信息”搜索）以及尝试利用关于该空间结构的部分知识的各种启发式算法，如线性松弛，约束生成，和约束传播。\n一个重要的子类是局部搜索方法，它将搜索空间的元素视为图的顶点，其边由适用于该案例的一组启发法定义; 并且通过沿着边缘从物品移动到物品来扫描空间，例如根据最速下降或最佳优先标准，或者在随机搜索中。这一类包括各种通用的启发式方法，如模拟退火，禁忌搜索，A-团队和遗传编程，它们以特定的方式结合了任意的启发式方法。该类还包括各种树搜索算法，将元素视为树的顶点，并以某种特定顺序遍历树。后者的例子包括深度优先搜索和广度优先搜索等详尽的方法，以及各种基于启发式的搜索树修剪方法，如回溯和分支定界。与一般的metaheuristics不同，后者至多只能以概率的方式工作，如果给予足够的时间，许多这些树搜索方法都能保证找到确切的或最优的解决方案。这被称为“ 完整性 ”。\n另一个重要的子类包括用于探索多玩家游戏（例如国际象棋或西洋双陆棋）的游戏树的算法，其中节点包括可能由当前情况导致的所有可能的游戏情况。这些问题的目标是找到提供最佳赢球机会的举措，同时考虑到对手的所有可能举措。当人类或机器必须作出连续的决定，其结果不完全在其控制之下时，例如在机器人指导或营销，财务或军事战略规划中，就会出现类似的问题。这种问题 - 组合搜索- 在人工智能的背景下进行了广泛的研究。这个类的算法的例子是极小极大算法，alpha-beta修剪，*信息搜索和A *算法。\n\n对于给定结构的子结构\n名称“组合搜索”通常用于查找给定离散结构的特定子结构的算法，例如图形，字符串，有限组等。术语组合优化通常用于当目标是找到具有某个参数的最大值（或最小值）的子结构时。（由于子结构通常在计算机中用一组带有约束的整数变量来表示，所以这些问题可以看作是约束满足或离散优化的特例;但它们通常是在一个更抽象的情况下制定和解决的，内部表示没有明确提及。）\n一个重要且广泛研究的子类是图算法，特别是图遍历算法，用于查找给定图中的特定子结构 - 例如子图，路径，电路等。例子包括Dijkstra算法，Kruskal算法，最近邻算法和Prim算法。\n这个类别的另一个重要子类是字符串搜索算法，它搜索字符串内的模式。两个着名的例子是Boyer-Moore和Knuth-Morris-Pratt算法，以及一些基于后缀树数据结构的算法。\n\n对于量子计算机\n还有为量子计算机设计的搜索方法，如Grover算法，即使没有数据结构或启发式的帮助，它在理论上也比线性或强力搜索更快。\n\n\n== 引用 =="}
{"title": "A*", "text": "A*搜索算法（英語：A* search algorithm）是一種在圖形平面上，有多個節點的路徑，求出最低通過成本的演算法。常用於遊戲中的NPC的移動計算，或网络游戏的BOT的移動計算上。\n该算法综合了最良優先搜索和戴克斯特拉算法的优点：在进行启发式搜索提高算法效率的同时，可以保证找到一条最优路径（需要评估函数满足单调性）。\n在此算法中，如果以\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n表示从起点到任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的实际距离，\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n表示任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目标顶点的估算距离（根据所采用的评估函数的不同而变化），那么A*算法的估算函数为：\n\n  \n    \n      \n        f\n        (\n        n\n        )\n        =\n        g\n        (\n        n\n        )\n        +\n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle f(n)=g(n)+h(n)}\n  \n\n这个公式遵循以下特性：\n\n如果\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n为0，即只计算任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目标的评估函数\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n，而不计算起点到顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的距离，则算法转化为使用贪心策略的最良優先搜索，速度最快，但可能得不出最优解；\n如果\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n不大于顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n到目標頂點的實際距離，则一定可以求出最优解，而且\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n越小，需要计算的节点越多，算法效率越低，常见的评估函数有——欧几里得距离、曼哈顿距离、切比雪夫距离；\n如果\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n为0，即只需求出起点到任意顶点\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的最短路径\n  \n    \n      \n        g\n        (\n        n\n        )\n      \n    \n    {\\displaystyle g(n)}\n  \n，而不计算任何评估函数\n  \n    \n      \n        h\n        (\n        n\n        )\n      \n    \n    {\\displaystyle h(n)}\n  \n，则转化为最短路问题，即戴克斯特拉算法，此时需要计算最多的顶点；\n\n虛擬碼\n相關連結\n寻路\n广度优先搜索\n深度优先搜索\n\n外部連結\nA* 演算法簡介 (A* Algorithm Brief)（页面存档备份，存于互联网档案馆）"}
{"title": "Dijkstra算法", "text": "戴克斯特拉算法（英語：Dijkstra's algorithm），又稱迪杰斯特拉算法、Dijkstra算法，是由荷兰计算机科学家艾茲赫尔·戴克斯特拉在1956年发现的算法，并于3年后在期刊上发表。戴克斯特拉算法使用类似廣度优先搜索的方法解决赋权图的单源最短路径问题。\n该算法存在很多变体：戴克斯特拉的原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。\n该算法解决了圖 \n  \n    \n      \n        G\n        =\n        ⟨\n        V\n        ,\n        E\n        ⟩\n      \n    \n    {\\displaystyle G=\\langle V,E\\rangle }\n  \n上带权的单源最短路径问题。具体来说，戴克斯特拉算法设置了一顶点集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n，在集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中所有的顶点与源点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n之间的最终最短路径权值均已确定。算法反复选择最短路径估计最小的点\n  \n    \n      \n        u\n        ∈\n        \n          V\n          −\n          S\n        \n      \n    \n    {\\displaystyle u\\in {V-S}}\n  \n并将\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中。该算法常用于路由算法或者作为其他图算法的一个子模块。举例来说，如果图中的顶点表示城市，而边上的权重表示城市间开车行经的距离，该演算法可以用来找到两个城市之间的最短路径。\n应当注意，绝大多数的戴克斯特拉算法不能有效处理带有负权边的图。\n戴克斯特拉算法在计算机科学的人工智能等领域也被称为均一开销搜索，并被认为是最良优先搜索的一个特例。\n\n描述\n戴克斯特拉算法通過保留目前為止所找到的每個頂點\n  \n    \n      \n        v\n        ∈\n        V\n      \n    \n    {\\displaystyle v\\in V}\n  \n從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑來工作。初始時，原點\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n的路径权重被賦為 0 （即原点的实际最短路径=0）。同時把所有其他頂點的路徑長度設為無窮大，即表示我們不知道任何通向這些頂點的路徑。當算法結束時，\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n 中儲存的便是從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑，或者如果路徑不存在的話是無窮大。\n松弛操作是戴克斯特拉算法的基礎操作：如果存在一條從\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的邊，那麼從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的一条新路径是將邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n        ∈\n        E\n      \n    \n    {\\displaystyle w(u,v)\\in E}\n  \n添加到從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路徑尾部來拓展一條從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的路径。這條路徑的長度是\n  \n    \n      \n        d\n        [\n        u\n        ]\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle d[u]+w(u,v)}\n  \n。如果這個值比目前已知的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n的值要小，那么可以用这个值來替代當前\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n中的值。松弛邊的操作一直執行到所有的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n都代表從\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短路徑的长度值。\n算法維護兩個頂點集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n和\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n保留所有已知实际最短路径值的頂點，而集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n則保留其他所有頂點。集合\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n初始狀態為空，而後每一步都有一個頂點從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n移動到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n。這個被選擇的頂點是\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中擁有最小的\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點。當一個頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n從\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中轉移到了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中，算法對\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的每条外接邊\n  \n    \n      \n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle w(u,v)}\n  \n進行松弛。\n《算法导论》中给出了以下伪代码：该伪代码计算并保留图\n  \n    \n      \n        G\n      \n    \n    {\\displaystyle G}\n  \n中原点\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到每一顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n的最短距离\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n。其中，函数\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle Extract-Min(Q)}\n  \n将頂點集合\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中有最小\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n值的頂點\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中删除并返回\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n。\n\n 1  function Dijkstra(G, w, s)\n 2   INITIALIZE-SINGLE-SOURCE(G, s)                //实际上的操作是将每个除原点外的顶点的\n  \n    \n      \n        d\n        [\n        v\n        ]\n      \n    \n    {\\displaystyle d[v]}\n  \n置为无穷大，\n  \n    \n      \n        d\n        [\n        s\n        ]\n        =\n        0\n      \n    \n    {\\displaystyle d[s]=0}\n  \n\n 3   \n  \n    \n      \n        S\n        ←\n        ∅\n      \n    \n    {\\displaystyle S\\leftarrow \\emptyset }\n  \n\n 4   \n  \n    \n      \n        Q\n        ←\n        s\n      \n    \n    {\\displaystyle Q\\leftarrow s}\n  \n                                //\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n是顶点\n  \n    \n      \n        V\n      \n    \n    {\\displaystyle V}\n  \n的一个优先队列，以顶点的最短路径估计排序\n 5   while(\n  \n    \n      \n        Q\n        ≠\n        ∅\n      \n    \n    {\\displaystyle Q\\not =\\emptyset }\n  \n)\n 6       do \n  \n    \n      \n        u\n        ←\n        E\n        X\n        T\n        R\n        A\n        C\n        T\n        −\n        M\n        I\n        N\n        (\n        Q\n        )\n      \n    \n    {\\displaystyle u\\leftarrow EXTRACT-MIN(Q)}\n  \n          //选取\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n为\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中最短路径估计最小的顶点\n 7       \n  \n    \n      \n        S\n        ←\n        S\n        ∪\n        u\n      \n    \n    {\\displaystyle S\\leftarrow S\\cup u}\n  \n\n 8       for each vertex v \n  \n    \n      \n        ∈\n        A\n        d\n        j\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle \\in Adj[u]}\n  \n\n 9            do RELAX(u, v, w)            //松弛成功的结点会被加入到队列中\n\n如果我們只對在\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n和\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n之間尋找一條最短路徑的話，我們可以在第5或第6行添加條件如果滿足\n  \n    \n      \n        u\n        =\n        t\n      \n    \n    {\\displaystyle u=t}\n  \n的話終止程序。\n在肯尼·罗森所著的《离散数学及其应用》中给出了如下的另一份伪代码：\n\n 1 procedure Dijkstra(G：边全为正权的图）\n 2   {G带有顶点\n  \n    \n      \n        a\n        =\n        \n          v\n          \n            0\n          \n        \n        ,\n        \n          v\n          \n            1\n          \n        \n        ,\n        \n          v\n          \n            2\n          \n        \n        .\n        .\n        .\n      \n    \n    {\\displaystyle a=v_{0},v_{1},v_{2}...}\n  \n和若干边\n  \n    \n      \n        w\n        (\n        \n          v\n          \n            i\n          \n        \n        ,\n        \n          v\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle w(v_{i},v_{j})}\n  \n}\n 3    for \n  \n    \n      \n        i\n        :=\n        1\n      \n    \n    {\\displaystyle i:=1}\n  \n to n\n 4       \n  \n    \n      \n        D\n        (\n        \n          v\n          \n            i\n          \n        \n        )\n        :=\n        ∞\n      \n    \n    {\\displaystyle D(v_{i}):=\\infty }\n  \n\n 5    \n  \n    \n      \n        D\n        (\n        a\n        )\n        :=\n        0\n      \n    \n    {\\displaystyle D(a):=0}\n  \n\n 6    \n  \n    \n      \n        S\n        :=\n        ∅\n      \n    \n    {\\displaystyle S:=\\emptyset }\n  \n\n 7    while \n  \n    \n      \n        z\n        ∉\n        S\n      \n    \n    {\\displaystyle z\\notin S}\n  \n\n 8    begin\n 9          \n  \n    \n      \n        u\n        :=\n      \n    \n    {\\displaystyle u:=}\n  \n不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的\n  \n    \n      \n        D\n        (\n        u\n        )\n      \n    \n    {\\displaystyle D(u)}\n  \n最小的一个顶点\n 10        \n  \n    \n      \n        S\n        :=\n        S\n        ∪\n        {\n        u\n        }\n      \n    \n    {\\displaystyle S:=S\\cup \\{u\\}}\n  \n\n 11        for 所有不属于\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n的顶点\n  \n    \n      \n        v\n      \n    \n    {\\displaystyle v}\n  \n\n 12            if \n  \n    \n      \n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n        <\n        D\n        (\n        v\n        )\n      \n    \n    {\\displaystyle D(u)+w(u,v)<D(v)}\n  \n then \n  \n    \n      \n        D\n        (\n        v\n        )\n        :=\n        D\n        (\n        u\n        )\n        +\n        w\n        (\n        u\n        ,\n        v\n        )\n      \n    \n    {\\displaystyle D(v):=D(u)+w(u,v)}\n  \n\n 13    end{\n  \n    \n      \n        D\n        (\n        z\n        )\n        =\n      \n    \n    {\\displaystyle D(z)=}\n  \n从a到z的最短路长度}\n\n時間複雜度\n我們可以用大O符號將该算法的運行時間表示為邊數\n  \n    \n      \n        \n          |\n        \n        E\n        \n          |\n        \n      \n    \n    {\\displaystyle |E|}\n  \n和頂點數\n  \n    \n      \n        \n          |\n        \n        V\n        \n          |\n        \n      \n    \n    {\\displaystyle |V|}\n  \n的函數。\n对于任何基于顶点集\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n的实现，算法的运行时间是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        ⋅\n        d\n        \n          k\n          \n            Q\n          \n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        ⋅\n        e\n        \n          m\n          \n            Q\n          \n        \n        )\n      \n    \n    {\\displaystyle O(|E|\\cdot dk_{Q}+|V|\\cdot em_{Q})}\n  \n，其中\n  \n    \n      \n        d\n        \n          k\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle dk_{Q}}\n  \n和\n  \n    \n      \n        e\n        \n          m\n          \n            Q\n          \n        \n      \n    \n    {\\displaystyle em_{Q}}\n  \n分别表示完成键的降序排列时间和从\n  \n    \n      \n        Q\n      \n    \n    {\\displaystyle Q}\n  \n中提取最小键值的时间。\n对于没有任何优化的戴克斯特拉算法，实际上等价于每次遍历了整个图的所有结点来找到Q中满足条件的元素（即寻找最小的頂點是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|)}\n  \n的），此外实际上还需要遍历所有的边一遍，因此算法的复杂度是\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n        +\n        \n          |\n        \n        E\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|V|^{2}+|E|)}\n  \n。\n對於邊數少於\n  \n    \n      \n        \n          |\n        \n        V\n        \n          \n            |\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle |V|^{2}}\n  \n的稀疏圖來說，可以用鄰接表來更有效的實現该算法。\n可以使用一個二叉堆或者斐波納契堆用作優先隊列來尋找最小的頂點（\n  \n    \n      \n        E\n        x\n        t\n        r\n        a\n        c\n        t\n        −\n        M\n        i\n        n\n      \n    \n    {\\displaystyle Extract-Min}\n  \n）以优化算法。當用到二叉堆的時候，算法所需的時間為\n  \n    \n      \n        O\n        (\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O((|E|+|V|)\\log |V|)}\n  \n，斐波納契堆能提高一些性能，讓算法運行時間達到\n  \n    \n      \n        O\n        (\n        \n          |\n        \n        E\n        \n          |\n        \n        +\n        \n          |\n        \n        V\n        \n          |\n        \n        log\n        ⁡\n        \n          |\n        \n        V\n        \n          |\n        \n        )\n      \n    \n    {\\displaystyle O(|E|+|V|\\log |V|)}\n  \n。然而，使用斐波納契堆进行编程，有时会由于算法常数过大而导致速度没有显著提高。\n下面是一些戴克斯特拉算法经典实现的复杂度比较：\n\n正确性证明\n戴克斯特拉本人在他的论文中给出了一份简单的证明。\n《算法导论》使用循环不变式（数学归纳法）给出了如下的一份证明：\n\n已知一带权图\n  \n    \n      \n        G\n        =<\n        V\n        ,\n        E\n        >\n      \n    \n    {\\displaystyle G=<V,E>}\n  \n，其加权函数\n  \n    \n      \n        w\n      \n    \n    {\\displaystyle w}\n  \n的值非负，源点为\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n。对该图运行戴克斯特拉算法，对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。其中\n  \n    \n      \n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[u]}\n  \n表示u点的最短路径估计，\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,u)}\n  \n表示\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点的最短路径。\n证明：证明如下的循环不变式成立即可：在每次执行EXTRACT-MIN时，对每个顶点\n  \n    \n      \n        u\n        ∈\n        S\n      \n    \n    {\\displaystyle u\\in S}\n  \n，有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n成立即可。由于上界性质，在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n加入了\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n之后，一旦有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n，则在后面的每次循环中都不会改变这个性质。\n初始化：第一次循环前，\n  \n    \n      \n        S\n        =\n        ∅\n      \n    \n    {\\displaystyle S=\\emptyset }\n  \n，因此循环不变式显然成立。\n保持：实际上要证明每一轮循环中加入到\n  \n    \n      \n        S\n      \n    \n    {\\displaystyle S}\n  \n中的结点满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。利用反证法，假设\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足此条件的结点，考虑循环开始前的状况，首先\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n一定不等于\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n，这是显然的。其次\n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n一定有到\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n的路径，否则路径为无穷大。那么假设在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n进入时，有最短路径\n  \n    \n      \n        p\n        =\n        s\n        −\n        >\n        u\n      \n    \n    {\\displaystyle p=s->u}\n  \n，假设该路径上存在两个点\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n，\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n。\n  \n    \n      \n        y\n        ∈\n        V\n        −\n        S\n      \n    \n    {\\displaystyle y\\in V-S}\n  \n、\n  \n    \n      \n        x\n        ∈\n        S\n      \n    \n    {\\displaystyle x\\in S}\n  \n，且x是y的前驱，路径\n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n可以分解为\n  \n    \n      \n        s\n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n        x\n        −\n        >\n        y\n        −\n        \n          p\n          \n            2\n          \n        \n        −\n        >\n        u\n      \n    \n    {\\displaystyle s-p_{1}->x->y-p_{2}->u}\n  \n（此处\n  \n    \n      \n        −\n        \n          p\n          \n            1\n          \n        \n        −\n        >\n      \n    \n    {\\displaystyle -p_{1}->}\n  \n表示经过\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n这条路径，后同），其中路径\n  \n    \n      \n        \n          p\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle p_{1}}\n  \n和路径\n  \n    \n      \n        \n          p\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle p_{2}}\n  \n可以为空。由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n是第一个不满足\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n的，又因为\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n是满足该条件的，而且\n  \n    \n      \n        (\n        x\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle (x,y)}\n  \n一定已经被松弛过了，所以\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n是满足该条件的。\n现在只需要推出矛盾，即可证明u不存在：\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n在\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n之前出现，而且图中所有权值非负，因此有\n  \n    \n      \n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle \\delta (s,y)\\leq \\delta (s,u)}\n  \n，所以：\n  \n    \n      \n        d\n        [\n        y\n        ]\n        ≤\n        δ\n        (\n        s\n        ,\n        y\n        )\n        ≤\n        δ\n        (\n        s\n        ,\n        u\n        )\n        ≤\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]\\leq \\delta (s,y)\\leq \\delta (s,u)\\leq d[u]}\n  \n，但是由于\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n和\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n同时在\n  \n    \n      \n        V\n        −\n        S\n      \n    \n    {\\displaystyle V-S}\n  \n中，因此\n  \n    \n      \n        d\n        [\n        u\n        ]\n        ≤\n        d\n        [\n        y\n        ]\n      \n    \n    {\\displaystyle d[u]\\leq d[y]}\n  \n，因此必有\n  \n    \n      \n        d\n        [\n        y\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        y\n        )\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n        =\n        d\n        [\n        u\n        ]\n      \n    \n    {\\displaystyle d[y]=\\delta (s,y)=\\delta (s,u)=d[u]}\n  \n，也就证明了\n  \n    \n      \n        u\n      \n    \n    {\\displaystyle u}\n  \n点不可能不满足该条件，上述假设为假，原命题得证。\n终止：终止时，\n  \n    \n      \n        Q\n        =\n        ∅\n      \n    \n    {\\displaystyle Q=\\emptyset }\n  \n，由于\n  \n    \n      \n        Q\n        =\n        V\n        −\n        S\n      \n    \n    {\\displaystyle Q=V-S}\n  \n，因此\n  \n    \n      \n        V\n        =\n        S\n      \n    \n    {\\displaystyle V=S}\n  \n，因此对所有\n  \n    \n      \n        u\n        ∈\n        V\n      \n    \n    {\\displaystyle u\\in V}\n  \n有\n  \n    \n      \n        d\n        [\n        u\n        ]\n        =\n        δ\n        (\n        s\n        ,\n        u\n        )\n      \n    \n    {\\displaystyle d[u]=\\delta (s,u)}\n  \n。\n\n起源与历史\n从鹿特丹到格罗宁根的最短路径是什么？实际上，这就是对于任意两座城市之间的最短路问题。解决这个问题实际上大概只花了我20分钟：一天早上，我和我的未婚妻在阿姆斯特丹购物，累了，我们便坐在咖啡馆的露台上喝咖啡，然后我就试了一下能否用一个算法解决最短路问题。正如我所说，这是一个20分钟的发现。不过实际上，我在3年后的1959年才把这个算法发表在论文上。即使现在来看这篇论文的可读性也非常高，这个算法之所以如此优雅，其中一个原因就是我没用笔纸就设计了它。后来我才知道，没用笔纸设计的优点之一是你不得不避免所有可避免的复杂问题。令我惊讶的是，这个算法最终成为我成名的基石之一。\n戴克斯特拉1956年在荷兰数学和计算机科学研究学会担任程序员时为了展示新型计算机ARMAC的功能曾思考过最短路径问题的解法。他的目标是让不去实际计算的人也能理解这个问题和解决的方法，于是他在发现了这个算法之后在ARMAC上做了简单实验。1959年，他正式将此算法发表在期刊上，该算法也成为了戴克斯特拉成名的基石之一。\n\n相关应用\n链路状态路由协议中需要计算最短路时常常要用到该算法，该算法在開放最短路徑優先和中间系统到中间系统协议中的相关应用是其在網絡路由中的典型實現。\n戴克斯特拉算法及其改进算法应用广泛，尤其是在寻路、交通、规划中。\n如果有已知信息可用來估計某一點到目標點的距離，則可改用A*搜尋算法，以減小最短路徑的搜索範圍，戴克斯特拉算法本身也可以看作是A*搜索算法的一个特例。\n戴克斯特拉算法本身采用了与Prim算法类似的贪心策略。快速行进算法与戴克斯特拉算法同样有相似之处。\n\n参考源程序\n以下是该算法使用堆优化的一个C++实现参考：\n\n以下是该算法Python的一个实现：\n\n参见\n图论\nA*搜尋演算法\n贝尔曼-福特算法\n宽度优先搜索\nFlood fill\nFloyd-Warshall算法\n最长路径问题\n\n參考\n参考文献\n扩展阅读\n外部連結\n\n迪科斯彻算法分解演示视频（优酷） （页面存档备份，存于互联网档案馆）\nAnimation of Dijkstra's algorithm （页面存档备份，存于互联网档案馆）\nThe Boost Graph Library (BGL) （页面存档备份，存于互联网档案馆）\nInteractive Implementation of Dijkstra's Algorithm （页面存档备份，存于互联网档案馆）\nShortest Path Problem: Dijkstra's Algorithm\nDijkstra算法使用TDD的一个实现 （页面存档备份，存于互联网档案馆）\nGraphical explanation of Dijkstra's algorithm step-by-step on an example （页面存档备份，存于互联网档案馆）"}
{"title": "K-近邻算法", "text": "在模式识别领域中，最近鄰居法（KNN算法，又譯K-近邻算法）是一种用于分类和回归的無母數統計方法，由美国统计学家伊芙琳·费克斯和小約瑟夫·霍奇斯于1951年首次提出，后来由托馬斯·寇弗扩展。在这两种情况下，输入包含特徵空間中的k个最接近的训练样本。\n\n在k-NN分类中，输出是一个分类族群。一个对象的分类是由其邻居的“多数表决”确定的，k个最近邻居（k为正整数，通常较小）中最常见的分类决定了赋予该对象的类别。若k = 1，则该对象的类别直接由最近的一个节点赋予。\n在k-NN回归中，输出是该对象的属性值。该值是其k个最近邻居的值的平均值。\n最近鄰居法採用向量空間模型來分類，概念為相同類別的案例，彼此的相似度高，而可以藉由計算與已知類別案例之相似度，來評估未知類別案例可能的分類。\nK-NN是一种循例學習，或者是局部近似和将所有计算推迟到分类之后的惰性学习。k-近邻算法是所有的机器学习算法中最简单的之一。\n无论是分类还是回归，衡量邻居的权重都非常有用，使较近邻居的权重比较远邻居的权重大。例如，一种常见的加权方案是给每个邻居权重赋值为1/ d，其中d是到邻居的距离。\n邻居都取自一组已经正确分类（在回归的情况下，指属性值正确）的对象。虽然没要求明确的训练步骤，但这也可以当作是此算法的一个训练样本集。\nk-近邻算法的缺点是对数据的局部结构非常敏感。\nK-平均算法也是流行的机器学习技术，其名稱和k-近邻算法相近，但兩者没有关系。数据标准化可以大大提高该算法的准确性。\n\n算法\n训练样本是多维特征空间向量，其中每个训练样本带有一个类别标签。算法的训练阶段只包含存储的特征向量和训练样本的标签。\n在分类阶段，k是一个用户定义的常数。一个没有类别标签的向量（查询或测试点）将被归类为最接近该点的k个样本点中最频繁使用的一类。\n一般情况下，将欧氏距离作为距离度量，但是这是只适用于连续变量。在文本分类这种离散变量情况下，另一个度量——“重叠度量”（或海明距离）可以用来作为度量。例如对于基因表达微阵列数据，k-NN也与Pearson和Spearman相关系数结合起来使用。通常情况下，如果运用一些特殊的算法来计算度量的话，k近邻分类精度可显著提高，如运用大间隔最近邻居或者邻里成分分析法。\n“多数表决”分类会在类别分布偏斜时出现缺陷。也就是说，出现频率较多的样本将会主导测试点的预测结果，因为他们比较大可能出现在测试点的K邻域而测试点的属性又是通过k邻域内的样本计算出来的。解决这个缺点的方法之一是在进行分类时将样本到k个近邻点的距离考虑进去。k近邻点中每一个的分类（对于回归问题来说，是数值）都乘以与测试点之间距离的成反比的权重。另一种克服偏斜的方式是通过数据表示形式的抽象。例如，在自组织映射（SOM）中，每个节点是相似的点的一个集群的代表（中心），而与它们在原始训练数据的密度无关。K-NN可以应用到SOM中。\n\n参数选择\n如何选择一个最佳的K值取决于数据。一般情况下，在分类时较大的K值能够减小雜訊的影响，  但会使类别之间的界限变得模糊。一个较好的K值能通过各种启发式技术（见超参数优化）来获取。\n噪声和非相关性特征的存在，或特徵尺度与它们的重要性不一致会使K近邻算法的准确性严重降低。对于选取和缩放特征来改善分类已经作了很多研究。一个普遍的做法是利用进化算法优化功能扩展，还有一种较普遍的方法是利用训练样本的互信息进行选择特征。\n在二元（两类）分类问题中，选取k为奇数有助于避免两个分类平票的情形。在此问题下，选取最佳经验k值的方法是自助法。\n\n加权最近邻分类器\nk- 最近邻分类器可以被视为为 k最近邻居分配权重\n  \n    \n      \n        1\n        \n          /\n        \n        k\n      \n    \n    {\\displaystyle 1/k}\n  \n以及为所有其他邻居分配 0权重。这可以推广到加权最近邻分类器。也就是说，第 i近的邻居被赋予权重\n  \n    \n      \n        \n          w\n          \n            n\n            i\n          \n        \n      \n    \n    {\\displaystyle w_{ni}}\n  \n，其中\n  \n    \n      \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          w\n          \n            n\n            i\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle \\sum _{i=1}^{n}w_{ni}=1}\n  \n。关于加权最近邻分类器的强一致性的类似结果也成立。 \n设\n  \n    \n      \n        \n          C\n          \n            n\n          \n          \n            w\n            n\n            n\n          \n        \n      \n    \n    {\\displaystyle C_{n}^{wnn}}\n  \n表示权重为\n  \n    \n      \n        {\n        \n          w\n          \n            n\n            i\n          \n        \n        \n          }\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\{w_{ni}\\}_{i=1}^{n}}\n  \n的加权最近邻分类器。根据类别分布的规律性条件，超额风险具有以下渐近展开\n\n  \n    \n      \n        \n          \n            \n              R\n            \n          \n          \n            \n              R\n            \n          \n        \n        (\n        \n          C\n          \n            n\n          \n          \n            w\n            n\n            n\n          \n        \n        )\n        −\n        \n          \n            \n              R\n            \n          \n          \n            \n              R\n            \n          \n        \n        (\n        \n          C\n          \n            B\n            a\n            y\n            e\n            s\n          \n        \n        )\n        =\n        \n          (\n          \n            \n              B\n              \n                1\n              \n            \n            \n              s\n              \n                n\n              \n              \n                2\n              \n            \n            +\n            \n              B\n              \n                2\n              \n            \n            \n              t\n              \n                n\n              \n              \n                2\n              \n            \n          \n          )\n        \n        {\n        1\n        +\n        o\n        (\n        1\n        )\n        }\n        ,\n      \n    \n    {\\displaystyle {\\mathcal {R}}_{\\mathcal {R}}(C_{n}^{wnn})-{\\mathcal {R}}_{\\mathcal {R}}(C^{Bayes})=\\left(B_{1}s_{n}^{2}+B_{2}t_{n}^{2}\\right)\\{1+o(1)\\},}\n  \n\n对常数 \n  \n    \n      \n        \n          B\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle B_{1}}\n  \n and \n  \n    \n      \n        \n          B\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle B_{2}}\n  \n 当 \n  \n    \n      \n        \n          s\n          \n            n\n          \n          \n            2\n          \n        \n        =\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          w\n          \n            n\n            i\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle s_{n}^{2}=\\sum _{i=1}^{n}w_{ni}^{2}}\n  \n 并且 \n  \n    \n      \n        \n          t\n          \n            n\n          \n        \n        =\n        \n          n\n          \n            −\n            2\n            \n              /\n            \n            d\n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          w\n          \n            n\n            i\n          \n        \n        {\n        \n          i\n          \n            1\n            +\n            2\n            \n              /\n            \n            d\n          \n        \n        −\n        (\n        i\n        −\n        1\n        \n          )\n          \n            1\n            +\n            2\n            \n              /\n            \n            d\n          \n        \n        }\n      \n    \n    {\\displaystyle t_{n}=n^{-2/d}\\sum _{i=1}^{n}w_{ni}\\{i^{1+2/d}-(i-1)^{1+2/d}\\}}\n  \n。\n最佳加权方案\n  \n    \n      \n        {\n        \n          w\n          \n            n\n            i\n          \n          \n            ∗\n          \n        \n        \n          }\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\{w_{ni}^{*}\\}_{i=1}^{n}}\n  \n用于平衡上面显示中的两个项，如下所示：令 \n  \n    \n      \n        \n          k\n          \n            ∗\n          \n        \n        =\n        ⌊\n        B\n        \n          n\n          \n            \n              4\n              \n                d\n                +\n                4\n              \n            \n          \n        \n        ⌋\n      \n    \n    {\\displaystyle k^{*}=\\lfloor Bn^{\\frac {4}{d+4}}\\rfloor }\n  \n，\n\n  \n    \n      \n        \n          w\n          \n            n\n            i\n          \n          \n            ∗\n          \n        \n        =\n        \n          \n            1\n            \n              k\n              \n                ∗\n              \n            \n          \n        \n        \n          [\n          \n            1\n            +\n            \n              \n                d\n                2\n              \n            \n            −\n            \n              \n                d\n                \n                  2\n                  \n                    \n                      \n                        k\n                        \n                          ∗\n                        \n                      \n                    \n                    \n                      2\n                      \n                        /\n                      \n                      d\n                    \n                  \n                \n              \n            \n            {\n            \n              i\n              \n                1\n                +\n                2\n                \n                  /\n                \n                d\n              \n            \n            −\n            (\n            i\n            −\n            1\n            \n              )\n              \n                1\n                +\n                2\n                \n                  /\n                \n                d\n              \n            \n            }\n          \n          ]\n        \n      \n    \n    {\\displaystyle w_{ni}^{*}={\\frac {1}{k^{*}}}\\left[1+{\\frac {d}{2}}-{\\frac {d}{2{k^{*}}^{2/d}}}\\{i^{1+2/d}-(i-1)^{1+2/d}\\}\\right]}\n  \n 对 \n  \n    \n      \n        i\n        =\n        1\n        ,\n        2\n        ,\n        …\n        ,\n        \n          k\n          \n            ∗\n          \n        \n      \n    \n    {\\displaystyle i=1,2,\\dots ,k^{*}}\n  \n 并且\n\n  \n    \n      \n        \n          w\n          \n            n\n            i\n          \n          \n            ∗\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle w_{ni}^{*}=0}\n  \n 对 \n  \n    \n      \n        i\n        =\n        \n          k\n          \n            ∗\n          \n        \n        +\n        1\n        ,\n        …\n        ,\n        n\n      \n    \n    {\\displaystyle i=k^{*}+1,\\dots ,n}\n  \n.\n利用最优权重，超额风险的渐近展开中的主项是\n  \n    \n      \n        \n          \n            O\n          \n        \n        (\n        \n          n\n          \n            −\n            \n              \n                4\n                \n                  d\n                  +\n                  4\n                \n              \n            \n          \n        \n        )\n      \n    \n    {\\displaystyle {\\mathcal {O}}(n^{-{\\frac {4}{d+4}}})}\n  \n。当使用bagged 最近邻分类器时，类似的结果也是如此。\n\n属性\n原始朴素的算法通过計算测试点到存储样本点的距离是比较容易实现的，但它属于计算密集型的，特别是当训练样本集变大时，计算量也会跟着增大。多年来，许多用来减少不必要距离评价的近邻搜索算法已经被提出来。使用一种合适的近邻搜索算法能使K近邻算法的计算变得简单许多。\n近邻算法具有较强的一致性结果。随着数据趋于无限，算法保证错误率不会超过贝叶斯算法错误率的两倍。对于一些K值，K近邻保证错误率不会超过贝叶斯的。\n\n决策边界\n近邻算法能用一种有效的方式隐含的计算决策边界。另外，它也可以显式的计算决策边界，以及有效率的这样做计算，使得计算复杂度是边界复杂度的函数。\n\n连续变量估计\nK近邻算法也适用于连续变量估计，比如适用反距离加权平均多个K近邻点确定测试点的值。该算法的功能有：\n\n从目标区域抽样计算欧式或马氏距离；\n在交叉验证后的RMSE基础上选择启发式最优的K邻域；\n计算多元k-最近邻居的距离倒数加权平均。\n\n發展\n然而k最近鄰居法因為計算量相當的大，所以相當的耗時，Ko與Seo提出一演算法TCFP（text categorization using feature projection），嘗試利用特徵投影法來降低與分類無關的特徵對於系統的影響，並藉此提昇系統效能，其實驗結果顯示其分類效果與k最近鄰居法相近，但其運算所需時間僅需k最近鄰居法運算時間的五十分之一。\n除了針對文件分類的效率，尚有研究針對如何促進k最近鄰居法在文件分類方面的效果，如Han等人於2002年嘗試利用貪心法，針對文件分類實做可調整權重的k最近鄰居法WAkNN（weighted adjusted k nearest neighbor），以促進分類效果；而Li等人於2004年提出由於不同分類的文件本身有數量上有差異，因此也應該依照訓練集合中各種分類的文件數量，選取不同數目的最近鄰居，來參與分類。\n\n参见\n注释\n參考文獻\n引用\n来源\n拓展阅读\nWhen Is \"Nearest Neighbor\" Meaningful?（页面存档备份，存于互联网档案馆）\nBelur V. Dasarathy (编). Nearest Neighbor (NN) Norms: NN Pattern Classification Techniques. 1991. ISBN 0-8186-8930-7. \nShakhnarovish, Darrell, and Indyk (编). Nearest-Neighbor Methods in Learning and Vision. MIT Press. 2005. ISBN 0-262-19547-X. \nMäkelä H Pekkarinen A. Estimation of forest stand volumes by Landsat TM imagery and stand-level field-inventory data. Forest Ecology and Management. 2004-07-26, 196 (2–3): 245–255. doi:10.1016/j.foreco.2004.02.049. \nFast k nearest neighbor search using GPU. In Proceedings of the CVPR Workshop on Computer Vision on GPU, Anchorage, Alaska, USA, June 2008. V. Garcia and E. Debreuve and M. Barlaud.\nScholarpedia article on k-NN （页面存档备份，存于互联网档案馆）\ngoogle-all-pairs-similarity-search （页面存档备份，存于互联网档案馆）"}
{"title": "哈希表", "text": "散列表（英語：Hash table）是根据键而直接访问在記憶體儲存位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来讓人访问，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。\n一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n到首字母\n  \n    \n      \n        F\n        (\n        x\n        )\n      \n    \n    {\\displaystyle F(x)}\n  \n的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则\n  \n    \n      \n        F\n        (\n        )\n      \n    \n    {\\displaystyle F()}\n  \n，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。\n\n基本概念\n若关键字为\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n，则其值存放在\n  \n    \n      \n        f\n        (\n        k\n        )\n      \n    \n    {\\displaystyle f(k)}\n  \n的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系\n  \n    \n      \n        f\n      \n    \n    {\\displaystyle f}\n  \n为散列函数，按这个思想建立的表为散列表。\n对不同的关键字可能得到同一散列地址，即\n  \n    \n      \n        \n          k\n          \n            1\n          \n        \n        ≠\n        \n          k\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle k_{1}\\neq k_{2}}\n  \n，而\n  \n    \n      \n        f\n        (\n        \n          k\n          \n            1\n          \n        \n        )\n        =\n        f\n        (\n        \n          k\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle f(k_{1})=f(k_{2})}\n  \n，这种现象称为冲突（英語：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数\n  \n    \n      \n        f\n        (\n        k\n        )\n      \n    \n    {\\displaystyle f(k)}\n  \n和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。\n若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。\n\n构造散列函数\n散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。\n\n直接定址法：取关键字或关键字的某个线性函数值为散列地址。即\n  \n    \n      \n        h\n        a\n        s\n        h\n        (\n        k\n        )\n        =\n        k\n      \n    \n    {\\displaystyle hash(k)=k}\n  \n或\n  \n    \n      \n        h\n        a\n        s\n        h\n        (\n        k\n        )\n        =\n        a\n        ⋅\n        k\n        +\n        b\n      \n    \n    {\\displaystyle hash(k)=a\\cdot k+b}\n  \n，其中\n  \n    \n      \n        a\n        \n        b\n      \n    \n    {\\displaystyle a\\,b}\n  \n为常数（这种散列函数叫做自身函数）\n数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。\n平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。\n折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。\n随机数法\n除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即\n  \n    \n      \n        h\n        a\n        s\n        h\n        (\n        k\n        )\n        =\n        k\n        \n        \n          mod\n          \n            \n          \n        \n        p\n      \n    \n    {\\displaystyle hash(k)=k\\,{\\bmod {\\,}}p}\n  \n, \n  \n    \n      \n        p\n        ≤\n        m\n      \n    \n    {\\displaystyle p\\leq m}\n  \n。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。\n\n处理冲突\n为了知道冲突产生的相同散列函数地址所对应的关键字，必须选用另外的散列函数，或者对冲突结果进行处理。而不发生冲突的可能性是非常之小的，所以通常对冲突进行处理。常用方法有以下几种：\n\n开放定址法（open addressing）：\n  \n    \n      \n        h\n        a\n        s\n        \n          h\n          \n            i\n          \n        \n        =\n        (\n        h\n        a\n        s\n        h\n        (\n        k\n        e\n        y\n        )\n        +\n        \n          d\n          \n            i\n          \n        \n        )\n        \n        \n          mod\n          \n            \n          \n        \n        m\n      \n    \n    {\\displaystyle hash_{i}=(hash(key)+d_{i})\\,{\\bmod {\\,}}m}\n  \n, \n  \n    \n      \n        i\n        =\n        1\n        ,\n        2...\n        k\n        \n        (\n        k\n        ≤\n        m\n        −\n        1\n        )\n      \n    \n    {\\displaystyle i=1,2...k\\,(k\\leq m-1)}\n  \n，其中\n  \n    \n      \n        h\n        a\n        s\n        h\n        (\n        k\n        e\n        y\n        )\n      \n    \n    {\\displaystyle hash(key)}\n  \n为散列函数，\n  \n    \n      \n        m\n      \n    \n    {\\displaystyle m}\n  \n为散列表长，\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle d_{i}}\n  \n为增量序列，\n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n为已发生冲突的次数。增量序列可有下列取法：\n\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n        1\n        ,\n        2\n        ,\n        3...\n        (\n        m\n        −\n        1\n        )\n      \n    \n    {\\displaystyle d_{i}=1,2,3...(m-1)}\n  \n称为线性探测（Linear Probing）；即\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n        i\n      \n    \n    {\\displaystyle d_{i}=i}\n  \n，或者为其他线性函数。相当于逐个探测存放地址的表，直到查找到一个空单元，把散列地址存放在该空单元。\n\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n        ±\n        \n          1\n          \n            2\n          \n        \n        ,\n        ±\n        \n          2\n          \n            2\n          \n        \n        ,\n        ±\n        \n          3\n          \n            2\n          \n        \n        .\n        .\n        .\n        ±\n        \n          k\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle d_{i}=\\pm 1^{2},\\pm 2^{2},\\pm 3^{2}...\\pm k^{2}}\n  \n \n  \n    \n      \n        (\n        k\n        ≤\n        m\n        \n          /\n        \n        2\n        )\n      \n    \n    {\\displaystyle (k\\leq m/2)}\n  \n称为 平方探测(Quadratic Probing)。相对线性探测，相当于发生冲突时探测间隔\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n        \n          i\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle d_{i}=i^{2}}\n  \n个单元的位置是否为空，如果为空，将地址存放进去。\n\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n      \n    \n    {\\displaystyle d_{i}=}\n  \n伪随机数序列，称为 伪随机探测。\n显示线性探测填装一个散列表的过程：\n\n关键字为{89,18,49,58,69}插入到一个散列表中的情况。此时线性探测的方法是取\n  \n    \n      \n        \n          d\n          \n            i\n          \n        \n        =\n        i\n      \n    \n    {\\displaystyle d_{i}=i}\n  \n。并假定取关键字除以10的余数为散列函数法则。\n\n第一次冲突发生在填装49的时候。地址为9的单元已经填装了89这个关键字，所以取\n  \n    \n      \n        i\n        =\n        1\n      \n    \n    {\\displaystyle i=1}\n  \n，往下查找一个单位，发现为空，所以将49填装在地址为0的空单元。第二次冲突则发生在58上，取\n  \n    \n      \n        i\n        =\n        3\n      \n    \n    {\\displaystyle i=3}\n  \n，往下查找3个单位，将58填装在地址为1的空单元。69同理。\n表的大小选取至关重要，此处选取10作为大小，发生冲突的几率就比选择质数11作为大小的可能性大。越是质数，mod取余就越可能均匀分布在表的各处。\n聚集（Cluster，也翻译做“堆积”）的意思是，在函数地址的表中，散列函数的结果不均匀地占据表的单元，形成区块，造成线性探测产生一次聚集（primary clustering）和平方探测的二次聚集（secondary clustering），散列到区块中的任何关键字需要查找多次试选单元才能插入表中，解决冲突，造成时间浪费。对于开放定址法，聚集会造成性能的灾难性损失，是必须避免的。\n\n单独链表法：将散列到同一个存储位置的所有元素保存在一个链表中。实现时，一种策略是散列表同一位置的所有冲突结果都是用栈存放的，新元素被插入到表的前端还是后端完全取决于怎样方便。\n双散列。\n再散列：\n  \n    \n      \n        h\n        a\n        s\n        \n          h\n          \n            i\n          \n        \n        =\n        h\n        a\n        s\n        \n          h\n          \n            i\n          \n        \n        (\n        k\n        e\n        y\n        )\n      \n    \n    {\\displaystyle hash_{i}=hash_{i}(key)}\n  \n, \n  \n    \n      \n        i\n        =\n        1\n        ,\n        2...\n        k\n      \n    \n    {\\displaystyle i=1,2...k}\n  \n。\n  \n    \n      \n        h\n        a\n        s\n        \n          h\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle hash_{i}}\n  \n是一些散列函数。即在上次散列计算发生冲突时，利用该次冲突的散列函数地址产生新的散列函数地址，直到冲突不再发生。这种方法不易产生“聚集”（Cluster），但增加了计算时间。\n建立一个公共溢出区。\n\n例程\n在C语言中，实现以上过程的简要程序：\n\n开放定址法：\n\n查找空单元并插入：\n\n分離連接法\n\n查找效率\n散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。\n查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：\n\n散列函数是否均匀；\n处理冲突的方法；\n散列表的载荷因子（英語：load factor）。\n\n载荷因子\n散列表的载荷因子定义为：\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n = 填入表中的元素个数 / 散列表的长度\n\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n是散列表装满程度的标志因子。由于表长是定值，\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n与“填入表中的元素个数”成正比，所以，\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n越大，表明填入表中的元素越多，产生冲突的可能性就越大；反之，\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n越小，标明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子\n  \n    \n      \n        α\n      \n    \n    {\\displaystyle \\alpha }\n  \n的函数，只是不同处理冲突的方法有不同的函数。\n对于开放定址法，荷载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升。因此，一些采用开放定址法的hash库，如Java的系统库限制了荷载因子为0.75，超过此值将resize散列表。\n\n举例：Linux内核的bcache\nLinux操作系统在物理文件系统与块设备驱动程序之间引入了“缓冲区缓存”（Buffer\nCache，简称bcache）。当读写磁盘文件的数据，实际上都是对bcache操作，这大大提高了读写数据的速度。如果要读写的磁盘数据不在bcache中，即缓存不命中（miss），则把相应数据从磁盘加载到bcache中。一个缓存数据大小是与文件系统上一个逻辑块的大小相对应的（例如1KiB字节），在bcache中每个缓存数据块用struct buffer_head记载其元信息：\n\n整个bcache以struct buffer_head为基本数据单元，组织为一个封闭定址（close addressing，即“单独链表法”解决冲突）的散列表struct buffer_head * hash_table[NR_HASH];  散列函数的输入关键字是b_blocknr（逻辑块号）与b_dev（设备号）。计算hash值的散列函数表达式为：\n\n(b_dev ^ b_blocknr) % NR_HASH\n其中NR_HASH是散列表的条目总数。发生“ 冲突”的struct buffer_head，以b_prev与b_next指针组成一个双向（不循环）链表。bcache中所有的struct buffer_head，包括使用中不空闲与未使用空闲的struct buffer_head，以b_prev_free和b_next_free指针组成一个双向循环链表free_list，其中未使用空闲的struct buffer_head放在该链表的前部。\n\n\n== 参考文献 =="}
{"title": "AVL树", "text": "AVL树（英語：Adelson-Velsky and Landis tree）是计算机科学中最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的時間複雜度都是 \n  \n    \n      \n        O\n        (\n        log\n        ⁡\n        \n          n\n        \n        )\n      \n    \n    {\\displaystyle O(\\log {n})}\n  \n。增加和删除元素的操作则可能需要藉由一次或多次树旋转，以实现树的重新平衡。AVL树得名于它的发明者格奥尔吉·阿杰尔松-韦利斯基和葉夫根尼·蘭迪斯，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。\n节点的平衡因子是它的左子树的高度减去它的右子树的高度（有時相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。\n\n操作\nAVL树的基本操作一般涉及运作同在不平衡的二叉查找树所运作的同样的算法。但是要进行预先或随后做一次或多次所谓的\"AVL旋转\"。\n以下图表以四列表示四种情况，每行表示在该种情况下要进行的操作。在左左和右右的情况下，只需要进行一次旋转操作；在左右和右左的情况下，需要进行两次旋转操作。\n\n删除\n从AVL树中删除，可以通过把要删除的节点向下旋转成一个葉子節點，接着直接移除这个叶子节点来完成。因为在旋转成葉子節點期间最多有log n个节点被旋转，而每次AVL旋转耗费固定的时间，所以删除处理在整体上耗费O(log n) 时间。\n\n搜尋\n可以像普通二叉查找树一样的进行，所以耗费O(log n)时间，因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查找而改变。（这是与伸展樹搜尋相对立的，它会因为搜尋而变更树结构。）\n\n实现描述\n假設平衡因子是左子樹的高度減去右子樹的高度所得到的值，又假设由于在二叉排序树上插入节点而失去平衡的最小子树根节点的指针为a（即a是离插入点最近，且平衡因子绝对值超过1的祖先节点），则失去平衡后进行的规律可归纳为下列四种情况：\n\n单向右旋平衡处理LL：由于在*a的左子树根节点的左子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作；\n单向左旋平衡处理RR：由于在*a的右子树根节点的右子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作；\n双向旋转（先左后右）平衡处理LR：由于在*a的左子树根节点的右子树上插入节点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。\n双向旋转（先右后左）平衡处理RL：由于在*a的右子树根节点的左子树上插入节点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。\n在平衡的二叉排序树BBST (Balancing Binary Search Tree)上插入一个新的数据元素e的递归算法可描述如下：\n\n若BBST为空树，则插入一个数据元素为e的新节点作为BBST的根节点，树的深度增1；\n若e的关键字和BBST的根节点的关键字相等，则不进行；\n若e的关键字小于BBST的根节点的关键字，而且在BBST的左子树中不存在和e有相同关键字的节点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：\nBBST的根节点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根节点的平衡因子更改为0，BBST的深度不变；\nBBST的根节点的平衡因子为0（左、右子树的深度相等）：则将根节点的平衡因子更改为1，BBST的深度增1；\nBBST的根节点的平衡因子为1（左子树的深度大于右子树的深度）：则若BBST的左子树根节点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根节点和其右子树根节点的平衡因子更改为0，树的深度不变；\n若e的关键字大于BBST的根节点的关键字，而且在BBST的右子树中不存在和e有相同关键字的节点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。\nAVL树的调平（Erlang的实现）\n\nAVL節點數計算\n高度為h的AVL樹，總節點數N最多\n  \n    \n      \n        \n          2\n          \n            h\n            +\n            1\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{h+1}-1}\n  \n； \n最少節點數\n  \n    \n      \n        \n          N\n          \n            h\n          \n        \n      \n    \n    {\\displaystyle N_{h}}\n  \n如以斐波那契數列可以用數學歸納法證明：\n\n  \n    \n      \n        \n          N\n          \n            h\n          \n        \n      \n    \n    {\\displaystyle N_{h}}\n  \n = \n  \n    \n      \n        \n          F\n          \n            h\n            +\n            2\n          \n        \n      \n    \n    {\\displaystyle F_{h+2}}\n  \n - 1 (\n  \n    \n      \n        \n          F\n          \n            h\n            +\n            2\n          \n        \n      \n    \n    {\\displaystyle F_{h+2}}\n  \n是斐波那契数列的第h+2项，根据斐波那契多项式得来)。\n即:\n\n  \n    \n      \n        \n          N\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle N_{0}}\n  \n = 0  (表示AVL Tree高度為0的節點總數)\n\n  \n    \n      \n        \n          N\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle N_{1}}\n  \n = 1  (表示AVL Tree高度為1的節點總數)\n\n  \n    \n      \n        \n          N\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle N_{2}}\n  \n = 2  (表示AVL Tree高度為2的節點總數)\n\n  \n    \n      \n        \n          N\n          \n            h\n          \n        \n      \n    \n    {\\displaystyle N_{h}}\n  \n = \n  \n    \n      \n        \n          N\n          \n            h\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle N_{h-1}}\n  \n + \n  \n    \n      \n        \n          N\n          \n            h\n            −\n            2\n          \n        \n      \n    \n    {\\displaystyle N_{h-2}}\n  \n + 1   (表示AVL Tree高度為h的節點總數)\n換句話說，當節點數為N時，高度h最多為\n  \n    \n      \n        l\n        o\n        \n          g\n          \n            Φ\n          \n        \n        (\n        \n          \n            5\n          \n        \n        ∗\n        (\n        N\n        +\n        1\n        )\n        )\n        −\n        2\n      \n    \n    {\\displaystyle log_{\\Phi }({\\sqrt {5}}*(N+1))-2}\n  \n。\n\n参见\n樹旋轉\n伸展樹\n紅黑樹\nB樹\n\n引用\nG. Adelson-Velskii and E.M. Landis, \"An algorithm for the organization of information.\" Doklady Akademii Nauk SSSR, 146:263–266, 1962（Russian）. English translation by Myron J. Ricci in Soviet Math. Doklady, 3:1259–1263, 1962.\n\n外部链接\nDescription from the Dictionary of Algorithms and Data Structures（页面存档备份，存于互联网档案馆）\nAVL Tree Traversal（页面存档备份，存于互联网档案馆）\nLinked AVL tree\nC++ AVL Tree Template and C AVL TREE \"Generic Package\" by Walt Karas\nA Visual Basic AVL Tree Container Class（页面存档备份，存于互联网档案馆） by Jim Harris\nAVL Trees: Tutorial and C++ Implementation（页面存档备份，存于互联网档案馆） by Brad Appleton\nUlm's Oberon Library: AVLTrees（页面存档备份，存于互联网档案馆）\nThe AVL TREE Data Type\nCNAVLTree Class Reference\nGNU libavl（页面存档备份，存于互联网档案馆）\nAVL-trees - balanced binary trees by Alex Konshin\nSimulation of AVL Trees\nAVL tree applet（页面存档备份，存于互联网档案馆）\nSimulation of AVL Trees (DYNAMIC)\nAVL, Splay and Red/Black Applet\nData Structures and Algorithm Analysis in C (2nd edition) （页面存档备份，存于互联网档案馆）"}
{"title": "B树", "text": "B树（英語：B-tree），是一种在计算机科学自平衡的树，能够高效的存储与访问键值对数据，但要求键数据类型上存在一全序。這種資料結構能够在對數時間內完成查找數據、插入數據及刪除的操作，与此同时还可以提供对数据的有序遍历。B树，概括来说是一个一般化的二元搜尋樹，而每個節點可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快存取速度。由于B树允许存在超过2个子节点，其单个节点的大小较大，因此具有良好的缓存友好性，常被用来组织处于外部存储上，读写操作开销较大的数据结构，如数据库和文件系统等。但近来随CPU的高速缓存逐渐增大，即使是对于处于内存中的数据解构，缓存友好性也变得日渐重要，因此一些软件也开始选择用B树来替代传统的红黑树等理论上更高效但缓存友好性较差的数据结构。\n\n概述\n在B树中，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）。当数据被插入或从一个节点中移除，它的子节点数量发生变化。为了维持在预先设定的数量范围内，内部节点可能会被合并或者分离。因为子节点数量有一定的允许范围，所以B树不需要像其他自平衡查找树那样频繁地重新保持平衡，但是由于节点没有被完全填充，可能浪费了一些空间。子节点数量的上界和下界依特定的实现而设置。例如，在一个2-3 B树（通常简称2-3树），每一个内部节点只能有2或3个子节点。\nB树中每一个内部节点会包含一定数量的键，键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键： a1 和 a2 。左边子树的所有值都必须小于 a1 ，中间子树的所有值都必须在 a1 和a2 之间，右边子树的所有值都必须大于 a2 。\n通常，键的数量被选定在 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n 和 \n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n 之间。其中 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n 是键的最小数量，\n  \n    \n      \n        d\n        +\n        1\n      \n    \n    {\\displaystyle d+1}\n  \n 是树最小的度或分支因子。在实际中，键值占用了节点中大部分的空间。因数2将保证节点可以被拆分或组合。如果一个内部节点有 \n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n 个键，那么要添加一个键值给此节点，只需要拆分这 \n  \n    \n      \n        2\n        d\n        +\n        1\n      \n    \n    {\\displaystyle 2d+1}\n  \n 个键为2个 拥有 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n 个键的节点，并把中间值节点移动到父节点。每一个拆分的节点需要拥有足够数目的键。相似地，如果一个内部节点和他的邻居两者都有 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n 个键，那么将通过它与邻居的合并来删除一个键。删除此键将导致此节点拥有 \n  \n    \n      \n        d\n        −\n        1\n      \n    \n    {\\displaystyle d-1}\n  \n 个键;与邻居的合并则加上 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n 个键，再加上从邻居节点的父节点移来的一个键值。结果为完全填充的 \n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n 个键。\n一个节点的分支（或子节点）的数量会比存储在节点内部键值的数量大1。在 2-3 B树中，内部节点将会存储1个键值（带有2个子节点）或2个键值（带有3个子节点）。一个B树有时会被描述为 \n  \n    \n      \n        (\n        d\n        +\n        1\n        )\n        −\n        (\n        2\n        d\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (d+1)-(2d+1)}\n  \n 或简单地使用最高分支 \n  \n    \n      \n        (\n        2\n        d\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (2d+1)}\n  \n 。\n一个Ｂ树通过约束所有叶子节点在相同深度来保持平衡。深度在元素添加至树的过程中缓慢增长，而整体深度极少地增长，并导致所有叶子节点与根节点距离加1。\n在存取节点数据所耗时间远超过处理节点数据所耗时间的情况下，Ｂ树在可选的实现中拥有很多优势，因为存取节点的开销被分摊到里层节点的多次操作上。这通常出现在当节点存储在二级存储器如硬盘存储器上。通过最大化内部里层节点的子节点的数量，树的高度减小，存取节点的开销被缩减。另外，重新平衡树的动作也更少出现。子节点的最大数量取决于，每个子节点必需存储的信息量，和完整磁盘块的大小或者二次存储器中类似的容量。虽然 2-3 树更易于解释，实际运用中，Ｂ树使用二级存储器，需要大量数目的子节点来提升效率。\n\n变体\n术语B树可以指一个特定的方案，也可以指大体上一类方案。狭义上，一个Ｂ树在它内部节点中存储键值，但不需在叶子节点上存储这些键值的记录。大体上的一类包含一些变体，如B+树和B*树。\n在B+树，这些键值的拷贝被存储在内部节点；键值和记录存储在叶子节点；另外，一个叶子节点可以包含一个指针，指向另一个叶子节点以加速顺序存取。\nB*树分支出更多的内部邻居节点以保持内部节点更密集地填充。此变体要求非根节点至少2/3填充，而不是1/2。为了维持这样的结构，当一个节点填满之后将不会再立即分割节点，而是将它的键值与下一个节点共享。当两个节点都填满之后，分割成3个节点。\n计数B树存储，每一树都带有一个指针和其指向子树的节点数目。这就允许了以键值为序快速查找第N笔记录，或是统计2笔记录之间的记录数目，还有其他很多相关的操作。\n\n名字取义\n魯道夫·拜爾和愛德華·M·麥克萊特于1972年在波音研究實驗室（Boeing Research Labs）工作时发明了B树，但是他们没有解释B代表什么意义（如果有的话）。道格拉斯·科默爾解释说：「两位作者从来都没解释过B树的原始意义。正如我们所见，“balanced”、“broad”或“bushy”可能适合。其他人建议字母“B”代表Boeing。源自于他的赞助，不过，看起来把B树当作“Bayer”树更合适些。」\n高德納在他1980年5月发表的题为“CS144C classroom lecture about disk storage and B-trees”的论文中推测了B树的名字取义，提出“B”可能意味Boeing或者Bayer的名字。\n\n数据库的问题\n已排序文件的查找时间\n通常，排序和查找算法会被通过大O符号，刻画为比较级别的数值。对一个有N笔记录的已排序表进行二叉查找，打个比方说，可以在O（log2N）比较级完成。如果表有1,000,000笔记录,那么定位其中一笔记录，将在20个比较级内完成。\nlog2(1,000,000) = 19.931...\n大数据库一直以来被存储在磁盘。从磁盘上读取一笔记录，与之后的比较键值操作相比，在花费的运行时间上前者处于支配地位。从磁盘读取记录的时间涉及到一个 寻道时间 和 旋转延迟。寻道时间可能是从0到20或者更多毫秒，旋转延迟平均下来约是旋转周期的一半。对于一个7,200转每分钟的磁盘，旋转周期大约是8.33毫秒。像希捷ST3500320NS这样的磁盘,磁道至磁道的寻道时间为 0.8毫秒，平均读取寻道时间为8.5毫秒。为了简化，假设从磁盘读取花费10毫秒。\n乐观来说，如此，在一百万中定位一笔记录将会话花费20次磁盘读取乘上10毫秒每次读取时间，总共是0.2秒。\n时间花费没有那么糟糕的原因是，独立的记录被成组地记录在磁盘块上。一个磁盘块可能为16 千字节。如果每笔记录大小为160 字节，那么一个块可以存储100 笔记录。上面假设的磁盘读取时间确切地说是读取一个完整块的时间。一旦磁头到达位置，一个或者更多的磁盘块可以以较小的延迟来完成读取。对于100笔记录每块，最后差不多6个比较级是不需要任何磁盘读取的——都在上次读取操作中完成了。\n为进一步加速查找，开始的13或14个比较级（每个需要一次磁盘访问）必须要提速。\n\n提升查找的索引\n较大程度上的提升是通过索引来做到的。在上面的例子中，初始磁盘读取从2个因素限制了查找范围。这基本上可以通过创建一个辅助索引来改善，这个索引包含每块磁盘块上的首笔记录（有时称为稀疏索引）。这个辅助索引可能只有原始数据库的1%大小，但是它可以更快速地被检索。在辅助索引中查找入口可以告诉我们在主数据库中要读取哪一块;查找辅助索引之后，我们只需要读取主数据库中的特定的某一个磁盘分块——通过一次磁盘读取开销。索引可以提供10,000入口，所以，这样最多需要14个比较级。就像主数据库，辅助索引中最后6个左右的比较级可能在相同的磁盘分块上。索引可以在大约8次磁盘读取中完成查找，目标记录会在9次磁盘读取后获得。\n创建辅助索引的窍门是可以重复地给辅助索引创建辅助索引。那样可以实现一个只拥有100 入口，能填满一整个磁盘块的辅助-辅助索引。\n要找到想要的记录，我们只需要读取3次磁盘分块，而不是14次。读取和查找辅助-辅助索引中第一个（而且是唯一的）块，标记了相应的辅助索引中的分块。读取和查找辅助索引的分块，标记了主数据库中相应的分块。我们只需要30毫秒，而不是150毫秒就能获取记录。\n辅助的索引，使得查找问题从约为log2N 磁盘读取开销的二分查找，变成logbN 磁盘读取开销的查找，其中b为分块因素（每分块的入口数目：b = 100 入口每分块;logb1,000,000 = 3 次读取）。\n在实际中，如果主数据库被频繁查找，辅助-辅助索引和大部分的辅助索引可能会存储在磁盘缓存中，所以它们不会产生磁盘读取。\n\n插入和删除带来的麻烦\n如果数据库不会改变，那么编制索引就很简单，而且索引永远不需要改变。如果他们会改变，那么管理数据库及其索引就变得非常麻烦。\n从数据库中删除记录不会引起太大问题。索引可以保持不变，记录只需要标记为已删除。数据库仍然保持有序状态。如果会有很多删除，之后查找和存储就不再那么高效了。\n在一个有序文件中进行插入将是个灾难，因为需要给插入的记录制造空间。在文件中第一笔记录后插入记录需要把所有记录向后偏移一个位置。如此的操作在实际中实在太过昂贵。\n一种做法是预留一些空间给插入操作。磁盘块有一些空闲空间允许后来的插入，而不是高密度地填充。这些记录可以被标记为像是已删除的记录。\n现在，只要块中存在空间，插入和删除都可以很快速。如果一个插入操作在一个块上找不到合适的空间，就在临近的块中寻找，且要调整辅助索引。期望是临近存在足够的空间，以免重新调整大量的块。作为可选方案，可以使用一些非排序的块。\n\nB树运用的理念\nB树使用了以上所有的想法。特别是：\n\n保持键值有序，以顺序遍历\n使用层次化的索引来最小化磁盘读取\n使用不完全填充的块来加速插入和删除\n通过优雅的遍历算法来保持索引平衡\n另外，B树通过保证内部节点至少半满来最小化空间浪费。一棵B树可以处理任意数目的插入和删除。\n\nB树的弊端\n除非完全重建数据库，否则无法改变键值的最大长度。这使得许多数据库系统将人名截断到70字符之内。\n（其他关联数组的实现，例如三元搜索树或者开哈希表，可以动态适应任意长度的键值）。\n\n术语和定义\n术语\n文献中B树的术语并不统一 (Folk & Zoellick 1992，第362頁)。\nBayer & McCreight (1972)，Comer (1979)等人将B树的 阶 定义为非根节点拥有键的最小数量。Folk & Zoellick (1992) 指出这一术语是模糊不清的。一个 3 阶B树键的最大数量可能为 6 或 7。 Knuth (1998，第483頁) 通过将 阶 定义为最大数量的子节点（比最大数量的键大1）来避免这一问题。\n术语 叶子 的定义也不一致。 Bayer & McCreight (1972) 认为叶子层是最下面一层的键，但是 Knuth 认为叶子层是最下面一层键之下的一层 (Folk & Zoellick 1992，第363頁)。可能的实现有许多。在一些设计中，叶子可能保存了完整的数据记录；在另一些设计中，叶子可能只保存了指向数据记录的指针。\n为了简化，许多作者假定一个节点能够容纳固定数量的键。基础的假设是键和节点的大小都是固定的。事实上，可变长度的键可能会被使用 (Folk & Zoellick 1992，第379頁)。\n\n定义\n根据 Knuth 的定义，一个 m 阶的B树是一个有以下属性的树：\n\n每一个节点最多有 m 个子节点\n每一个非叶子节点（除根节点）最少有 ⌈m/2⌉ 个子节点\n如果根节点不是叶子节点，那么它至少有两个子节点\n有 k 个子节点的非叶子节点拥有 k − 1 个键\n所有的叶子节点都在同一层\n每一个内部节点的键将节点的子树分开。例如，如果一个内部节点有3个子节点（子树），那么它就必须有两个键： a1 和 a2 。左边子树的所有值都必须小于 a1 ，中间子树的所有值都必须在 a1 和a2 之间，右边子树的所有值都必须大于 a2 。\n\n内部节点\n内部节点是除叶子节点和根节点之外的所有节点。它们通常被表示为一组有序的元素和指向子节点的指针。每一个内部节点拥有最多 U 个，最少 L 个子节点。元素的数量总是比子节点指针的数量少一（元素的数量在 L-1 和 U-1 之间）。U 必须等于 2L 或者 2L-1;因此，每一个内部节点都至少是半满的。U 和 L 之间的关系意味着两个半满的节点可以合并成一个合法的节点，一个全满的节点可以被分裂成两个合法的节点（如果父节点有空间容纳移来的一个元素）。这些特性使得在B树中删除或插入新的值时可以调整树来保持B树的性质。\n根节点\n根节点拥有的子节点数量的上限和内部节点相同，但是没有下限。例如，当整个树中的元素数量小于 L-1 时，根节点是唯一的节点并且没有任何子节点。\n叶子节点\n叶子节点对元素的数量有相同的限制，但是没有子节点，也没有指向子节点的指针。\n一个深度为n+1 的B树可以容纳的元素数量大约是深度为 n 的B树的 U 倍，但是搜索、插入和删除操作的开销也会增加。和其他的平衡树一样，这一开销增加的速度远远慢于元素数量的增加。\n一些平衡树只在叶子节点中存储值，而且叶子节点和内部节点使用不同的结构。B树在每一个节点中都存储值，所有的节点有着相同的结构。然而，因为叶子节点没有子节点，所以可以通过使用专门的结构来提高B树的性能。\n\n非形式的描述\nB树的内部非叶节点的子节点的数量要保持在一定范围。当在这个节点上插入或删除值，它的子节点可以合并或者分裂，以便该节点的子节点的数量继续保持在一定范围内。从而， B树不需要像其他二叉搜索树那样需要频繁地再平衡操作，但可能会浪费一些空间，因为节点未必是满的。非叶节点的子节点的数量一般实现时取固定值。例如，2-3树的内部节点可以有2或3个子节点。\n通常，内部节点的键值的数量在\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n到\n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n之间变化，其中\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n是键值的最少数量，\n  \n    \n      \n        d\n        +\n        1\n      \n    \n    {\\displaystyle d+1}\n  \n是树的最小出度或分支因子。系数2保证了这个节点可以分割或合并。如果内部节点有\n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n个键值，那么再增加一个键值需要把该节点分为2个包含\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n个键值的节点和1个增加到父节点的分隔键值。如果一个内部节点和它的相邻兄弟节点都有\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n个键值，那么从该节点删除一个键值需要合并它与相邻兄弟节点及父节点中的分隔键值，结果为一个具有\n  \n    \n      \n        2\n        d\n      \n    \n    {\\displaystyle 2d}\n  \n个键值的满节点，及父节点删除一个键值操作。\n一颗B树有时被称为\n  \n    \n      \n        (\n        d\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (d+1)}\n  \n—\n  \n    \n      \n        (\n        2\n        d\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (2d+1)}\n  \n（例如2-3树）或者用最大分支秩\n  \n    \n      \n        (\n        2\n        d\n        +\n        1\n        )\n      \n    \n    {\\displaystyle (2d+1)}\n  \n。\nB树在插入操作后将分裂过满的节点，以保持平衡，即对有\n  \n    \n      \n        2\n        d\n        +\n        1\n      \n    \n    {\\displaystyle 2d+1}\n  \n个键值的节点分裂为2个\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n个键值的兄弟节点并向父节点插入一个分隔键值。仅当根节点分裂时，B树的深度会增长，以保持平衡。类似地，B-树删除操作会对少于\n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n个键值的非根节点执行和相邻兄弟节点的合并或重分布操作，以保持平衡。合并节点将导致父节点减少一个分隔操作，这导致父节点的删除操作。仅当根节点仅有2个子节点且各自包含 \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n个和\n  \n    \n      \n        d\n        −\n        1\n      \n    \n    {\\displaystyle d-1}\n  \n个键值，做合并操作时，B树的深度将减去1。\n当访问节点数据的时间大大超过处理该数据所花费的时间时，B-树比替代实现具有显着的优势，因为访问节点的成本可以分摊到节点内的多个操作上。当节点数据位于辅助存储（例如磁盘驱动器）时，通常会发生这种情况。 通过最大化每个内部节点内的键数量，树的高度会降低，并且昂贵的节点访问次数也会减少。 此外，树的重新平衡发生的频率也较低。 子节点的最大数量取决于必须为每个子节点存储的信息以及完整磁盘块的大小或辅助存储中的类似大小。 虽然2-3树更容易解释，但实际用于辅助存储的B树需要大量子节点来提高性能。\n\n变种\n术语“B树”可以指特定设计，也可以指一般类别的设计。 狭义上，B树将键存储在其内部节点中，但不需要将这些键存储在叶节点的记录中。 一般类包括诸如B+树、B*树和B*+树之类的变体。\n\n在B+树中, 键值的副本存储在内部节点中；键值和记录存储在叶节点中； 此外，叶节点可能包含指向下一个相邻叶节点的指针以加速顺序访问。\nB*树平衡更多相邻的内部节点，以保持内部节点更密集。B*树确保非根节点至少有2/3满，而不是1/2。由于在B树中插入节点的操作中成本最高的部分是分裂节点，因此创建了B*树尽可能推迟分裂操作。为了维持这一点，不是在节点满时立即拆分节点，而是与下一个节点共享其键值。这种溢出操作的成本比拆分要低，因为它只需要在现有节点之间移动键值，而不需要为新节点分配内存。\nB*+树将B+树和B*树的主要特征结合在一起。\nB树可以变成顺序统计树，可以快速查找关键顺序的第N条记录，或者统计任意两条记录之间的记录数，以及其他各种相关操作。\n\n算法\n搜索\nB树的搜索和二叉搜索树类似。从根节点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父节点的键确定。\n\n插入\n所有的插入都从根节点开始。要插入一个新的元素，首先搜索这棵树找到新元素应该被添加到的对应节点。将新元素插入到这一节点中的步骤如下：\n\n如果节点拥有的元素数量小于最大值，那么有空间容纳新的元素。将新元素插入到这一节点，且保持节点中元素有序。\n否则的话这一节点已经满了，将它平均地分裂成两个节点：\n从该节点的原有元素和新的元素中选择出中位数\n小于这一中位数的元素放入左边节点，大于这一中位数的元素放入右边节点，中位数作为分隔值。\n分隔值被插入到父节点中，这可能会造成父节点分裂，分裂父节点时可能又会使它的父节点分裂，以此类推。如果没有父节点（这一节点是根节点），就创建一个新的根节点（增加了树的高度）。\n如果分裂一直上升到根节点，那么一个新的根节点会被创建，它有一个分隔值和两个子节点。这就是根节点并不像内部节点一样有最少子节点数量限制的原因。每个节点中元素的最大数量是 U-1。当一个节点分裂时，一个元素被移动到它的父节点，但是一个新的元素增加了进来。所以最大的元素数量 U-1 必须能够被分成两个合法的节点。如果 U-1 是奇数，那么 U=2L ，总共有 2L-1 个元素，一个新的节点有 L-1 个元素，另外一个有 L 个元素，都是合法的节点。如果 U-1 是偶数，那么 U=2L-1,总共有 2L-2 个元素。 一半是 L-1，正好是节点允许的最小元素数量。\n\n删除\n有两种常用的删除策略\n\n定位并删除元素，然后调整树使它满足约束条件； 或者\n从上到下处理这棵树，在进入一个节点之前，调整树使得之后一旦遇到了要删除的键，它可以被直接删除而不需要再进行调整\n以下的算法使用了前一种策略。\n删除一个元素时有以下两种特殊情况\n\n这个元素用于分隔一个内部节点的子节点\n删除元素会导致它所在的节点的元素或子节点数量小于最低值\n下面分别是这些情况的处理过程\n\n删除叶子节点中的元素\n搜索要删除的元素\n如果它在叶子节点，将它从中删除\n如果发生了下溢出，按照后面 “删除后重新平衡”部分的描述重新调整树\n\n删除内部节点中的元素\n内部节点中的每一个元素都作为分隔两颗子树的分隔值，因此我们需要重新划分。值得注意的是左子树中最大的元素仍然小于分隔值。同样的，右子树中最小的元素仍然大于分隔值。这两个元素都在叶子节点中，并且任何一个都可以作为两颗子树的新分隔值。算法的描述如下：\n\n选择一个新的分隔符（左子树中最大的元素或右子树中最小的元素），将它从叶子节点中移除，替换掉被删除的元素作为新的分隔值。\n前一步删除了一个叶子节点中的元素。如果这个叶子节点拥有的元素数量小于最低要求，那么从这一叶子节点开始重新进行平衡。\n\n删除后的重新平衡\n重新平衡从叶子节点开始向根节点进行，直到树重新平衡。如果删除节点中的一个元素使该节点的元素数量低于最小值，那么一些元素必须被重新分配。通常，移动一个元素数量大于最小值的兄弟节点中的元素。如果兄弟节点都没有多余的元素，那么缺少元素的节点就必须要和他的兄弟节点 合并。合并可能导致父节点失去了分隔值，所以父节点可能缺少元素并需要重新平衡。合并和重新平衡可能一直进行到根节点，根节点变成惟一缺少元素的节点。重新平衡树的算法如下：\n\n如果缺少元素节点的右兄弟存在且拥有多余的元素，那么向左旋转\n将父节点的分隔值复制到缺少元素节点的最后（分隔值被移下来；缺少元素的节点现在有最小数量的元素）\n将父节点的分隔值替换为右兄弟的第一个元素（右兄弟失去了一个节点但仍然拥有最小数量的元素）\n树又重新平衡\n否则，如果缺少元素节点的左兄弟存在且拥有多余的元素，那么向右旋转\n将父节点的分隔值复制到缺少元素节点的第一个节点（分隔值被移下来；缺少元素的节点现在有最小数量的元素）\n将父节点的分隔值替换为左兄弟的最后一个元素（左兄弟失去了一个节点但仍然拥有最小数量的元素）\n树又重新平衡\n否则，如果它的两个直接兄弟节点都只有最小数量的元素，那么将它与一个直接兄弟节点以及父节点中它们的分隔值合并\n将分隔值复制到左边的节点（左边的节点可以是缺少元素的节点或者拥有最小数量元素的兄弟节点）\n将右边节点中所有的元素移动到左边节点（左边节点现在拥有最大数量的元素，右边节点为空）\n将父节点中的分隔值和空的右子树移除（父节点失去了一个元素）\n如果父节点是根节点并且没有元素了，那么释放它并且让合并之后的节点成为新的根节点（树的深度减小）\n否则，如果父节点的元素数量小于最小值，重新平衡父节点\n\n相关条目\nB+树\n\n\n== 参考文献 =="}
{"title": "二叉树", "text": "在電腦科學中，二元樹（英語：Binary tree）是每個節點最多只有兩個分支（即不存在分支度大於2的節點）的樹結構。通常分支被稱作“左子樹”或“右子樹”。二元樹的分支具有左右次序，不能随意顛倒。\n二元樹的第\n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n層至多擁有\n  \n    \n      \n        \n          2\n          \n            i\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle 2^{i-1}}\n  \n個節點；深度為\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n的二元樹至多總共有\n  \n    \n      \n        \n          2\n          \n            k\n            +\n            1\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{k+1}-1}\n  \n個節點（定义根节点所在深度 \n  \n    \n      \n        \n          k\n          \n            0\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle k_{0}=0}\n  \n），而總計擁有節點數符合的，稱為「完美二叉树」；深度為\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n個節點的二元樹，當且僅當其中的每一節點，都可以和深度\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n的滿二元樹，序號1到\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n的節點一對一對應時，稱為「完全二叉树」。\n與普通樹不同，普通樹的節點個數至少為1，而二元樹的節點個數可以為0；普通樹節點的最大分支度沒有限制，而二元樹節點的最大分支度為2；普通樹的節點無左、右次序之分，而二元樹的節點有左、右次序之分。\n二元樹通常作為資料結構應用，典型用法是對節點定義一個標記函數，將一些值與每個節點相關聯。這樣標記的二元樹就可以實現二元搜尋樹和二元堆積，並應用於高效率的搜索和排序。\n\n圖論中的定義\n二元樹是一個連通的無環圖，並且每一個頂點的度不大於3。有根二元樹還要滿足根節點的度不大於2。有了根節點之後，每個顶点定義了唯一的父節點，和最多2個子節點。然而，沒有足夠的資訊來區分左節點和右節點。如果不考慮連通性，允許圖中有多個連通分量，這樣的結構叫做森林。\n\n性质\n二元樹是一個有根树，並且每個節點最多有2個子節點。非空的二叉樹，若樹葉總數為 \n  \n    \n      \n        \n          n\n          \n            0\n          \n        \n      \n    \n    {\\displaystyle n_{0}}\n  \n，分支度為2的總數為 \n  \n    \n      \n        \n          n\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle n_{2}}\n  \n，則 \n  \n    \n      \n        \n          n\n          \n            0\n          \n        \n        =\n        \n          n\n          \n            2\n          \n        \n        +\n        1\n      \n    \n    {\\displaystyle n_{0}=n_{2}+1}\n  \n。\n\n特殊类型\n滿二元樹\n在一棵二元樹中，每个节点都要么有0个子节点，要么有2个子节点，则这种二叉树称作满二叉树（Full Binary Tree）。\n满二叉树亦可通过如下递归定义得到：\n\n仅有单个节点（根节点）的二叉树是满二叉树；\n根节点有2个子树且均为满二叉树的二叉树是满二叉树。\n\n完美二叉树\n一棵深度為\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n，且有\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{k}-1}\n  \n個節點的二元樹，稱為完美二元樹（Perfect Binary Tree）。這種樹的特點是其中所有内部节点都有两个子节点，并且所有叶子都处于同一深度。\n\n性质\n对于一棵深度为 \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n 的完美二叉树：\n\n共有 \n  \n    \n      \n        \n          2\n          \n            k\n            +\n            1\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{k+1}-1}\n  \n 个结点\n结点个数一定为奇数\n第 \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n 层有 \n  \n    \n      \n        \n          2\n          \n            i\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle 2^{i-1}}\n  \n 个结点\n有 \n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle 2^{k}}\n  \n 个叶子\n\n完全二叉树\n在一颗二元樹中，若除最後一層外的其餘層都是滿的，並且最後一層要么是满的，要么在右邊缺少連續若干節點，則此二元樹為完全二元樹（Complete Binary Tree）。具有\n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n個節點的完全二元樹的深度為\n  \n    \n      \n        l\n        o\n        \n          g\n          \n            2\n          \n        \n        n\n        +\n        1\n      \n    \n    {\\displaystyle log_{2}n+1}\n  \n。深度為\n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n的完全二元樹，至少有\n  \n    \n      \n        \n          2\n          \n            k\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle 2^{k-1}}\n  \n個節點，至多有\n  \n    \n      \n        \n          2\n          \n            k\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{k}-1}\n  \n個節點。\n\n存儲\n在程式設計語言中能用多種方法來構造二元樹。\n\n順序存儲表示\n二元樹可以用陣列或链表來存儲，若是滿二元樹就能緊湊排列而不浪費空間。如果某個節點的索引為i，（假設根節點的索引為0）則在它左子節點的索引會是\n  \n    \n      \n        2\n        i\n        +\n        1\n      \n    \n    {\\displaystyle 2i+1}\n  \n，以及右子節點會是\n  \n    \n      \n        2\n        i\n        +\n        2\n      \n    \n    {\\displaystyle 2i+2}\n  \n；而它的父節點（如果有）索引則為\n  \n    \n      \n        \n          ⌊\n          \n            \n              \n                i\n                −\n                1\n              \n              2\n            \n          \n          ⌋\n        \n      \n    \n    {\\displaystyle \\left\\lfloor {\\frac {i-1}{2}}\\right\\rfloor }\n  \n。這種方法更有利於緊湊存儲和更好的訪問的局部性，特別是在前序遍歷中。然而，它需要連續的存儲空間，這樣在存儲高度為h的n個節點所組成的一般樹時，將浪費很多空間。在最糟糕的情況下，如果深度為h的二元樹其每個節點都只有右孩子，則該存儲結構需要佔用\n  \n    \n      \n        \n          2\n          \n            h\n          \n        \n        −\n        1\n      \n    \n    {\\displaystyle 2^{h}-1}\n  \n的空間，實際上卻只有h個節點，浪費了不少空間，是順序存儲結構的一大缺點。\n\n存储结构\n基本操作\n二叉鏈表存儲表示\n在使用記錄或記憶體位址指標的程式設計語言中，二叉樹通常用樹結點結構來存儲。有時也包含指向唯一的父節點的指標。如果一個結點的子結點個數小於2，一些子結點指針可能為空值，或者為特殊的哨兵結點。 \n使用鏈表能避免順序儲存浪費空間的問題，演算法和結構相對簡單，但使用二叉鏈表，由於缺乏父鏈的指引，在找回父節點時需要重新掃描樹得知父節點的節點位址。\n\n存儲結構\n基本操作\n三叉鏈表存儲表示\n改進於二叉鏈表，增加父節點的指引，能更好地實現節點間的訪問，不過演算法相對複雜。\n當二叉樹用三叉鏈表表示時，有N個結點，就會有N+2個空指針。\n\n存儲結構\n基本操作\n遍历\n我們經常希望訪問樹中的每一個結點並且查看它的值。有很多常見的順序來訪問所有的結點，而且每一種都有有用的性質。\n\n深度優先遍歷\n在深度優先順序中，我們希望從根結點訪問最遠的結點。和圖的深度優先搜索不同的是，不需記住訪問過的每一個結點，因為樹中不會有環。前序，中序和後序遍歷都是深度優先遍歷的特例。\n\n前（先）序、中序、後序遍歷\n遍歷二叉樹：L、D、R分別表示遍歷左子樹、訪問根結點和遍歷右子樹，則先(根)序遍歷二叉樹的順序是DLR，中(根)序遍歷二叉樹的順序是LDR，後(根)序遍歷二叉樹的順序是LRD。還有按層遍歷二叉樹。這些方法的時間複雜度都是O(n)，n為結點個數。\n如果T2是由有序樹T轉換而來的二叉樹，那麼T中結點的前序就是T2中結點的前序，T中結點的後序就是T2中結點的中序。任何一棵二叉樹的葉結點在先序、中序和後序遍歷中的相對次序不發改變。設n,m為一棵二叉樹上的兩個結點，在中序遍歷時，n在m前的條件是n在m的左方。前序序列和中序序列相同的二叉樹為空樹或任一結點均無左孩子的非空二叉樹；中序序列和後序序列相同的二叉樹為空樹或任一結點均無右孩子的非空二叉樹；前序序列和後序序列相同的二叉樹為空樹或僅有一個結點的二叉樹。\n假設我們有一個包含值的value和指向兩個子結點的left和right的樹結點結構。我們可以寫出這樣的過程：\n\nvisit(node)\n    print node.value\n    if node.left  != null then visit(node.left)\n    if node.right != null then visit(node.right)\n\n這樣會用前序打印出樹中的值。在前序，每個結點在訪問它的子結點之前訪問。類似地，如果打印語句在最後，每個結點在訪問他的子節點之後訪問，樹中的值會用後序來打印。在這兩種情況中，左子樹中的值比右子樹中得值先打印。\n\nvisit(node)\n    if node.left  != null then visit(node.left)\n    print node.value\n    if node.right != null then visit(node.right)\n\n最後，上面的中序遍歷，每個結點在訪問左子樹和右子樹之間訪問。這在遍歷二叉搜尋樹時很常用，因為它能用遞增的順序來遍歷所有的值。\n為什麼呢？如果n是二叉搜尋樹的結點，那麼n的左子樹的所有結點的值都比n的值要小，而且n的右子樹的所有節點的值都比n的值要大。因此，如果我們順序遍歷左子樹，然後訪問n，然後順序遍歷右子樹。我們就已經循序存取了整個樹。\n后序遍历伪代码如下：\n\nvisit(node)\n    if node.left  != null then visit(node.left)\n    if node.right != null then visit(node.right)\n    print node.value\n\n以上的遞迴演算法使用與樹的高度成比例的棧空間。如果我們在每個結點中存儲指向父結點的指標，那樣可以使用反覆運算演算法，只使用常數空間實現所有這些遍歷。然而，指向父結點的指標佔用更多的空間。這只在需要指向父節點的指標或棧空間有限時才使用。例如，\n這是一個中序遍歷的反覆運算演算法：\n\nvisit(root)\n    prev    := null\n    current := root\n    next    := null\n    \n    while current != null\n        if prev == current.parent\n            prev := current\n            next := current.left\n        if next == null or prev == current.left\n            print current.value\n            prev := current\n            next := current.right\n        if next == null or prev == current.right\n            prev := current\n            next := current.parent\n        current := next\n\n廣度優先遍歷\n和深度優先遍歷不同，廣度優先遍歷會先訪問離根節點最近的節點。二叉樹的廣度優先遍歷又稱按層次遍歷。演算法借助佇列實現。\n\n轉換自多叉樹\n一般有序樹可映射为二叉樹，但反之未必成立。\nn叉樹轉換為二叉樹的方法：二叉樹中結點x的左子結點為n叉樹中結點x的左子結點；二叉樹中結點x的右子結點為n叉樹中結點x的第一個右邊的同級結點y。\n二叉树当且仅当根节点没有右子结点时可转换为n叉树。\n例如，在左邊的樹中，A有6個子結點{B,C,D,E,F,G}。它能被轉換成右邊的二叉樹。\n\n將一棵樹轉換為二叉樹的方法：\n在兄弟之間加一連線；\n對每個結點，除了其左孩子外，去除其與其餘孩子之間的聯繫；\n以樹的根結點為軸心，將整樹順時針轉45度。\n\n樹的二叉鏈表標記法（孩子兄弟標記法）\n樹的二叉鏈表標記法（孩子兄弟標記法）是樹和二叉樹轉換的媒介。\n\n存儲結構\n基本操作\n線索二叉樹\n線索二叉樹（英語：threaded binary tree，保留遍歷時結點在任一序列的前驅和後繼的資訊）：若結點有左子樹，則其lchild域指示其左孩子，否則令lchild域指示其前驅；若結點有右子樹，則其rchild域指示其右孩子，否則令rchild指示其後繼。還需在結點結構中增加兩個標誌域LTag和RTag。LTag=0時，lchild域指示結點的左孩子，LTag=1時，lchild域指示結點的前驅；RTag=0時，rchild域指示結點的右孩子，RTag=1時，rchild域指示結點的後繼。以這種結點結構構成的二叉鏈表作為二叉樹的存儲結構，叫做線索鏈表，其中指向結點前驅和後繼的指標叫做線索，加上線索的二叉樹稱為線索二叉樹。對二叉樹以某種次序遍歷使其變為線索二叉樹的過程叫做線索化。若對二叉樹進行中序遍歷，則所得的線索二叉樹稱為中序線索二叉樹，線索鏈表稱為為中序線索鏈表。線索二叉樹是一種物理結構。\n\n在中序線索樹找結點後繼的規律是：若其右標誌為1，則右鏈為線索，指示其後繼，否則遍歷其右子樹時訪問的第一個結點（右子樹最左下的結點）為其後繼；找結點前驅的規律是：若其左標誌為1，則左鏈為線索，指示其前驅，否則遍歷左子樹時最後訪問的一個結點（左子樹中最右下的結點）為其前驅。\n在後序線索樹中找到結點的後繼分三種情況：\n\n若結點是二叉樹的根，則其後繼為空；\n若結點是其雙親的右孩子，或是其雙親的左孩子且其雙親沒有右子樹，則其後繼即為雙親結點；\n若結點是其雙親的左孩子，且其雙親有右子樹，則其後繼為雙親右子樹上按後序遍歷列出的第一個結點。\n\n二叉線索存儲表示\n存儲結構\n二叉樹的二叉線索存儲表示：在線索鏈表上添加一個頭結點，並令其lchild域的指標指向二叉樹的根結點，其rchild域的指標指向中序遍歷時訪問的最後一個結點。令二叉樹中序序列中的第一個結點的lchild域指標和最後一個結點的rchild域的指標均指向頭結點，這樣就建立了一個雙向線索鏈表。二叉樹常採用二叉鏈表方式存儲。\n\n基本操作\n外部链接\n\nbinary trees（页面存档备份，存于互联网档案馆） entry in the FindStat（页面存档备份，存于互联网档案馆）数据库\nGamedev.net introduction on binary trees（页面存档备份，存于互联网档案馆）\n二叉树归纳证明（页面存档备份，存于互联网档案馆）\nBalanced binary search tree on array How to create bottom-up an Ahnentafel list, or a balanced binary search tree on array（页面存档备份，存于互联网档案馆）\nBinary trees and Implementation of the same with working code examples"}
{"title": "2-3-4树", "text": "2-3-4树（英語：2–3–4 tree）在计算机科学中是阶为4的B树。\n大体同B树，2-3-4树是一种自平衡数据结构，可用於實作字典。它可以在\n  \n    \n      \n        \n          O\n        \n        (\n        log\n        ⁡\n        n\n        )\n      \n    \n    {\\displaystyle {\\text{O}}(\\log n)}\n  \n时间内查找、插入和删除，这里的n是树中元素的数目。\n2-3-4树在多数编程语言中实现起来相对困难，因为在树上的操作涉及大量特殊情况。红黑树实现起来更简单一些，所以可以用它来替代。\n\n背景\n2-3-4树把数据存储在叫做元素的单独单元中。它们组合成节点，每个节点都是下列之一\n\n2-节点，就是说，它包含1个元素和2个子節點，\n3-节点，就是说，它包含2个元素和3个子節點，\n4-节点，就是说，它包含3个元素和4個子節點。\n\n每个子節點（可能为空）都是一个子2-3-4树。根节点是其中没有父亲的那个节点；它在遍历树的时候充当起点，因为从它可以到达所有的其他节点。叶子节点是有至少一个空子節點的节点。\n同B树一样，2-3-4树是有序的：每个元素必须大于或等于它左边的和它的左子树中的任何其他元素。每个子節點因此成为了由它的左和右元素界定的一个区间。\n2-3-4树是紅黑樹的一种等同，这意味着它们是等价的数据结构。换句话说，对于每个2-3-4树，都存在着至少一个数据元素是相同次序的红黑树。在2-3-4树上的插入和删除操作也等价于在红黑树中的颜色翻转和旋转。这使得它成为理解红黑树背后的逻辑的重要工具。"}
